<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="每个人都应该考虑采用的Linux内核安全可调原文连接：https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;linux-kernel-hardening&#x2F; 本文介绍了一些Linux内核的功能，这些功能帮助我们保持生产系统更安全。我们将深入探讨它们的工作原理以及为什么您也应该考虑启用它们。">
<meta property="og:type" content="article">
<meta property="og:title" content="每个人都应该考虑采用的 Linux 内核安全可调">
<meta property="og:url" content="http://example.com/2024/03/15/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E9%87%87%E7%94%A8%E7%9A%84%20Linux%20%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E5%8F%AF%E8%B0%83/index.html">
<meta property="og:site_name" content="萝卜的博客">
<meta property="og:description" content="每个人都应该考虑采用的Linux内核安全可调原文连接：https:&#x2F;&#x2F;blog.cloudflare.com&#x2F;linux-kernel-hardening&#x2F; 本文介绍了一些Linux内核的功能，这些功能帮助我们保持生产系统更安全。我们将深入探讨它们的工作原理以及为什么您也应该考虑启用它们。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.hxzhouh.com/blog-images/2024/03/b6bf3148716461c32a9f1e5447cb2c62.png">
<meta property="og:image" content="https://images.hxzhouh.com/blog-images/2024/03/a960262885fbf648dbdc2bd800cde2ca.png">
<meta property="og:image" content="https://images.hxzhouh.com/blog-images/2024/03/46b61bf0a9163c9836837b598bc64d9e.png">
<meta property="og:image" content="https://images.hxzhouh.com/blog-images/2024/03/70708d7d7185c3edd9a77c712198af8c.png">
<meta property="article:published_time" content="2024-03-15T01:42:00.000Z">
<meta property="article:modified_time" content="2024-03-15T01:42:25.869Z">
<meta property="article:author" content="hxzhouh">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="安全">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.hxzhouh.com/blog-images/2024/03/b6bf3148716461c32a9f1e5447cb2c62.png">


<link rel="canonical" href="http://example.com/2024/03/15/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E9%87%87%E7%94%A8%E7%9A%84%20Linux%20%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E5%8F%AF%E8%B0%83/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/03/15/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E9%87%87%E7%94%A8%E7%9A%84%20Linux%20%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E5%8F%AF%E8%B0%83/","path":"2024/03/15/每个人都应该考虑采用的 Linux 内核安全可调/","title":"每个人都应该考虑采用的 Linux 内核安全可调"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>每个人都应该考虑采用的 Linux 内核安全可调 | 萝卜的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2D664FV9XT"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2D664FV9XT","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="萝卜的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">萝卜的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E9%87%87%E7%94%A8%E7%9A%84Linux%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E5%8F%AF%E8%B0%83"><span class="nav-number">1.</span> <span class="nav-text">每个人都应该考虑采用的Linux内核安全可调</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8"><span class="nav-number">1.1.</span> <span class="nav-text">安全启动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%AD%BE%E5%90%8D%E7%9A%84%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">内核模块签名的密钥管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KEXEC"><span class="nav-number">1.1.2.</span> <span class="nav-text">KEXEC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80%E9%9A%8F%E6%9C%BA%E5%8C%96%EF%BC%88KASLR%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">内核地址空间布局随机化（KASLR）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E5%86%85%E6%A0%B8%E6%8C%87%E9%92%88"><span class="nav-number">1.2.1.</span> <span class="nav-text">受限制的内核指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lockdown-LSM"><span class="nav-number">1.3.</span> <span class="nav-text">Lockdown LSM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">1.4.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hxzhouh</p>
  <div class="site-description" itemprop="description">关注后端开发，性能优化以及个人成长</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/15/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E9%87%87%E7%94%A8%E7%9A%84%20Linux%20%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E5%8F%AF%E8%B0%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hxzhouh">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="萝卜的博客">
      <meta itemprop="description" content="关注后端开发，性能优化以及个人成长">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="每个人都应该考虑采用的 Linux 内核安全可调 | 萝卜的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          每个人都应该考虑采用的 Linux 内核安全可调
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-15 09:42:00 / 修改时间：09:42:25" itemprop="dateCreated datePublished" datetime="2024-03-15T09:42:00+08:00">2024-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/blog/" itemprop="url" rel="index"><span itemprop="name">blog</span></a>
        </span>
    </span>

  
    <span id="/2024/03/15/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E9%87%87%E7%94%A8%E7%9A%84%20Linux%20%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E5%8F%AF%E8%B0%83/" class="post-meta-item twikoo_visitors" data-flag-title="每个人都应该考虑采用的 Linux 内核安全可调" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="twikoo_visitors"></span>
    </span>
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="每个人都应该考虑采用的Linux内核安全可调"><a href="#每个人都应该考虑采用的Linux内核安全可调" class="headerlink" title="每个人都应该考虑采用的Linux内核安全可调"></a>每个人都应该考虑采用的Linux内核安全可调</h1><p>原文连接：<a target="_blank" rel="noopener" href="https://blog.cloudflare.com/linux-kernel-hardening/">https://blog.cloudflare.com/linux-kernel-hardening/</a></p>
<p>本文介绍了一些Linux内核的功能，这些功能帮助我们保持生产系统更安全。我们将深入探讨它们的工作原理以及为什么您也应该考虑启用它们。</p>
<span id="more"></span>

<p><img src="https://images.hxzhouh.com/blog-images/2024/03/b6bf3148716461c32a9f1e5447cb2c62.png" alt="Linux内核安全调整：每个人都应该考虑采用的方法"></p>
<p>Linux内核是许多现代生产系统的核心。它决定了何时允许运行任何代码以及哪些程序&#x2F;用户可以访问哪些资源。它管理内存，调解对硬件的访问，并在程序运行时的幕后代表程序执行大部分工作。由于内核始终参与任何代码执行，它处于最佳位置来保护系统免受恶意程序的侵害，执行所需的系统安全策略，并为更安全的生产环境提供安全功能。</p>
<p>在本文中，我们将回顾Cloudflare在Linux内核安全配置方面的一些使用方法，以及它们如何帮助阻止或减少潜在的系统妥协。</p>
<h2 id="安全启动"><a href="#安全启动" class="headerlink" title="安全启动"></a>安全启动</h2><p>当机器（无论是笔记本还是服务器）启动时，它经历了几个引导阶段：</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/a960262885fbf648dbdc2bd800cde2ca.png" alt="image3-17"></p>
<p>在安全启动架构中，上图中的每个阶段在传递执行权之前都会验证下一个阶段的完整性，从而形成所谓的安全启动链。这样，“可信度”就扩展到引导链中的每个组件，因为如果我们验证了特定阶段的代码完整性，我们可以相信该代码可以验证下一个阶段的完整性。</p>
<p>我们之前已经介绍过Cloudflare在引导过程的初始阶段实现安全启动的方法。在本文中，我们将重点介绍Linux内核。</p>
<p>安全启动是任何操作系统安全机制的基石。Linux内核是操作系统安全配置和策略的主要执行者，因此我们必须确保Linux内核本身没有被篡改。在我们之前关于安全启动的文章中，我们展示了如何使用UEFI Secure Boot来确保Linux内核的完整性。</p>
<p>但接下来会发生什么呢？内核执行后，它可能尝试加载其他驱动程序，或者在Linux世界中称为内核模块。内核模块加载不仅限于引导过程。模块可以在运行时的任何时候加载——当插入新设备并需要驱动程序时，需要对网络堆栈进行一些附加扩展（例如，用于细粒度防火墙规则），或者只是由系统管理员手动加载。</p>
<p>然而，不受控制的内核模块加载可能对系统完整性构成重大风险。与常规程序不同，内核模块是直接注入并在Linux内核地址空间中直接执行的代码片段。在不同的内核模块和核心内核子系统中，代码和数据之间没有分离，因此一切都可以访问一切。这意味着一个恶意的内核模块可以完全使操作系统的可信度失效，并使安全启动变得无效。例如，考虑一个简单的Debian 12（Bookworm安装），但启用了SELinux配置和强制执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ lsb_release --all</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Debian</span><br><span class="line">Description:	Debian GNU/Linux 12 (bookworm)</span><br><span class="line">Release:	12</span><br><span class="line">Codename:	bookworm</span><br><span class="line">ignat@dev:~$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux dev 6.1.0-18-cloud-amd64 <span class="comment">#1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 GNU/Linux</span></span><br><span class="line">ignat@dev:~$ sudo getenforce</span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure>

<p>现在我们需要进行一些研究。首先，我们看到我们正在运行6.1.76 Linux内核。如果我们探索源代码，我们会发现<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.1.76/source/security/selinux/hooks.c#L107">在内核内部，SELinux配置存储在一个单例结构中</a>，该结构<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.1.76/source/security/selinux/include/security.h#L92">定义如下</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selinux_state</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY_SELINUX_DISABLE</span></span><br><span class="line">	<span class="type">bool</span> disabled;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY_SELINUX_DEVELOP</span></span><br><span class="line">	<span class="type">bool</span> enforcing;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">bool</span> checkreqprot;</span><br><span class="line">	<span class="type">bool</span> initialized;</span><br><span class="line">	<span class="type">bool</span> policycap[__POLICYDB_CAP_MAX];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">status_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">status_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">selinux_avc</span> *<span class="title">avc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">selinux_policy</span> __<span class="title">rcu</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">policy_mutex</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，如果内核配置启用了<code>CONFIG_SECURITY_SELINUX_DEVELOP</code>，则该结构将具有一个名为<code>enforcing</code>的布尔变量，该变量控制SELinux在运行时的强制执行状态。这正是上面的<code>$ sudo getenforce</code>命令返回的内容。我们可以再次检查Debian内核确实已启用该配置选项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep CONFIG_SECURITY_SELINUX_DEVELOP /boot/config-`<span class="built_in">uname</span> -r` CONFIG_SECURITY_SELINUX_DEVELOP=y</span><br></pre></td></tr></table></figure>

<p>很好！现在我们在内核中有一个变量，负责某种安全执行，我们可以尝试攻击它。但有一个问题是<code>__randomize_layout</code>属性：由于我们的Debian内核实际上没有设置<code>CONFIG_SECURITY_SELINUX_DISABLE</code>，因此<code>enforcing</code>实际上将是结构体的第一个成员。因此，如果我们知道结构体的位置，我们立即就知道了<code>enforcing</code>标志的位置。使用<code>__randomize_layout</code>，在内核编译期间，编译器可能会将成员放置在结构体的任意位置，因此创建通用的漏洞利用变得更加困难。但是，在内核中任意结构体随机化<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.1.76/source/security/Kconfig.hardening#L301">可能会引入性能影响</a>，因此通常被禁用，并且对于Debian内核而言，它是被禁用的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep RANDSTRUCT /boot/config-`<span class="built_in">uname</span> -r` CONFIG_RANDSTRUCT_NONE=y</span><br></pre></td></tr></table></figure>

<p>我们还可以使用<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/devel/pahole/pahole.git/">pahole工具</a>和内核调试符号（如果可用）或（在现代内核上，如果启用）内核<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/next/bpf/btf.html">BTF</a>信息来确认<code>enforcing</code>标志的编译位置。我们将使用后者：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ pahole -C selinux_state /sys/kernel/btf/vmlinux</span><br><span class="line">struct selinux_state &#123;</span><br><span class="line">	bool                       enforcing;            /*     0     1 */</span><br><span class="line">	bool                       checkreqprot;         /*     1     1 */</span><br><span class="line">	bool                       initialized;          /*     2     1 */</span><br><span class="line">	bool                       policycap[8];         /*     3     8 */</span><br><span class="line"></span><br><span class="line">	/* XXX 5 bytes hole, try to pack */</span><br><span class="line"></span><br><span class="line">	struct page *              status_page;          /*    16     8 */</span><br><span class="line">	struct mutex               status_lock;          /*    24    32 */</span><br><span class="line">	struct selinux_avc *       avc;                  /*    56     8 */</span><br><span class="line">	/* --- cacheline 1 boundary (64 bytes) --- */</span><br><span class="line">	struct selinux_policy *    policy;               /*    64     8 */</span><br><span class="line">	struct mutex               policy_mutex;         /*    72    32 */</span><br><span class="line"></span><br><span class="line">	/* size: 104, cachelines: 2, members: 9 */</span><br><span class="line">	/* <span class="built_in">sum</span> members: 99, holes: 1, <span class="built_in">sum</span> holes: 5 */</span><br><span class="line">	/* last cacheline: 40 bytes */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>因此，<code>enforcing</code>确实位于结构体的开头，我们甚至不需要成为特权用户即可确认这一点。</p>
<p>太棒了！我们只需要内核内的<code>selinux_state</code>变量的运行时地址：<br>（shell&#x2F;bash）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ sudo grep selinux_state /proc/kallsyms</span><br><span class="line">ffffffffbc3bcae0 B selinux_state</span><br></pre></td></tr></table></figure>

<p>有了所有这些信息，我们可以编写一个几乎完全符合教科书的简单内核模块来操纵SELinux状态：</p>
<p>Mymod.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mod_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> *selinux_enforce = (<span class="type">bool</span> *)<span class="number">0xffffffffbc3bcae0</span>;</span><br><span class="line">	*selinux_enforce = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mod_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mod_init);</span><br><span class="line">module_exit(mod_fini);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A somewhat malicious module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Ignat Korchagin &lt;ignat@cloudflare.com&gt;&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以及相应的<code>Kbuild</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-m := mymod.o</span><br></pre></td></tr></table></figure>

<p>使用这两个文件，我们可以根据<a target="_blank" rel="noopener" href="https://docs.kernel.org/kbuild/modules.html">官方内核文档</a>构建一个完整的内核模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">cd</span> mymod/</span><br><span class="line">ignat@dev:~/mymod$ <span class="built_in">ls</span></span><br><span class="line">Kbuild  mymod.c</span><br><span class="line">ignat@dev:~/mymod$ make -C /lib/modules/`<span class="built_in">uname</span> -r`/build M=<span class="variable">$PWD</span></span><br><span class="line">make: Entering directory <span class="string">&#x27;/usr/src/linux-headers-6.1.0-18-cloud-amd64&#x27;</span></span><br><span class="line">  CC [M]  /home/ignat/mymod/mymod.o</span><br><span class="line">  MODPOST /home/ignat/mymod/Module.symvers</span><br><span class="line">  CC [M]  /home/ignat/mymod/mymod.mod.o</span><br><span class="line">  LD [M]  /home/ignat/mymod/mymod.ko</span><br><span class="line">  BTF [M] /home/ignat/mymod/mymod.ko</span><br><span class="line">Skipping BTF generation <span class="keyword">for</span> /home/ignat/mymod/mymod.ko due to unavailability of vmlinux</span><br><span class="line">make: Leaving directory <span class="string">&#x27;/usr/src/linux-headers-6.1.0-18-cloud-amd64&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果现在尝试加载此模块，系统可能不允许，因为SELinux策略的原因：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~/mymod$ sudo insmod mymod.ko insmod: ERROR: could not load module mymod.ko: Permission denied</span><br></pre></td></tr></table></figure>

<p>我们可以通过将模块复制到标准模块路径中的某个位置来解决此问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~/mymod$ sudo <span class="built_in">cp</span> mymod.ko /lib/modules/`<span class="built_in">uname</span> -r`/kernel/crypto/</span><br></pre></td></tr></table></figure>

<p>现在让我们试试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~/mymod$ sudo getenforce Enforcing ignat@dev:~/mymod$ sudo insmod /lib/modules/`<span class="built_in">uname</span> -r`/kernel/crypto/mymod.ko ignat@dev:~/mymod$ sudo getenforce Permissive</span><br></pre></td></tr></table></figure>

<p>我们不仅通过恶意内核模块静默地禁用了SELinux保护，而且还完成了这一操作。正常的<code>sudo setenforce 0</code>即使被允许，也会通过官方的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.1.76/source/security/selinux/selinuxfs.c#L173">selinuxfs接口，并发出审核消息</a>。我们的代码直接操作内核内存，因此没有人会发出警报。这说明为什么不受控制的内核模块加载非常危险，这也是为什么大多数安全标准和商业安全监控产品主张密切监控内核模块加载的原因。</p>
<p>但是，在Cloudflare上，我们不需要监视内核模块。让我们在Cloudflare生产内核上重复这个过程（为简洁起见，跳过模块重新编译）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep MODULE_SIG /boot/config-6.1.0-18-cloud-amd64</span><br><span class="line">CONFIG_MODULE_SIG_FORMAT=y</span><br><span class="line">CONFIG_MODULE_SIG=y</span><br><span class="line"><span class="comment"># CONFIG_MODULE_SIG_FORCE is not set</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>当尝试加载模块时，我们会收到“Key was rejected by service”错误，并且内核日志将显示以下消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~/mymod$ sudo dmesg | <span class="built_in">tail</span> -n 1 [41515.037031] Loading of unsigned module is rejected</span><br></pre></td></tr></table></figure>

<p>这是因为Cloudflare内核要求所有内核模块具有有效的签名，因此我们无需担心恶意模块在某个时间点被加载：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep MODULE_SIG_FORCE /boot/config-`<span class="built_in">uname</span> -r` CONFIG_MODULE_SIG_FORCE=y</span><br></pre></td></tr></table></figure>

<p>为了完整起见，值得注意的是，Debian标准内核也支持模块签名，但不强制执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep MODULE_SIG /boot/config-6.1.0-18-cloud-amd64 CONFIG_MODULE_SIG_FORMAT=y CONFIG_MODULE_SIG=y <span class="comment"># CONFIG_MODULE_SIG_FORCE is not set …</span></span><br></pre></td></tr></table></figure>

<p>上述配置意味着，如果可用，内核将验证模块签名。但是如果没有签名-模块将被加载，并发出警告消息，<a target="_blank" rel="noopener" href="https://docs.kernel.org/admin-guide/tainted-kernels.html">内核将被污染</a>。</p>
<h3 id="内核模块签名的密钥管理"><a href="#内核模块签名的密钥管理" class="headerlink" title="内核模块签名的密钥管理"></a>内核模块签名的密钥管理</h3><p>签名的内核模块非常好，但是它会带来密钥管理问题：要签名一个模块，我们需要一个由内核信任的签名密钥对。密钥对的公钥通常直接嵌入到内核二进制文件中，因此内核可以轻松使用它来验证模块签名。密钥对的私钥需要受到保护和安全，因为如果泄漏，任何人都可以编译和签名一个潜在恶意的内核模块，而我们的内核将接受它。</p>
<p>但是，如何消除丢失风险呢？首先不要一开始就拥有它！幸运的是，内核构建系统<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.6.17/source/certs/Makefile#L36">将为模块签名生成一个随机密钥对</a>，如果没有提供密钥。在Cloudflare，我们使用该功能在内核编译阶段对所有内核模块进行签名。但是，在编译和签名完成后，我们不会将私钥存储在安全的位置，而是销毁私钥：</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/46b61bf0a9163c9836837b598bc64d9e.png" alt="image1-19"></p>
<p>因此，根据上述过程：</p>
<ol>
<li>内核构建系统为模块签名生成了一个随机密钥对，并编译内核和模块</li>
<li>公钥嵌入到内核映像中，私钥用于签名所有模块</li>
<li>私钥被销毁</li>
</ol>
<p>通过这种方案，我们不仅无需担心模块签名密钥管理问题，而且我们还为每个发布到生产环境的内核使用不同的密钥。因此，即使某个特定的构建过程被劫持并且签名密钥未被销毁并且有可能泄漏，当发布内核更新时，该密钥将不再有效。</p>
<p>然而，值得注意的是，Debian内核的库存版本也支持模块签名，但不强制执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep MODULE_SIG /boot/config-6.1.0-18-cloud-amd64 CONFIG_MODULE_SIG_FORMAT=y CONFIG_MODULE_SIG=y <span class="comment"># CONFIG_MODULE_SIG_FORCE is not set …</span></span><br></pre></td></tr></table></figure>

<p>上述配置意味着，如果可用，内核将验证模块签名。但是如果没有签名-模块将被加载，并发出警告消息，<a target="_blank" rel="noopener" href="https://docs.kernel.org/admin-guide/tainted-kernels.html">内核将被污染</a>。</p>
<h3 id="KEXEC"><a href="#KEXEC" class="headerlink" title="KEXEC"></a>KEXEC</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kexec">KEXEC</a>（或<code>kexec_load()</code>）是Linux中一个有趣的系统调用，它允许一个内核直接执行（或跳转到）另一个内核。这个想法是在不经过完整的重新启动过程的情况下更快地切换&#x2F;更新&#x2F;降级内核，以减少潜在的系统停机时间。然而，它是在很久以前开发的，当时安全启动和系统完整性还不是一个问题。因此，它的原始设计存在安全缺陷，可以<a target="_blank" rel="noopener" href="https://mjg59.dreamwidth.org/28746.html">绕过安全启动并潜在地破坏系统完整性</a>。</p>
<p>我们可以根据<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/kexec_load.2.html">系统调用的定义</a>看到这些问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kexec_segment</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *buf;</span><br><span class="line">	<span class="type">size_t</span> bufsz;</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *mem;</span><br><span class="line">	<span class="type">size_t</span> memsz;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">long</span> <span class="title function_">kexec_load</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> entry, <span class="type">unsigned</span> <span class="type">long</span> nr_segments, <span class="keyword">struct</span> kexec_segment *segments, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>因此，内核期望的只是一组要执行的代码缓冲区。在当时，内核内部没有太多的数据解析的愿望，因此，解析要执行的内核映像是在用户空间中完成的，并且仅向内核提供其所需的数据。此外，为了在旧内核关闭时接管并且新内核尚未执行时，我们需要一个中间程序。在kexec世界中，此程序称为<a target="_blank" rel="noopener" href="https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git/tree/purgatory">purgatory</a>。因此，问题显而易见：我们向内核提供一堆代码，它将愉快地以最高特权级别执行它。但是，与原始内核或purgatory代码相反，我们可以轻松地提供类似于本文中演示的代码，该代码禁用SELinux（或对内核执行其他操作）。</p>
<p>在Cloudflare上，我们已经将<code>kexec_load()</code>禁用了一段时间，仅因为这个原因。使用kexec实现更快的重新启动的优点是，<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.6.17/source/kernel/Kconfig.kexec#L30">硬件可能未正确初始化</a>，因此即使没有安全问题，也不值得使用它。但是，kexec确实提供了一个有用的功能-它是Linux内核<a target="_blank" rel="noopener" href="https://docs.kernel.org/admin-guide/kdump/kdump.html">崩溃转储解决方案</a>的基础。简而言之，如果内核在生产中崩溃（由于错误或其他错误），备份内核（使用kexec预先加载）可以接管，收集并保存内存转储以供进一步调查。这使得在生产中更有效地调查内核和其他问题成为可能，因此它是一个强大的工具。</p>
<p>幸运的是，自从<a target="_blank" rel="noopener" href="https://mjg59.dreamwidth.org/28746.html">指出了kexec的原始问题</a>以来，Linux开发了一种替代的<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.6.17/source/kernel/Kconfig.kexec#L36">安全的kexec接口</a>：与其使用代码缓冲区，它期望使用包含要执行的内核映像和initrd的文件描述符，并在内核内部进行解析。因此，只能提供有效的内核映像。在此基础上，我们可以<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.6.17/source/kernel/Kconfig.kexec#L48">配置</a>并<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.6.17/source/kernel/Kconfig.kexec#L62">要求</a>kexec以确保所提供的映像具有正确的签名，因此只有经授权的代码可以在kexec场景中执行。一个安全的kexec配置如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep KEXEC /boot/config-`<span class="built_in">uname</span> -r` CONFIG_KEXEC_CORE=y CONFIG_HAVE_IMA_KEXEC=y <span class="comment"># CONFIG_KEXEC is not set CONFIG_KEXEC_FILE=y CONFIG_KEXEC_SIG=y CONFIG_KEXEC_SIG_FORCE=y CONFIG_KEXEC_BZIMAGE_VERIFY_SIG=y …</span></span><br></pre></td></tr></table></figure>

<p>以上配置确保了禁用了传统的<code>kexec_load()</code>系统调用，通过禁用<code>CONFIG_KEXEC</code>来实现，但仍然可以使用新的<code>kexec_file_load()</code>系统调用通过<code>CONFIG_KEXEC_FILE=y</code>进行Linux内核崩溃转储的配置，并强制执行签名检查（<code>CONFIG_KEXEC_SIG=y</code>和<code>CONFIG_KEXEC_SIG_FORCE=y</code>）。</p>
<p>请注意，Debian内核的库存版本启用了传统的<code>kexec_load()</code>系统调用，并且不强制执行<code>kexec_file_load()</code>的签名检查（类似于模块签名检查）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep KEXEC /boot/config-6.1.0-18-cloud-amd64 CONFIG_KEXEC=y CONFIG_KEXEC_FILE=y CONFIG_ARCH_HAS_KEXEC_PURGATORY=y CONFIG_KEXEC_SIG=y <span class="comment"># CONFIG_KEXEC_SIG_FORCE is not set CONFIG_KEXEC_BZIMAGE_VERIFY_SIG=y …</span></span><br></pre></td></tr></table></figure>

<h2 id="内核地址空间布局随机化（KASLR）"><a href="#内核地址空间布局随机化（KASLR）" class="headerlink" title="内核地址空间布局随机化（KASLR）"></a>内核地址空间布局随机化（KASLR）</h2><p>即使在库存的Debian内核上，如果您尝试在系统重新启动后重复我们在“安全启动”部分中描述的练习，您可能会发现它无法再禁用SELinux。这是因为我们在恶意内核模块中硬编码了<code>selinux_state</code>的内核地址，但现在地址已更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ sudo grep selinux_state /proc/kallsyms ffffffffb41bcae0 B selinux_state</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://docs.kernel.org/security/self-protection.html#kernel-address-space-layout-randomization-kaslr">内核地址空间布局随机化（或KASLR）</a>是一个简单的概念：它在每次启动时都会轻微且随机地移动内核代码和数据：</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/70708d7d7185c3edd9a77c712198af8c.png" alt="Screenshot-2024-03-06-at-13.53.23-2"></p>
<p>这是为了对抗基于对内核内部结构和代码位置的了解的有针对性的利用（如本文中的恶意模块）。对于像Debian这样的流行Linux发行版内核尤其有用，因为大多数用户使用相同的二进制文件，任何人都可以下载调试符号和包含所有内核内部地址的System.map文件。只要注意：它不会阻止模块加载和造成伤害，但它可能无法实现禁用SELinux的有针对性效果。相反，它将修改随机的内核内存片段，可能导致内核崩溃。</p>
<p>Cloudflare内核和Debian内核都启用了此功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep RANDOMIZE_BASE /boot/config-`<span class="built_in">uname</span> -r` CONFIG_RANDOMIZE_BASE=y</span><br></pre></td></tr></table></figure>

<h3 id="受限制的内核指针"><a href="#受限制的内核指针" class="headerlink" title="受限制的内核指针"></a>受限制的内核指针</h3><p>虽然KASLR有助于针对性的利用，但很容易绕过，因为每次只是通过单个随机偏移量移动所有内容，如上图所示。因此，如果攻击者知道至少一个运行时内核地址，他们可以通过将运行时地址从内核的System.map文件中的相同符号（函数或数据结构）的编译时地址中减去来恢复此偏移量。一旦他们知道了偏移量，他们就可以通过调整它们来恢复所有其他符号的地址。</p>
<p>因此，现代内核为了至少不将内核地址泄漏给非特权用户而采取了预防措施。其中一个主要的调整选项是<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#kptr-restrict">kptr_restrict sysctl</a>。将其至少设置为<code>1</code>以禁止普通用户查看内核指针是一个好主意：<br>（shell&#x2F;bash）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ sudo sysctl -w kernel.kptr_restrict=1</span><br><span class="line">kernel.kptr_restrict = 1</span><br><span class="line">ignat@dev:~$ grep selinux_state /proc/kallsyms</span><br><span class="line">0000000000000000 B selinux_state</span><br></pre></td></tr></table></figure>

<p>特权用户仍然可以查看指针：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ sudo grep selinux_state /proc/kallsyms ffffffffb41bcae0 B selinux_state</span><br></pre></td></tr></table></figure>

<p>类似于<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#kptr-restrict">kptr_restrict sysctl</a>，还有<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#dmesg-restrict">dmesg_restrict</a>，如果设置，将阻止普通用户读取内核日志（通过其消息也可能泄漏内核指针）。虽然您需要在每次启动时显式设置<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#kptr-restrict">kptr_restrict sysctl</a>的值（或使用一些系统sysctl配置实用程序，如<a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/latest/systemd-sysctl.service.html">此工具</a>），但您可以通过<code>CONFIG_SECURITY_DMESG_RESTRICT</code>内核配置选项来配置<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#dmesg-restrict">dmesg_restrict</a>的初始值。Cloudflare内核和Debian内核都通过这种方式强制执行<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#dmesg-restrict">dmesg_restrict</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep CONFIG_SECURITY_DMESG_RESTRICT /boot/config-`<span class="built_in">uname</span> -r` CONFIG_SECURITY_DMESG_RESTRICT=y</span><br></pre></td></tr></table></figure>

<p>值得注意的是，&#x2F;proc&#x2F;kallsyms和内核日志不是潜在的内核指针泄漏的唯一来源。Linux内核中有很多遗留问题，而且<a target="_blank" rel="noopener" href="https://docs.kernel.org/latest/admin-guide/kernel-parameters.html#debug-kernel-parameters">新的泄漏来源不断被发现和修复</a>。这就是为什么及时跟上最新的内核错误修复版本非常重要。</p>
<h2 id="Lockdown-LSM"><a href="#Lockdown-LSM" class="headerlink" title="Lockdown LSM"></a>Lockdown LSM</h2><p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/latest/admin-guide/LSM/index.html">Linux Security Modules (LSM)</a>是一个基于钩子的框架，用于在Linux内核中实现安全策略和强制访问控制。我们之前[介绍过我们使用的另一个LSM模块，BPF-LSM]。</p>
<p>BPF-LSM是我们内核安全性的一个有用的基础组件，但在本文中，我们要提到我们使用的另一个有用的LSM模块——<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/kernel_lockdown.7.html">Lockdown LSM</a>。Lockdown可以处于三种状态（由<code>/sys/kernel/security/lockdown</code>特殊文件控制）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">cat</span> /sys/kernel/security/lockdown [none] integrity confidentiality</span><br></pre></td></tr></table></figure>

<p><code>none</code>是未执行任何操作并且模块实际上被禁用的状态。当Lockdown处于<code>integrity</code>状态时，内核尝试阻止任何可能破坏其完整性的操作。我们在本文中已经涵盖了其中的一些示例：加载未签名的模块和通过KEXEC执行未签名的代码。但是，该LSM还尝试阻止<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/kernel_lockdown.7.html">LSM的man页中提到的其他潜在方式</a>。<code>confidentiality</code>是最严格的模式，其中Lockdown还尝试阻止内核信息泄漏。在实践中，这对于服务器工作负载来说可能过于严格，因为它会阻止所有运行时调试功能，如<code>perf</code>或eBPF。</p>
<p>让我们看看Lockdown LSM的实际效果。在一个基本的Debian系统上，初始状态是<code>none</code>，意味着没有被锁定：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">uname</span> -a Linux dev 6.1.0-18-cloud-amd64 <span class="comment">#1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 GNU/Linux ignat@dev:~$ cat /sys/kernel/security/lockdown [none] integrity confidentiality</span></span><br></pre></td></tr></table></figure>

<p>我们可以将系统切换到<code>integrity</code>模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">echo</span> integrity | sudo <span class="built_in">tee</span> /sys/kernel/security/lockdown integrity ignat@dev:~$ <span class="built_in">cat</span> /sys/kernel/security/lockdown none [integrity] confidentiality</span><br></pre></td></tr></table></figure>

<p>值得注意的是，我们只能将系统设置为更严格的状态，而不能返回。也就是说，一旦进入<code>integrity</code>模式，我们只能切换到<code>confidentiality</code>模式，而不能切换回<code>none</code>模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">echo</span> none | sudo <span class="built_in">tee</span> /sys/kernel/security/lockdown none <span class="built_in">tee</span>: /sys/kernel/security/lockdown: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>现在，即使在库存的Debian内核上，我们也无法再加载潜在恶意的未签名内核模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ sudo insmod mymod/mymod.ko insmod: ERROR: could not insert module mymod/mymod.ko: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>而且内核日志会友好地指出这是由于Lockdown LSM引起的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ sudo dmesg | <span class="built_in">tail</span> -n 1 [21728.820129] Lockdown: insmod: unsigned module loading is restricted; see man kernel_lockdown.7</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，Lockdown LSM有助于加强内核的安全性，否则可能不会启用其他强制执行位，如库存的Debian内核。</p>
<p>如果您自己编译内核，您可以更进一步，将<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.6.17/source/security/lockdown/Kconfig#L33">Lockdown LSM的初始状态设置为比none更严格的状态</a>。这正是我们为Cloudflare生产内核所做的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignat@dev:~$ grep LOCK_DOWN /boot/config-6.6.17-cloudflare-2024.2.9 <span class="comment"># CONFIG_LOCK_DOWN_KERNEL_FORCE_NONE is not set CONFIG_LOCK_DOWN_KERNEL_FORCE_INTEGRITY=y # CONFIG_LOCK_DOWN_KERNEL_FORCE_CONFIDENTIALITY is not set</span></span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们回顾了Cloudflare在Linux内核安全配置方面使用的一些有用方法。这只是一个小的子集，还有许多其他可用的功能，并且Linux内核社区不断开发、审查和改进更多功能。我们希望本文能够为您介绍这些安全功能，并且如果您尚未这样做，您可以考虑在Linux系统中启用它们。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux/" rel="tag"># linux</a>
              <a href="/tags/%E5%AE%89%E5%85%A8/" rel="tag"># 安全</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/03/12/%E4%BB%80%E4%B9%88%E6%98%AFmedium%20%E7%9A%84%20publication/" rel="prev" title="什么是medium 的 publication">
                  <i class="fa fa-angle-left"></i> 什么是medium 的 publication
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/03/15/Go%20tool%EF%BC%9Aexpvar%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%A6%E9%87%8F%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BE%85%E5%8A%A9%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E7%82%B9/" rel="next" title="Go tool: expvar 自定义度量数据，辅助定位性能瓶颈点">
                  Go tool: expvar 自定义度量数据，辅助定位性能瓶颈点 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">hxzhouh</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">48k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:54</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/hxzhouh" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  




<script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":true,"envId":"https://twikoo.hxzhouh.com/","el":"#twikoo-comments"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      CONFIG.twikoo.jsUrl || 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>
<style>
.post-block, .comments {
  overflow: visible;
}
.tk-owo-emotion {
  display: inline-block;
}
</style>

</body>
</html>
