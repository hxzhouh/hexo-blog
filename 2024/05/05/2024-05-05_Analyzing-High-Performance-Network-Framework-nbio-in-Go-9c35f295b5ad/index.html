<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/head.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/head.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/head.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hxzhouh.com","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"algolia":{"appID":"ZISROINTK6","apiKey":"970a441f5df78225c1ec616cceb70271","indexName":"hxzhouh-blog","hits":{"per_page":10,"labels":null,"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="A Deep Dive into Efficient Network Programming">
<meta property="og:type" content="article">
<meta property="og:title" content="Analyzing High-Performance Network Framework nbio in Go">
<meta property="og:url" content="https://hxzhouh.com/2024/05/05/2024-05-05_Analyzing-High-Performance-Network-Framework-nbio-in-Go-9c35f295b5ad/index.html">
<meta property="og:site_name" content="huizhou92">
<meta property="og:description" content="A Deep Dive into Efficient Network Programming">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://images.hxzhouh.com/blog-images/2024/05/8876d50feac67c7fe0d47c28960064e5.png">
<meta property="article:published_time" content="2024-05-05T04:24:00.000Z">
<meta property="article:modified_time" content="2024-05-17T15:51:07.419Z">
<meta property="article:author" content="huizhou92">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.hxzhouh.com/blog-images/2024/05/8876d50feac67c7fe0d47c28960064e5.png">


<link rel="canonical" href="https://hxzhouh.com/2024/05/05/2024-05-05_Analyzing-High-Performance-Network-Framework-nbio-in-Go-9c35f295b5ad/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://hxzhouh.com/2024/05/05/2024-05-05_Analyzing-High-Performance-Network-Framework-nbio-in-Go-9c35f295b5ad/","path":"2024/05/05/2024-05-05_Analyzing-High-Performance-Network-Framework-nbio-in-Go-9c35f295b5ad/","title":"Analyzing High-Performance Network Framework nbio in Go"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Analyzing High-Performance Network Framework nbio in Go | huizhou92</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2D664FV9XT"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2D664FV9XT","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="huizhou92" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">huizhou92</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">20</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">10</span></a></li><li class="menu-item menu-item-rss"><a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">38</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fab fa-algolia fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">Server:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">Client:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">Summary</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">huizhou92</p>
  <div class="site-description" itemprop="description">Backend engineer with a focus on Golang, cloud computing, data storage, and efficiency tools. Lifelong learner.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hxzhouh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxzhouh" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/@piaopiaopig" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;@piaopiaopig" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          Links
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://programmerscareer.com/" title="http:&#x2F;&#x2F;programmerscareer.com&#x2F;" rel="noopener" target="_blank">Tfrain</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hxzhouh.com/2024/05/05/2024-05-05_Analyzing-High-Performance-Network-Framework-nbio-in-Go-9c35f295b5ad/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="huizhou92">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="huizhou92">
      <meta itemprop="description" content="Backend engineer with a focus on Golang, cloud computing, data storage, and efficiency tools. Lifelong learner.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Analyzing High-Performance Network Framework nbio in Go | huizhou92">
      <meta itemprop="description" content="A Deep Dive into Efficient Network Programming">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Analyzing High-Performance Network Framework nbio in Go
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-05-05 12:24:00" itemprop="dateCreated datePublished" datetime="2024-05-05T12:24:00+08:00">2024-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-17 23:51:07" itemprop="dateModified" datetime="2024-05-17T23:51:07+08:00">2024-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="firestore-visitors-count"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>9 mins.</span>
    </span>
</div>

            <div class="post-description">A Deep Dive into Efficient Network Programming</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img src="https://images.hxzhouh.com/blog-images/2024/05/8876d50feac67c7fe0d47c28960064e5.png" alt="bac10"></p>
<h1>Introduction</h1>
<p>In this article, we’ll continue our in-depth analysis of another high-performance network programming framework: <code>nbio</code>.</p>
<p>The <code>nbio</code> project also includes <code>nbhttp</code> built on top of <code>nbio</code>, but that’s outside the scope of our discussion.</p>
<p>Like <code>evio</code>, <code>nbio</code> adopts the classic Reactor pattern. In fact, many asynchronous network frameworks in Go are designed based on this pattern.</p>
<p>Let’s start by running the <code>nbio</code> program code.</p>
<h1>Server:</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> ​</span><br><span class="line"> <span class="keyword">import</span> (</span><br><span class="line">     <span class="string">&quot;fmt&quot;</span></span><br><span class="line">     <span class="string">&quot;github.com/lesismal/nbio&quot;</span></span><br><span class="line"> )</span><br><span class="line"> ​</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     g := nbio.NewGopher(nbio.Config&#123;</span><br><span class="line">         Network:            <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">         Addrs:              []<span class="type">string</span>&#123;<span class="string">&quot;:8888&quot;</span>&#125;,</span><br><span class="line">         MaxWriteBufferSize: <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">     &#125;)</span><br><span class="line"> ​</span><br><span class="line">     g.OnData(<span class="function"><span class="keyword">func</span><span class="params">(c *nbio.Conn, data []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">         c.Write(<span class="built_in">append</span>([]<span class="type">byte</span>&#123;&#125;, data...))</span><br><span class="line">     &#125;)</span><br><span class="line"> ​</span><br><span class="line">     err := g.Start()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;nbio.Start failed: %v\n&quot;</span>, err)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     &#125;</span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">defer</span> g.Stop()</span><br><span class="line">     g.Wait()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Here, we create a new Engine instance using the <code>nbio.NewGopher()</code> function. We pass a <code>nbio.Config</code> struct to configure the Engine instance, including:</p>
<ul>
<li><code>Network</code>: The type of network to use, which is “TCP” in this case.</li>
<li><code>Addrs</code>: The addresses and ports the server should listen to, here it’s “:8888” (listening on port 8888 of the local machine).</li>
<li><code>MaxWriteBufferSize</code>: The maximum size of the write buffer, is set to 6MB here.</li>
</ul>
<p>Other configurations can be explored further. Then, we register a data reception callback function using <code>g.OnData()</code> the Engine instance. This callback function is invoked when data is received. It takes two parameters: the connection object <code>c</code> and the received data <code>data</code>. Inside the callback function, we use <code>c.Write()</code> a method to write the received data back to the client.</p>
<h1>Client:</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> ​</span><br><span class="line"> <span class="keyword">import</span> (</span><br><span class="line">     <span class="string">&quot;bytes&quot;</span></span><br><span class="line">     <span class="string">&quot;context&quot;</span></span><br><span class="line">     <span class="string">&quot;fmt&quot;</span></span><br><span class="line">     <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">     <span class="string">&quot;time&quot;</span></span><br><span class="line">     <span class="string">&quot;github.com/lesismal/nbio&quot;</span></span><br><span class="line">     <span class="string">&quot;github.com/lesismal/nbio/logging&quot;</span></span><br><span class="line"> )</span><br><span class="line"> ​</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> (</span><br><span class="line">         ret  []<span class="type">byte</span></span><br><span class="line">         buf  = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">4</span>)</span><br><span class="line">         addr = <span class="string">&quot;localhost:8888&quot;</span></span><br><span class="line">         ctx, _ = context.WithTimeout(context.Background(), <span class="number">60</span>*time.Second)</span><br><span class="line">     )</span><br><span class="line"> ​</span><br><span class="line">     logging.SetLevel(logging.LevelInfo)</span><br><span class="line">     rand.Read(buf)</span><br><span class="line"> ​</span><br><span class="line">     g := nbio.NewGopher(nbio.Config&#123;&#125;)</span><br><span class="line">     done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"> ​</span><br><span class="line">     g.OnData(<span class="function"><span class="keyword">func</span><span class="params">(c *nbio.Conn, data []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">         ret = <span class="built_in">append</span>(ret, data...)</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(ret) == <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">             <span class="keyword">if</span> bytes.Equal(buf, ret) &#123;</span><br><span class="line">                 <span class="built_in">close</span>(done)</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"> ​</span><br><span class="line">     err := g.Start()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;Start failed: %v\n&quot;</span>, err)</span><br><span class="line">     &#125;</span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">defer</span> g.Stop()</span><br><span class="line"> ​</span><br><span class="line">     c, err := nbio.Dial(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;Dial failed: %v\n&quot;</span>, err)</span><br><span class="line">     &#125;</span><br><span class="line"> ​</span><br><span class="line">     g.AddConn(c)</span><br><span class="line">     c.Write(buf)</span><br><span class="line"> ​</span><br><span class="line">     <span class="keyword">select</span> &#123;</span><br><span class="line">     <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">         logging.Error(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">     <span class="keyword">case</span> &lt;-done:</span><br><span class="line">         logging.Info(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>At first glance, it might seem a bit cumbersome. Actually, the server and client share the same set of structures.</p>
<p>The client connects to the server through <code>nbio.Dial</code>, and upon successful connection, it encapsulates into <code>nbio.Conn</code>. Here, <code>nbio.Conn</code> implements the <code>net.Conn</code> interface of the standard library. Finally, it adds this connection via <code>g.AddConn(c)</code> and writes data to the server. When the server receives the data, its handling logic is to send the data back to the client as is. When the client receives the data, the <code>OnData</code> callback is triggered. This callback checks if the received data length matches the sent data length, and if so, it closes the connection.</p>
<p>Now, let’s delve into a few key structures.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">struct</span> &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     sync.WaitGroup</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     mux                        sync.Mutex</span><br><span class="line">     wgConn                     sync.WaitGroup</span><br><span class="line">     network                    <span class="type">string</span></span><br><span class="line">     addrs                      []<span class="type">string</span></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     connsStd                   <span class="keyword">map</span>[*Conn]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">     connsUnix                  []*Conn</span><br><span class="line">     listeners                  []*poller</span><br><span class="line">     pollers                    []*poller</span><br><span class="line">     onOpen                     <span class="function"><span class="keyword">func</span><span class="params">(c *Conn)</span></span></span><br><span class="line">     onClose                    <span class="function"><span class="keyword">func</span><span class="params">(c *Conn, err <span class="type">error</span>)</span></span></span><br><span class="line">     onRead                     <span class="function"><span class="keyword">func</span><span class="params">(c *Conn)</span></span></span><br><span class="line">     onData                     <span class="function"><span class="keyword">func</span><span class="params">(c *Conn, data []<span class="type">byte</span>)</span></span></span><br><span class="line">     onReadBufferAlloc          <span class="function"><span class="keyword">func</span><span class="params">(c *Conn)</span></span> []<span class="type">byte</span></span><br><span class="line">     onReadBufferFree           <span class="function"><span class="keyword">func</span><span class="params">(c *Conn, buffer []<span class="type">byte</span>)</span></span></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>The <code>Engine</code> is essentially the core manager, responsible for managing all listeners, pollers, and worker pollers.</p>
<p>What’s the difference between these two types of pollers?</p>
<p>The difference lies in their responsibilities.</p>
<p>The listener poller is responsible only for accepting new connections. When a new client <code>conn</code> arrives, it selects a worker poller from <code>pollers</code> and adds <code>conn</code> to the corresponding worker poller. Subsequently, the worker poller is responsible for handling the read/write events of this <code>conn</code>.</p>
<p>Therefore, when we start the program, if only one address is being listened to, the number of polls in the program equals 1 (listener poller) + <code>pollerNum</code>.</p>
<p>From the fields above, you can customize some configurations and callbacks. For example, you can set a callback function <code>onOpen</code> when a new connection arrives, or set a callback function <code>onData</code> when data arrives, etc.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Conn <span class="keyword">struct</span> &#123;</span><br><span class="line">     mux                   sync.Mutex</span><br><span class="line">     p                     *poller</span><br><span class="line">     fd                    <span class="type">int</span></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     writeBuffer           []<span class="type">byte</span></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     DataHandler           <span class="function"><span class="keyword">func</span><span class="params">(c *Conn, data []<span class="type">byte</span>)</span></span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>The <code>Conn</code> structure represents a network connection. Each <code>conn</code> belongs to only one poller. <code>writeBuffer</code>: When data is not completely written at once, the remaining data is first stored in <code>writeBuffer</code> and waits for the next writable event to continue writing.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poller <span class="keyword">struct</span> &#123;</span><br><span class="line">     g             *Engine</span><br><span class="line">     epfd          <span class="type">int</span></span><br><span class="line">     evtfd         <span class="type">int</span></span><br><span class="line">     index         <span class="type">int</span></span><br><span class="line">     shutdown      <span class="type">bool</span></span><br><span class="line">     listener      net.Listener</span><br><span class="line">     isListener    <span class="type">bool</span></span><br><span class="line">     unixSockAddr  <span class="type">string</span></span><br><span class="line">     ReadBuffer    []<span class="type">byte</span></span><br><span class="line">     pollType      <span class="type">string</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>As for the <code>poller</code> structure, it’s an abstract concept used to manage underlying multiplexed I/O operations (such as epoll on Linux, kqueue on Darwin, etc.).</p>
<p>Pay attention to <code>pollType</code>, nbio defaults to epoll using level-triggered (LT) mode, but users can also set it to edge-triggered (ET) mode.</p>
<p>After introducing the basic structures, let’s move on to the code flow.</p>
<p>When you start the server code provided above, when you call <code>Start</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Engine)</span></span> Start() <span class="type">error</span> &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">switch</span> g.network &#123;</span><br><span class="line">     <span class="comment">// First part: initialize listener</span></span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;unix&quot;</span>, <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;tcp4&quot;</span>, <span class="string">&quot;tcp6&quot;</span>:</span><br><span class="line">         <span class="keyword">for</span> i := <span class="keyword">range</span> g.addrs &#123;</span><br><span class="line">             ln, err := newPoller(g, <span class="literal">true</span>, i)</span><br><span class="line">             <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                 <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">                     g.listeners[j].stop()</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span> err</span><br><span class="line">             &#125;</span><br><span class="line">             g.addrs[i] = ln.listener.Addr().String()</span><br><span class="line">             g.listeners = <span class="built_in">append</span>(g.listeners, ln)</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="comment">// Second part: initialize a certain number of pollers</span></span><br><span class="line">     <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; g.pollerNum; i++ &#123;</span><br><span class="line">         p, err := newPoller(g, <span class="literal">false</span>, i)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(g.listeners); j++ &#123;</span><br><span class="line">                 g.listeners[j].stop()</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">                 g.pollers[j].stop()</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> err</span><br><span class="line">         &#125;</span><br><span class="line">         g.pollers[i] = p</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="comment">// Third part: start all worker pollers</span></span><br><span class="line">     <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; g.pollerNum; i++ &#123;</span><br><span class="line">         g.pollers[i].ReadBuffer = <span class="built_in">make</span>([]<span class="type">byte</span>, g.readBufferSize)</span><br><span class="line">         g.Add(<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">go</span> g.pollers[i].start()</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Fourth part: start all listeners</span></span><br><span class="line">     <span class="keyword">for</span> _, l := <span class="keyword">range</span> g.listeners &#123;</span><br><span class="line">         g.Add(<span class="number">1</span>)</span><br><span class="line">         <span class="keyword">go</span> l.start()</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//... (ignore UDP)</span></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>The code is understandable. It’s divided into four parts:</p>
<p><strong>First part: initialize listener</strong></p>
<p>Based on the <code>g.network</code> value (e.g., “unix”, “tcp”, “tcp4”, “tcp6”), create a new poller for each address to listen on. This poller mainly manages events on the listening socket. If an error occurs during creation, stop all previously created listeners and return an error.</p>
<p><strong>Second part: initialize a certain number of pollers</strong></p>
<p>Create the specified number of worker pollers ( <code>pollerNum</code>). These pollers handle read/write events on connected sockets. If an error occurs during creation, stop all listeners and previously created worker pollers, and then return an error.</p>
<p><strong>Third part: start all worker pollers</strong></p>
<p>Assign a read buffer for each worker poller concurrently and start these pollers.</p>
<p><strong>Fourth part: start all listeners</strong></p>
<p>Start all previously created listeners and begin listening for connection requests on respective addresses.</p>
<p>Regarding the startup of pollers:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *poller)</span></span> start() &#123;</span><br><span class="line">     <span class="keyword">defer</span> p.g.Done()</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">if</span> p.isListener &#123;</span><br><span class="line">         p.acceptorLoop()</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">             syscall.Close(p.epfd)</span><br><span class="line">             syscall.Close(p.evtfd)</span><br><span class="line">         &#125;()</span><br><span class="line">         p.readWriteLoop()</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>It’s divided into two cases. If it’s a listener poller:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *poller)</span></span> acceptorLoop() &#123;</span><br><span class="line">     <span class="comment">// If you want the current goroutine not to be scheduled to other operation threads.</span></span><br><span class="line">     <span class="keyword">if</span> p.g.lockListener &#123;</span><br><span class="line">         runtime.LockOSThread()</span><br><span class="line">         <span class="keyword">defer</span> runtime.UnlockOSThread()</span><br><span class="line">     &#125;</span><br><span class="line">     p.shutdown = <span class="literal">false</span></span><br><span class="line">     <span class="keyword">for</span> !p.shutdown &#123;</span><br><span class="line">         conn, err := p.listener.Accept()</span><br><span class="line">         <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">             <span class="keyword">var</span> c *Conn</span><br><span class="line">             c, err = NBConn(conn)</span><br><span class="line">             <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                 conn.Close()</span><br><span class="line">                 <span class="keyword">continue</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// p.g.pollers[c.Hash()%len(p.g.pollers)].addConn(c)</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">var</span> ne net.Error</span><br><span class="line">             <span class="keyword">if</span> ok := errors.As(err, &amp;ne); ok &amp;&amp; ne.Timeout() &#123;</span><br><span class="line">                 logging.Error(<span class="string">&quot;NBIO[%v][%v_%v] Accept failed: temporary error, retrying...&quot;</span>, p.g.Name, p.pollType, p.index)</span><br><span class="line">                 time.Sleep(time.Second / <span class="number">20</span>)</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> !p.shutdown &#123;</span><br><span class="line">                     logging.Error(<span class="string">&quot;NBIO[%v][%v_%v] Accept failed: %v, exit...&quot;</span>, p.g.Name, p.pollType, p.index, err)</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">break</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>The listener poller waits for new connections and, upon arrival, encapsulates them into <code>nbio.Conn</code> after acceptance. Then, it adds the <code>conn</code> to the corresponding worker poller.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *poller)</span></span> addConn(c *Conn) &#123;</span><br><span class="line">     c.p = p</span><br><span class="line">     <span class="keyword">if</span> c.typ != ConnTypeUDPServer &#123;</span><br><span class="line">         p.g.onOpen(c)</span><br><span class="line">     &#125;</span><br><span class="line">     fd := c.fd</span><br><span class="line">     p.g.connsUnix[fd] = c</span><br><span class="line">     err := p.addRead(fd)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         p.g.connsUnix[fd] = <span class="literal">nil</span></span><br><span class="line">         c.closeWithError(err)</span><br><span class="line">         logging.Error(<span class="string">&quot;[%v] add read event failed: %v&quot;</span>, c.fd, err)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>An interesting design here is the management of <code>conns</code>. The structure is a slice, and the author directly uses <code>conn</code>’s <code>fd</code> as the index. This has its benefits:</p>
<ul>
<li>With a large number of connections, the burden during garbage collection is smaller compared to using a map.</li>
<li>It prevents serial number issues.</li>
</ul>
<p>Finally, the corresponding <code>conn</code> fd is added to epoll by calling <code>addRead</code>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *poller)</span></span> addRead(fd <span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">     <span class="keyword">switch</span> p.g.epollMod &#123;</span><br><span class="line">     <span class="keyword">case</span> EPOLLET:</span><br><span class="line">         <span class="keyword">return</span> syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_ADD, fd, &amp;syscall.EpollEvent&#123;Fd: <span class="type">int32</span>(fd), Events: syscall.EPOLLERR | syscall.EPOLLHUP | syscall.EPOLLRDHUP | syscall.EPOLLPRI | syscall.EPOLLIN | syscall.EPOLLET&#125;)</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">return</span> syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_ADD, fd, &amp;syscall.E</span><br><span class="line"> ​</span><br><span class="line"> pollEvent&#123;Fd: <span class="type">int32</span>(fd), Events: syscall.EPOLLERR | syscall.EPOLLHUP | syscall.EPOLLRDHUP | syscall.EPOLLPRI | syscall.EPOLLIN&#125;)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>It’s reasonable not to register the write event here because there’s no data to send on a new connection. This approach avoids some unnecessary system calls, thereby enhancing program performance.</p>
<p>If it’s a worker poller’s startup, its job is to wait for events from the added <code>conns</code> and handle them accordingly.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *poller)</span></span> readWriteLoop() &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     msec := <span class="number">-1</span></span><br><span class="line">     events := <span class="built_in">make</span>([]syscall.EpollEvent, <span class="number">1024</span>)</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">for</span> !p.shutdown &#123;</span><br><span class="line">         n, err := syscall.EpollWait(p.epfd, events, msec)</span><br><span class="line">         <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, syscall.EINTR) &#123;</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">             msec = <span class="number">-1</span></span><br><span class="line">             <span class="keyword">continue</span></span><br><span class="line">         &#125;</span><br><span class="line">         msec = <span class="number">20</span></span><br><span class="line">         <span class="comment">// Traverse events</span></span><br><span class="line">         <span class="keyword">for</span> _, ev := <span class="keyword">range</span> events[:n] &#123;</span><br><span class="line">             fd := <span class="type">int</span>(ev.Fd)</span><br><span class="line">             <span class="keyword">switch</span> fd &#123;</span><br><span class="line">             <span class="keyword">case</span> p.evtfd:</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 c := p.getConn(fd)</span><br><span class="line">                 <span class="keyword">if</span> c != <span class="literal">nil</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> ev.Events&amp;epollEventsError != <span class="number">0</span> &#123;</span><br><span class="line">                         c.closeWithError(io.EOF)</span><br><span class="line">                         <span class="keyword">continue</span></span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// If it&#x27;s writable, flush the data</span></span><br><span class="line">                     <span class="keyword">if</span> ev.Events&amp;epollEventsWrite != <span class="number">0</span> &#123;</span><br><span class="line">                         c.flush()</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// Read event</span></span><br><span class="line">                     <span class="keyword">if</span> ev.Events&amp;epollEventsRead != <span class="number">0</span> &#123;</span><br><span class="line">                         <span class="keyword">if</span> p.g.onRead == <span class="literal">nil</span> &#123;</span><br><span class="line">                             <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.g.maxConnReadTimesPerEventLoop; i++ &#123;</span><br><span class="line">                                 buffer := p.g.borrow(c)</span><br><span class="line">                                 rc, n, err := c.ReadAndGetConn(buffer)</span><br><span class="line">                                 <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">                                     p.g.onData(rc, buffer[:n])</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 p.g.payback(c, buffer)</span><br><span class="line">                                 <span class="comment">//...</span></span><br><span class="line">                                 <span class="keyword">if</span> n &lt; <span class="built_in">len</span>(buffer) &#123;</span><br><span class="line">                                     <span class="keyword">break</span></span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                             p.g.onRead(c)</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     syscall.Close(fd)</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>This piece of code is also straightforward. It waits for events to arrive, traverses the event list, and handles each event accordingly.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EpollWait</span><span class="params">(epfd <span class="type">int</span>, events []EpollEvent, msec <span class="type">int</span>)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>In <code>EpollWait</code>, only <code>msec</code> is user-modifiable. Usually, we set <code>msec = -1</code> to make the function block until at least one event occurs; otherwise, it blocks indefinitely. This method is very useful when there are few events because it minimizes CPU usage.</p>
<p>If you want to respond to events as quickly as possible, you can set <code>msec = 0</code>. This makes <code>EpollWait</code> return immediately without waiting for any events. In this case, your program may call <code>EpollWait</code> more frequently, but it can process events immediately after they occur, leading to higher CPU usage.</p>
<p>If your program can tolerate some delay and you want to reduce CPU usage, you can set <code>msec</code> it to a positive number. This makes <code>EpollWait</code> waiting for events for the specified time. If no events occur during this time, the function returns, and you can choose to call <code>EpollWait</code> again later. This method can reduce CPU usage but may result in longer response times.</p>
<p>Nbio adjusts the value <code>msec</code> according to event counts. If the count is greater than 0, <code>msec</code> is set to 20.</p>
<p>The code for ByteDance’s netpoll is similar; if the event count is greater than 0, <code>msec</code> it is set to 0. If the event count is less than or equal to 0, <code>msec</code> it is set to -1, and then <code>Gosched()</code> is called to voluntarily yield the current Goroutine.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msec = <span class="number">-1</span></span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">     n, err = syscall.EpollWait(epfd, events, msec)</span><br><span class="line">     <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">         msec = <span class="number">-1</span></span><br><span class="line">         runtime.Gosched()</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">     &#125;</span><br><span class="line">     msec = <span class="number">0</span></span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>However, the code for voluntary switching in nbio has been commented out. According to the author’s explanation in the issue, initially, he referred to ByteDance’s method and added voluntary switching.</p>
<p>However, during performance testing of nbio, it was found that adding or not adding voluntary switching did not significantly affect performance. Therefore, it was ultimately decided to remove it.</p>
<p><strong>The processing part of the event.</strong></p>
<p>If it is a readable event, you can obtain the corresponding buffer through built-in or custom memory allocators, and then call ReadAndGetConn to read the data without needing to allocate a buffer every time.</p>
<p>If it is a writable event, flush will be called to send out the unsent data in the buffer.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span></span> flush() <span class="type">error</span> &#123;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">   old := c.writeBuffer</span><br><span class="line">   n, err := c.doWrite(old)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, syscall.EINTR) &amp;&amp; !errors.Is(err, syscall.EAGAIN) &#123;</span><br><span class="line">     <span class="comment">//.....</span></span><br><span class="line">   &#125;</span><br><span class="line"> ​</span><br><span class="line">   <span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">     n = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">   left := <span class="built_in">len</span>(old) - n</span><br><span class="line">   <span class="comment">// The description is not finished, so store the rest in writeBuffer for next writing.</span></span><br><span class="line">   <span class="keyword">if</span> left &gt; <span class="number">0</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">       c.writeBuffer = mempool.Malloc(left)</span><br><span class="line">       <span class="built_in">copy</span>(c.writeBuffer, old[n:])</span><br><span class="line">       mempool.Free(old)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// c.modWrite()</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     mempool.Free(old)</span><br><span class="line">     c.writeBuffer = <span class="literal">nil</span></span><br><span class="line">     <span class="keyword">if</span> c.wTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">       c.wTimer.Stop()</span><br><span class="line">       c.wTimer = <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// The explanation is finished, reset the conn to only have read events first.</span></span><br><span class="line">     c.resetRead()</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line"> ​</span><br><span class="line">   c.mux.Unlock()</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>The logic is also very simple, write as much as there is, if it cannot be written, put the remaining data back into the writeBuffer and write again when epollWait triggers.</p>
<p>If writing is completed, then there is no more data to be written, reset the event of this connection to a read event.</p>
<p>That’s basically how the main logic works.</p>
<p>Wait a minute, when we initially mentioned that a new connection comes in, we only registered a read event for the connection and didn’t register a write event. When was the write event registered?</p>
<p>Of course, it is registered when you call conn.Write.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">g := nbio.NewGopher(nbio.Config&#123;</span><br><span class="line">     Network:            <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">     Addrs:              []<span class="type">string</span>&#123;<span class="string">&quot;:8888&quot;</span>&#125;,</span><br><span class="line">     MaxWriteBufferSize: <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">   &#125;)</span><br><span class="line"> ​</span><br><span class="line">   g.OnData(<span class="function"><span class="keyword">func</span><span class="params">(c *nbio.Conn, data []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">     c.Write(<span class="built_in">append</span>([]<span class="type">byte</span>&#123;&#125;, data...))</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<p>When conn data arrives, the bottom layer will call back the OnData function after reading the data. At this time, you can call Write to send data to the other end.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">g := nbio.NewGopher(nbio.Config&#123;</span><br><span class="line">     Network:            <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">     Addrs:              []<span class="type">string</span>&#123;<span class="string">&quot;:8888&quot;</span>&#125;,</span><br><span class="line">     MaxWriteBufferSize: <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">   &#125;)</span><br><span class="line"> ​</span><br><span class="line">   g.OnData(<span class="function"><span class="keyword">func</span><span class="params">(c *nbio.Conn, data []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">     c.Write(<span class="built_in">append</span>([]<span class="type">byte</span>&#123;&#125;, data...))</span><br><span class="line">   &#125;)</span><br><span class="line"> <span class="comment">// When data arrives on conn, the underlying layer will read the data and callback the OnData function. At this time, you can call Write to send data to the other end.</span></span><br><span class="line"> ​</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//....</span></span><br><span class="line">   n, err := c.write(b)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, syscall.EINTR) &amp;&amp; !errors.Is(err, syscall.EAGAIN) &#123;</span><br><span class="line">     <span class="comment">//.....</span></span><br><span class="line">     <span class="keyword">return</span> n, err</span><br><span class="line">   &#125;</span><br><span class="line"> ​</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(c.writeBuffer) == <span class="number">0</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> c.wTimer != <span class="literal">nil</span> &#123;</span><br><span class="line">       c.wTimer.Stop()</span><br><span class="line">       c.wTimer = <span class="literal">nil</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// There is still data that has not been written, add a write event.</span></span><br><span class="line">     c.modWrite()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//.....</span></span><br><span class="line">   <span class="keyword">return</span> n, err</span><br><span class="line"> &#125;</span><br><span class="line"> ​</span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c *Conn)</span></span> write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">len</span>(c.writeBuffer) == <span class="number">0</span> &#123;</span><br><span class="line">     n, err := c.doWrite(b)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, syscall.EINTR) &amp;&amp; !errors.Is(err, syscall.EAGAIN) &#123;</span><br><span class="line">       <span class="keyword">return</span> n, err</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//.....</span></span><br><span class="line"></span><br><span class="line">     left := <span class="built_in">len</span>(b) - n</span><br><span class="line"> <span class="comment">// Not finished yet, put the remaining into writeBuffer.</span></span><br><span class="line">     <span class="keyword">if</span> left &gt; <span class="number">0</span> &amp;&amp; c.typ == ConnTypeTCP &#123;</span><br><span class="line">       c.writeBuffer = mempool.Malloc(left)</span><br><span class="line">       <span class="built_in">copy</span>(c.writeBuffer, b[n:])</span><br><span class="line">       c.modWrite()</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">len</span>(b), <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// If there is still unwritten data in the writeBuffer, the new data will also be appended.</span></span><br><span class="line">   c.writeBuffer = mempool.Append(c.writeBuffer, b...)</span><br><span class="line"> ​</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(b), <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>When the data is not completely written, the remaining data is put into writeBuffer, which will trigger the execution of modWrite and register the write event of conn to epoll.</p>
<h1>Summary</h1>
<p>Compared to Evio, nbio does not have a thundering herd effect.</p>
<p>Evio achieves logical correctness by constantly waking up epoll invalidly. Nbio tries to minimize system calls and reduce unnecessary overhead.</p>
<p>In terms of usability, nbio implements a standard library net.Conn and many settings are configurable, allowing users to customize with high flexibility.</p>
<p>Pre-allocated buffers are used for reading and writing to improve application performance.</p>
<p>In conclusion, nbio is a good high-performance non-blocking network framework.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/04/27/Slowing%20Down%20Your%20Disk%20Speed%20by%2060x/" rel="prev" title="Mac: Slowing Down Your Disk Speed by 60x">
                  <i class="fa fa-angle-left"></i> Mac: Slowing Down Your Disk Speed by 60x
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/05/07/If%20Google%20No%20Longer%20supports%20Golang/" rel="next" title="If Google No Longer supports Golang">
                  If Google No Longer supports Golang <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments"><div id="twikoo-comments"></div></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">huizhou92</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="Word count total">39k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">2:22</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/algoliasearch/4.23.3/algoliasearch-lite.umd.js" integrity="sha256-1QNshz86RqXe/qsCBldsUu13eAX6n/O98uubKQs87UI=" crossorigin="anonymous"></script><script src="/js/third-party/search/algolia-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.11.1/firebase-app-compat.js" integrity="sha256-GNS0PNk7BKL3ESum0TEubZtkybvbBMfkV3uZr7137Mk=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/firebase/10.11.1/firebase-firestore-compat.js" integrity="sha256-e8eevSHRq9ExY9rGvp5MoYeiGniYwJq0djypMLEqCjs=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="firestore" type="application/json">{"enable":true,"collection":"articles","apiKey":"AIzaSyBhf1ZiBUIQypQR6JV1MPzZsJkUQHsNK4o","projectId":"blog-views-3d7a8"}</script>
  <script src="/js/third-party/statistics/firestore.js"></script>



<script class="next-config" data-name="twikoo" type="application/json">{"enable":true,"visitor":false,"envId":"https://twikoo.yixiao9206.cn/","el":"#twikoo-comments"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.twikoo.el)
    .then(() => NexT.utils.getScript(
      CONFIG.twikoo.jsUrl || 'https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js',
      { condition: window.twikoo }
    ))
    .then(() => {
      twikoo.init(CONFIG.twikoo);
    });
});
</script>
<style>
.post-block, .comments {
  overflow: visible;
}
.tk-owo-emotion {
  display: inline-block;
}
</style>

</body>
</html>
