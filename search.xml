<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023 年度总结</title>
    <url>/2023/12/29/2023%20%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>7点10分，从公司走出去，2023最后一个工作日已经结束了，很快又一年过去了，尝试写一下一年的盘点，留下点记忆。</p>
<span id="more"></span>

<h1 id="关于我自己"><a href="#关于我自己" class="headerlink" title="关于我自己"></a>关于我自己</h1><p>房子终于交房了，第一次搬进了属于自己的家，装修的不是很好，位置也不是很好，但是这是我的第一个家，我很满足了。以后会越来越好的。<br>跟女票要订婚了，明年会结婚，双喜临门吧，2024年准备结婚。</p>
<hr>
<p>再终生学习这件事情上面，我还是没找到什么特别适合我的方式，一直尝试在努力，好像收获也不是特别大，不知道明年我能不能找到答案。<br>2023年看到书也比2022年少了很多，比以前更忙了是一个理由，但是我好像处理不了很复杂的事务，今年好几次被搞到有点崩溃了。</p>
<h1 id="工作方面"><a href="#工作方面" class="headerlink" title="工作方面"></a>工作方面</h1><p>原地踏步，可以预料到绩效比去年还差。叠加大环境不好，公司一直在裁员，一潭死水，自己的技术也原地踏步，担心35岁危机，如果被裁员，长沙大概率待不下去了，找不到工作。</p>
<h1 id="Luck-in-2024"><a href="#Luck-in-2024" class="headerlink" title="Luck in 2024"></a>Luck in 2024</h1><ol>
<li>继续阅读，阅读才能进步。</li>
<li>学会过鸡贼和抠门的日子。</li>
<li>把英语用起来 </li>
<li>学会NodeJS</li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>A Deep Dive into CNCF’s Cloud-Native AI Whitepaper</title>
    <url>/2024/04/17/A%20Deep%20Dive%20into%20CNCF%E2%80%99s%20Cloud-Native%20AI%20Whitepaper/</url>
    <content><![CDATA[<p><img src="https://images.hxzhouh.com/blog-images/2024/04/3c8f677dae51c4d491a982224b6a3e0d.png" alt="cncf"></p>
<blockquote>
<p>During KubeCon EU 2024, CNCF launched its first Cloud-Native AI Whitepaper. This article provides an in-depth analysis of the content of this whitepaper.</p>
</blockquote>
<p>In March 2024, during KubeCon EU, the Cloud-Native Computing Foundation (CNCF) released its first detailed whitepaper on Cloud-Native Artificial Intelligence (CNAI) <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. This report extensively explores the current state, challenges, and future development directions of integrating cloud-native technologies with artificial intelligence. This article will delve into the core content of this whitepaper.</p>
<span id="more"></span>
<h2 id="What-is-Cloud-Native-AI"><a href="#What-is-Cloud-Native-AI" class="headerlink" title="What is Cloud-Native AI?"></a>What is Cloud-Native AI?</h2><p>Cloud-Native AI refers to building and deploying artificial intelligence applications and workloads using cloud-native technology principles. This includes leveraging microservices, containerization, declarative APIs, and continuous integration&#x2F;continuous deployment (CI&#x2F;CD) among other cloud-native technologies to enhance AI applications’ scalability, reusability, and operability.</p>
<p>The following diagram illustrates the architecture of Cloud-Native AI, redrawn based on the whitepaper.<br><img src="https://images.hxzhouh.com/blog-images/2024/04/40eb5be3bd0139d72f816cef9d25a51f.png" alt="Pasted image 20240418101533"></p>
<h2 id="Relationship-between-Cloud-Native-AI-and-Cloud-Native-Technologies"><a href="#Relationship-between-Cloud-Native-AI-and-Cloud-Native-Technologies" class="headerlink" title="Relationship between Cloud-Native AI and Cloud-Native Technologies"></a>Relationship between Cloud-Native AI and Cloud-Native Technologies</h2><p>Cloud-native technologies provide a flexible, scalable platform that makes the development and operation of AI applications more efficient. Through containerization and microservices architecture, developers can iterate and deploy AI models quickly while ensuring high availability and scalability of the system. Kuuch as resource scheduling, automatic scaling, and service discovery.</p>
<p>The whitepaper provides two examples to illustrate the relationship between Cloud-Native AI and cloud-native technologies, namely running AI on cloud-native infrastructure:</p>
<ul>
<li>Hugging Face Collaborates with Microsoft to launch Hugging Face Model Catalog on Azure<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></li>
<li>OpenAI Scaling Kubernetes to 7,500 nodes<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></li>
</ul>
<h2 id="Challenges-of-Cloud-Native-AI"><a href="#Challenges-of-Cloud-Native-AI" class="headerlink" title="Challenges of Cloud-Native AI"></a>Challenges of Cloud-Native AI</h2><p>Despite providing a solid foundation for AI applications, there are still challenges when integrating AI workloads with cloud-native platforms. These challenges include data preparation complexity, model training resource requirements, and maintaining model security and isolation in multi-tenant environments. Additionally, resource management and scheduling in cloud-native environments are crucial for large-scale AI applications and need further optimization to support efficient model training and inference.</p>
<h2 id="Development-Path-of-Cloud-Native-AI"><a href="#Development-Path-of-Cloud-Native-AI" class="headerlink" title="Development Path of Cloud-Native AI"></a>Development Path of Cloud-Native AI</h2><p>The whitepaper proposes several development paths for Cloud-Native AI, including improving resource scheduling algorithms to better support AI workloads, developing new service mesh technologies to enhance the performance and security of AI applications, and promoting innovation and standardization of Cloud-Native AI technology through open-source projects and community collaboration.</p>
<h2 id="Cloud-Native-AI-Technology-Landscape"><a href="#Cloud-Native-AI-Technology-Landscape" class="headerlink" title="Cloud-Native AI Technology Landscape"></a>Cloud-Native AI Technology Landscape</h2><p>Cloud-Native AI involves various technologies, ranging from containers and microservices to service mesh and serverless computing. Kubernetes plays a central role in deploying and managing AI applications, while service mesh technologies such as Istio and Envoy provide robust traffic management and security features. Additionally, monitoring tools like Prometheus and Grafana are crucial for maintaining the performance and reliability of AI applications.</p>
<p>Below is the Cloud-Native AI landscape diagram provided in the whitepaper.</p>
<ul>
<li>Kubernetes</li>
<li>Volcano</li>
<li>Armada</li>
<li>Kuberay</li>
<li>Nvidia NeMo</li>
<li>Yunikorn</li>
<li>Kueue</li>
<li>Flame</li>
</ul>
<h2 id="Distributed-Training"><a href="#Distributed-Training" class="headerlink" title="Distributed Training"></a>Distributed Training</h2><ul>
<li>Kubeflow Training Operator</li>
<li>Pytorch DDP</li>
<li>TensorFlow Distributed</li>
<li>Open MPI</li>
<li>DeepSpeed</li>
<li>Megatron</li>
<li>Horovod</li>
<li>Apla</li>
<li>…</li>
</ul>
<h2 id="ML-Serving"><a href="#ML-Serving" class="headerlink" title="ML Serving"></a>ML Serving</h2><ul>
<li>Kserve</li>
<li>Seldon</li>
<li>VLLM</li>
<li>TGT</li>
<li>Skypilot</li>
<li>…</li>
</ul>
<h2 id="CI-CD-—-Delivery"><a href="#CI-CD-—-Delivery" class="headerlink" title="CI&#x2F;CD — Delivery"></a>CI&#x2F;CD — Delivery</h2><ul>
<li>Kubeflow Pipelines</li>
<li>Mlflow</li>
<li>TFX</li>
<li>BentoML</li>
<li>MLRun</li>
<li>…</li>
</ul>
<h2 id="Data-Science"><a href="#Data-Science" class="headerlink" title="Data Science"></a>Data Science</h2><ul>
<li>Jupyter</li>
<li>Kubeflow Notebooks</li>
<li>PyTorch</li>
<li>TensorFlow</li>
<li>Apache Zeppelin</li>
</ul>
<h2 id="Workload-Observability"><a href="#Workload-Observability" class="headerlink" title="Workload Observability"></a>Workload Observability</h2><ul>
<li>Prometheus</li>
<li>Influxdb</li>
<li>Grafana</li>
<li>Weights and Biases (wandb)</li>
<li>OpenTelemetry</li>
<li>…</li>
</ul>
<h2 id="AutoML"><a href="#AutoML" class="headerlink" title="AutoML"></a>AutoML</h2><ul>
<li>Hyperopt</li>
<li>Optuna</li>
<li>Kubeflow Katib</li>
<li>NNI</li>
<li>…</li>
</ul>
<h2 id="Governance-Policy"><a href="#Governance-Policy" class="headerlink" title="Governance &amp; Policy"></a>Governance &amp; Policy</h2><ul>
<li>Kyverno</li>
<li>Kyverno-JSON</li>
<li>OPA&#x2F;Gatekeeper</li>
<li>StackRox Minder</li>
<li>…</li>
</ul>
<h2 id="Data-Architecture"><a href="#Data-Architecture" class="headerlink" title="Data Architecture"></a>Data Architecture</h2><ul>
<li>ClickHouse</li>
<li>Apache Pinot</li>
<li>Apache Druid</li>
<li>Cassandra</li>
<li>ScyllaDB</li>
<li>Hadoop HDFS</li>
<li>Apache HBase</li>
<li>Presto</li>
<li>Trino</li>
<li>Apache Spark</li>
<li>Apache Flink</li>
<li>Kafka</li>
<li>Pulsar</li>
<li>Fluid</li>
<li>Memcached</li>
<li>Redis</li>
<li>Alluxio</li>
<li>Apache Superset</li>
<li>…</li>
</ul>
<h2 id="Vector-Databases"><a href="#Vector-Databases" class="headerlink" title="Vector Databases"></a>Vector Databases</h2><ul>
<li>Chroma</li>
<li>Weaviate</li>
<li>Quadrant</li>
<li>Pinecone</li>
<li>Extensions</li>
<li>Redis</li>
<li>Postgres SQL</li>
<li>ElasticSearch</li>
<li>…</li>
</ul>
<h2 id="Model-LLM-Observability"><a href="#Model-LLM-Observability" class="headerlink" title="Model&#x2F;LLM Observability"></a>Model&#x2F;LLM Observability</h2><ul>
<li>• Trulens</li>
<li>Langfuse</li>
<li>Deepchecks</li>
<li>OpenLLMetry</li>
<li>…</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Finally, the following key points are summarized:</p>
<ul>
<li><strong>Role of Open Source Community</strong>: The whitepaper indicates the role of the open-source community in advancing Cloud-Native AI, including accelerating innovation and reducing costs through open-source projects and extensive collaboration.</li>
<li><strong>Importance of Cloud-Native Technologies</strong>: Cloud-Native AI, built according to cloud-native principles, emphasizes the importance of repeatability and scalability. Cloud-native technologies provide an efficient development and operation environment for AI applications, especially in resource scheduling and service scalability.</li>
<li><strong>Existing Challenges</strong>: Despite bringing many advantages, Cloud-Native AI still faces challenges in data preparation, model training resource requirements, and model security and isolation.</li>
<li><strong>Future Development Directions</strong>: The whitepaper proposes development paths including optimizing resource scheduling algorithms to support AI workloads, developing new service mesh technologies to enhance performance and security, and promoting technology innovation and standardization through open-source projects and community collaboration.</li>
<li><strong>Key Technological Components</strong>: Key technologies involved in Cloud-Native AI include containers, microservices, service mesh, and serverless computing, among others. Kubernetes plays a central role in deploying and managing AI applications, while service mesh technologies like Istio and Envoy provide necessary traffic management and security.</li>
</ul>
<p>For more details, please download the Cloud-Native AI whitepaper <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>
<h2 id="Reference-Links"><a href="#Reference-Links" class="headerlink" title="Reference Links"></a>Reference Links</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.cncf.io/reports/cloud-native-artificial-intelligence-whitepaper/">Whitepaper:</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;"><a href="https://huggingface.co/blog/hugging-face-endpoints-on-azure">Hugging Face Collaborates with Microsoft to launch Hugging Face Model Catalog on Azure</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;"><a href="https://openai.com/research/scaling-kubernetes-to-7500-nodes"> OpenAI Scaling Kubernetes to 7,500 nodes:</a></span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;"><a href="https://www.cncf.io/reports/cloud-native-artificial-intelligence-whitepaper/">Cloud-Native AI Whitepaper: </a></span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div>]]></content>
      <categories>
        <category>Information</category>
      </categories>
      <tags>
        <tag>CNCF</tag>
      </tags>
  </entry>
  <entry>
    <title>Go - Ordering in Select Statements</title>
    <url>/2020/04/29/Go%20-%20Ordering%20in%20Select%20Statements/</url>
    <content><![CDATA[<p> <a href="https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6">原文链接</a></p>
<p><a href="https://medium.com/@blanchon.vincent?source=post_page-----fd0ff80fd8d6----------------------">Vincent Blanchon</a></p>
<hr>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200429220520.png"></p>
<blockquote>
<p>本文基于 go 1.14 </p>
</blockquote>
<p><code>select</code> 允许在一个goroutine中管理多个channel。但是，当所有channel同时就绪的时候，go需要在其中选择一个执行。go还需要处理没有channel就绪的情况，我们先从就绪的channel开始。</p>
<h1 id="Order"><a href="#Order" class="headerlink" title="Order"></a>Order</h1><p><code>select</code> 不会按照任何规则或者优先级选择到达的channel。go标准库在每次访问的时候，都会将他们顺序打乱，也就是说不能保证任何顺序。</p>
<p>看一个有三个就绪的channel的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">	b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		a &lt;- <span class="literal">true</span></span><br><span class="line">		b &lt;- <span class="literal">true</span></span><br><span class="line">		c &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-a:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-b:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;&lt; b&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-c:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;&lt; c&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;&lt; default&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个channel都有三个完整的buffer（不会阻塞），下面是程序的输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt; b&lt; a&lt; a&lt; b&lt; c&lt; c&lt; c&lt; a&lt; b&lt; b</span><br></pre></td></tr></table></figure>

<p>在 select 的每次迭代中，case 都会被打乱：</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200429223415.png"></p>
<p>由于go 不会删除重复的channel，所以可以使用多次添加case来影响结果，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">   b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">   c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      a &lt;- <span class="literal">true</span></span><br><span class="line">      b &lt;- <span class="literal">true</span></span><br><span class="line">      c &lt;- <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-a:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> &lt;-a:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> &lt;-a:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> &lt;-a:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> &lt;-a:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> &lt;-a:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> &lt;-a:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> &lt;-b:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; b&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> &lt;-c:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; c&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; default&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt; c&lt; a&lt; b&lt; a&lt; b&lt; a&lt; a&lt; c&lt; a&lt; a</span><br></pre></td></tr></table></figure>

<p>当所有channel同时准备就绪时，有80％的机会选择通道a。下面来看一下channel未就绪的情况。</p>
<h1 id="Non-ready-channels"><a href="#Non-ready-channels" class="headerlink" title="Non-ready channels"></a>Non-ready channels</h1><p><code>select</code> 运行时，如果没有一个case channel就绪，那么他就会运行<code>default:</code>,如果 <code>select</code>中没有写default，那么他就进入等待状态，如下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">   b := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">100</span>)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      time.Sleep(time.Minute)</span><br><span class="line">      <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">         a &lt;- <span class="literal">true</span></span><br><span class="line">         b &lt;- <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-a:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; a&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> &lt;-b:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;&lt; b&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面那个例子中，将在一分钟后打印结果。<code>select</code>阻塞在 channel上。这种情况下，处理<code>select</code>的函数将会订阅所有channel并且等待，下面是一个goroutine#7在select中等待的示例，其中另一个goroutine#4也在等待channel：</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200429225528.png"></p>
<p>Goroutine(G7)订阅所有频道并在列表末尾等待。 如果channel发送了一条消息，channel将通知已在等待该消息的另一个Goroutine。一旦收到通知，<code>select </code>将取消订阅所有channel，并且返回到代码运行.</p>
<p>更多关于channel与等待队列的信息，请查看作者另外一篇文章<a href="https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268"><em>Go: Buffered and Unbuffered Channels</em></a><em>.</em></p>
<p>上面介绍的逻辑，都是针对于有两个或者以上的活动的channel，实际上如果只有一个活动的channel，go乐意简化select</p>
<h1 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h1><p>如果只有一个case 加上一个default，例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   t:= time.NewTicker(time.Second)</span><br><span class="line">   <span class="keyword">for</span>   &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-t.C:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;1 second &quot;</span>)</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;default branch&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下。Go会以非阻塞模式读取channel的操作替换select语句。如果channel在缓冲区中没有任何值，或者发送方准备发送消息，将会运行default。就像下面这张图</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200429231908.png"></p>
<p>如果没有default，则 Go 通过阻塞channel操作重写 select 语句。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>Go iota, 不是枚举</title>
    <url>/2024/03/27/Go%20iota,%20%E4%B8%8D%E6%98%AF%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<p>上周再hacker news 上有一篇讨论go enum 的 文章 <a href="https://www.zarl.dev/articles/enums">Go Enums Suck</a>（很开心还能再hacker news  上看到go相关的信息），我不想对这篇文章发表什么看法，作者说的都是正确的 如果把iota 当成enum看，跟其他语言相比较，确实很糟糕，本篇文章，我们讨论一下iota 的用法。</p>
<span id="more"></span>
<h1 id="iota-在-Go-中的使用"><a href="#iota-在-Go-中的使用" class="headerlink" title="iota 在 Go 中的使用"></a>iota 在 Go 中的使用</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Go 语言实际上没有直接支持枚举的关键字。一般我们都是通过 <code>const</code> + <code>iota</code> 实现枚举的能力。<br>有人要问了，为什么一定要使用枚举呢？<code>stackoverflow</code> 上有一个高赞的回答，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You should always use enums when a variable (especially a method parameter) can only take one out of a small set of possible values. Examples would be things like type constants (contract status: &quot;permanent&quot;, &quot;temp&quot;, &quot;apprentice&quot;), or flags (&quot;execute now&quot;, &quot;defer execution&quot;).</span><br><span class="line"></span><br><span class="line">If you use enums instead of integers (or String codes), you increase compile-time checking and avoid errors from passing in invalid constants, and you document which values are legal to use.</span><br><span class="line"></span><br><span class="line">BTW, overuse of enums might mean that your methods do too much (it&#x27;s often better to have several separate methods, rather than one method that takes several flags which modify what it does), but if you have to use flags or type codes, enums are the way to go.</span><br></pre></td></tr></table></figure>
<h1 id="如何实现枚举"><a href="#如何实现枚举" class="headerlink" title="如何实现枚举"></a>如何实现枚举</h1><p><code>iota</code> 是 Go 中预声明的一个特殊常量。它会被预声明为0，但是它的值在编译阶段并非是固定的，当预声明的 <code>iota</code> 出现在一个常量声明中的时候，它的值在第n个常量描述中的值为n(从0开始)。所以它只在同类型多个常量声明的情况下才显得有意义。</p>
<p>比如，大家都了解的电商，订单系统一定会涉及到订单状态的流转。那么这时候，我们一般可以这样做:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Cancelled OrderStatus = <span class="literal">iota</span> <span class="comment">//订单已取消 0</span></span><br><span class="line">	NoPay     OrderStatus = <span class="literal">iota</span> <span class="comment">//未支付  1</span></span><br><span class="line">	PendIng   OrderStatus = <span class="literal">iota</span> <span class="comment">// 未发货 2</span></span><br><span class="line">	Delivered OrderStatus = <span class="literal">iota</span> <span class="comment">// 已发货 3</span></span><br><span class="line">	Received  OrderStatus = <span class="literal">iota</span> <span class="comment">// 已收货 4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Cancelled, NoPay) <span class="comment">// 打印:0,1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这样看着好麻烦。其实，其他常量可以重复上一行 <code>iota</code> 表达式，我们可以改成这样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Cancelled OrderStatus = <span class="literal">iota</span> <span class="comment">//订单已取消 0</span></span><br><span class="line">	NoPay                        <span class="comment">//未支付 1</span></span><br><span class="line">	PendIng                      <span class="comment">// 未发货 2</span></span><br><span class="line">	Delivered                    <span class="comment">// 已发货 3</span></span><br><span class="line">	Received                     <span class="comment">// 已收货 4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Cancelled, NoPay) <span class="comment">// 打印:0,1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人会用 0 的值来表示状态吗？一般都不会，我们想以1开头，那么可以这样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Cancelled OrderStatus = <span class="literal">iota</span>+<span class="number">1</span> <span class="comment">//订单已取消 1</span></span><br><span class="line">	NoPay                        <span class="comment">//未支付 2</span></span><br><span class="line">	PendIng                      <span class="comment">// 未发货 3</span></span><br><span class="line">	Delivered                    <span class="comment">// 已发货 4</span></span><br><span class="line">	Received                     <span class="comment">// 已收货 5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Cancelled, NoPay) <span class="comment">// 打印:1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还想在 <code>Delivered</code> 后跳过一个数字，才是 <code>Received</code> 的值,也就是 <code>Received=6</code>，那么可以借助 <code>_</code> 符号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Cancelled OrderStatus = <span class="literal">iota</span>+<span class="number">1</span> <span class="comment">//订单已取消 1</span></span><br><span class="line">	NoPay                        <span class="comment">//未支付 2</span></span><br><span class="line">	PendIng                      <span class="comment">// 未发货 3</span></span><br><span class="line">	Delivered                    <span class="comment">// 已发货 4</span></span><br><span class="line">	_</span><br><span class="line">	Received                     <span class="comment">// 已收货 6</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Received) <span class="comment">// 打印:6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺着来可以，倒着当然也行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Max = <span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Received  OrderStatus = Max - <span class="literal">iota</span> <span class="comment">// 已收货  5</span></span><br><span class="line">	Delivered                          <span class="comment">// 已发货 4</span></span><br><span class="line">	PendIng                            <span class="comment">// 未发货 3</span></span><br><span class="line">	NoPay                              <span class="comment">//未支付 2</span></span><br><span class="line">	Cancelled                          <span class="comment">//订单已取消 1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Received,Delivered) <span class="comment">// 打印:5,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以使用位运算，比如在 go 源码中的包 <code>sync</code> 中的锁上面有这么一段代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>  <span class="comment">//1&lt;&lt;0</span></span><br><span class="line">    mutexWoken               <span class="comment">//1&lt;&lt;1</span></span><br><span class="line">    mutexStarving            <span class="comment">//1&lt;&lt;2</span></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span>  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;mutexLocked的值&quot;</span>,mutexLocked) <span class="comment">//打印：1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;mutexWoken的值&quot;</span>,mutexWoken) <span class="comment">//打印：2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;mutexStarving的值&quot;</span>,mutexStarving) <span class="comment">//打印：4</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;mutexWaiterShift的值&quot;</span>,mutexWaiterShift) <span class="comment">// 打印：3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有人平常是直接定义常量值或者用字符串来表示的。<br>比如，上面这些我完全可以用 <code>string</code> 来表示，我还真见过用字符串来表示订单状态的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Cancelled = <span class="string">&quot;cancelled&quot;</span></span><br><span class="line">	NoPay     = <span class="string">&quot;noPay&quot;</span></span><br><span class="line">	PendIng   = <span class="string">&quot;pendIng&quot;</span></span><br><span class="line">	Delivered = <span class="string">&quot;delivered&quot;</span></span><br><span class="line">	Received  = <span class="string">&quot;received&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderStatusMsg = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">	Cancelled: <span class="string">&quot;订单已取消&quot;</span>,</span><br><span class="line">	NoPay:     <span class="string">&quot;未付款&quot;</span>,</span><br><span class="line">	PendIng:   <span class="string">&quot;未发货&quot;</span>,</span><br><span class="line">	Delivered: <span class="string">&quot;已发货&quot;</span>,</span><br><span class="line">	Received:  <span class="string">&quot;已收货&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(OrderStatusMsg[Cancelled])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者直接定义整形常量值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Cancelled = <span class="number">1</span></span><br><span class="line">	NoPay     = <span class="number">2</span></span><br><span class="line">	PendIng   = <span class="number">3</span></span><br><span class="line">	Delivered = <span class="number">4</span></span><br><span class="line">	Received  = <span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> OrderStatusMsg = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line">	Cancelled: <span class="string">&quot;订单已取消&quot;</span>,</span><br><span class="line">	NoPay:     <span class="string">&quot;未付款&quot;</span>,</span><br><span class="line">	PendIng:   <span class="string">&quot;未发货&quot;</span>,</span><br><span class="line">	Delivered: <span class="string">&quot;已发货&quot;</span>,</span><br><span class="line">	Received:  <span class="string">&quot;已收货&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(OrderStatusMsg[Cancelled])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实上述两种都可以，但是相比之下使用 <code>iota</code> 更有优势。</p>
<ul>
<li>能保证一组常量的唯一性，人工定义的不能保证。</li>
<li>可以为一组动作分享同一种行为。</li>
<li>避免无效值。</li>
<li>提高代码阅读性以及维护。</li>
</ul>
<h1 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h1><p>按照上面我们所演示的，最后我们可以这样操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Cancelled OrderStatus = <span class="literal">iota</span> + <span class="number">1</span> <span class="comment">//订单已取消 1</span></span><br><span class="line">	NoPay                            <span class="comment">//未支付 2</span></span><br><span class="line">	PendIng                          <span class="comment">// 未发货 3</span></span><br><span class="line">	Delivered                        <span class="comment">// 已发货 4</span></span><br><span class="line">	Received                         <span class="comment">// 已收货 5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共行为 赋予类型 String() 函数，方便打印值含义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(order OrderStatus)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> [...]<span class="type">string</span>&#123;<span class="string">&quot;cancelled&quot;</span>, <span class="string">&quot;noPay&quot;</span>, <span class="string">&quot;pendIng&quot;</span>, <span class="string">&quot;delivered&quot;</span>, <span class="string">&quot;received&quot;</span>&#125;[order<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建公共行为 赋予类型 int 函数 EnumIndex()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(order OrderStatus)</span></span> EnumIndex() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(order)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> order OrderStatus = Received</span><br><span class="line">	fmt.Println(order.String())    <span class="comment">// 打印:received</span></span><br><span class="line">	fmt.Println(order.EnumIndex()) <span class="comment">// 打印:5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章主要介绍了 <code>Golang</code> 中对 <code>iota</code> 的使用介绍，以及我们为什么要使用它。每一种语言的设计都一定不是完美的，我们要适应它。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Go tool: expvar 自定义度量数据，辅助定位性能瓶颈点</title>
    <url>/2024/03/15/Go%20tool%EF%BC%9Aexpvar%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%A6%E9%87%8F%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BE%85%E5%8A%A9%E5%AE%9A%E4%BD%8D%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E7%82%B9/</url>
    <content><![CDATA[<p>介绍 go 内置工具包 expvar 的使用，能够帮我们实现什么功能，以及它跟pprof 的区别</p>
<span id="more"></span>
<p>#go #监控 #自定义<br>在开发过程中，要想对Go应用存在的性能瓶颈进行剖析，首先就要使用pprof 对不同类型的性能数据进行收集和采样。有两种收集和采样数据的方法。</p>
<ul>
<li>在微观层面，采用通过运行性能基准测试收集和采样数据的方法，这种方法适用于定位函数或方法实现中存在性能瓶颈点的情形；</li>
<li>在宏观层面，采用独立程序收集和采样数据的方法。但通过独立程序进行性能数据采样时，往往很难快速捕捉到真正的瓶颈点，尤其是对于那些内部结构复杂、业务逻辑过多、内部有较多并发的Go程序。我们在对这样的程序进行性能采样时，真正的瓶颈点很可能被其他数据遮盖。<br><strong>那么如何能更高效地捕捉到应用的性能瓶颈点呢？</strong><br>我们可以通过部署agent或者其他方式，通过查询应用外部特征而获取的探针类（probing）数据（比如查看应用某端口是否有响应并返回正确的数据或状态码），相比于这些消息，我们可能还想知道一些内省的消息，比如更多的有关应用程序状态的上下文信息。这些上下文信息可以是应用对各类资源的占用信息，比如应用运行占用了多少内存空间，也可以是自定义的性能指标信息，比如单位时间处理的外部请求数量、应答延迟、队列积压量等。<br>这个时候，我们就需要 go 官方的另外一个包 <a href="https://pkg.go.dev/expvar">expvar</a></li>
</ul>
<blockquote>
<p>Package expvar provides a standardized interface to public variables, such as operation counters in servers. It exposes these variables via HTTP at &#x2F;debug&#x2F;vars in JSON format.</p>
</blockquote>
<p>我们可以轻松地使用Go标准库提供的expvar包按统一接口、统一数据格式、一致的指标定义方法输出自定义的度量数据。在本篇博客中，我们就一起来看看如何使用expvar输出自定义的性能度量数据。  </p>
<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>我们首先来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    _ <span class="string">&quot;expvar&quot;</span>  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>    <span class="string">&quot;net/http&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    http.Handle(<span class="string">&quot;/hi&quot;</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter,  </span></span></span><br><span class="line"><span class="params"><span class="function">       r *http.Request)</span></span> &#123;  </span><br><span class="line">       w.Write([]<span class="type">byte</span>(<span class="string">&quot;hi\n&quot;</span>))  </span><br><span class="line">    &#125;))  </span><br><span class="line">    fmt.Println(http.ListenAndServe(<span class="string">&quot;localhost:8080&quot;</span>, <span class="literal">nil</span>))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们访问一下<code>http://localhost:8080/debug/vars</code><br><img src="https://images.hxzhouh.com/blog-images/2024/03/a74e96c20015c0490c2668b06451c1b6.png" alt="Pasted image 20240314192240"><br>expvar 返回的是标准格式的JSON。<br>在默认返回的状态数据中包含了两个字段：cmdline和memstats。<br>这两个输出数据是expvar包在init函数中就已经发布（Publish）了的变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">src/expvar/expvar.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">  http.HandleFunc(<span class="string">&quot;/debug/vars&quot;</span>, expvarHandler)  </span><br><span class="line">  Publish(<span class="string">&quot;cmdline&quot;</span>, Func(cmdline))  </span><br><span class="line">  Publish(<span class="string">&quot;memstats&quot;</span>, Func(memstats))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://pkg.go.dev/os#Args">cmdline</a></strong> 字段的含义是输出数据的应用名，这里因为是通过go run运行的应用，所以cmdline的值是一个临时路径下的应用。<br><strong><a href="https://pkg.go.dev/runtime#MemStats">memstats</a></strong> 输出的数据对应的是runtime.Memstats结构体，反映的是应用在运行期间堆内存分配、栈内存分配及GC的状态。runtime.Memstats结构体的字段可能会随着Go版本的演进而发生变化，其字段具体含义可以参考Memstats结构体中的注释。</p>
<h1 id="通过expvar输出自定义度量数据"><a href="#通过expvar输出自定义度量数据" class="headerlink" title="通过expvar输出自定义度量数据"></a>通过expvar输出自定义度量数据</h1><p>同样，我们用一个例子说明 如何自定义度量数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;expvar&quot;</span>  </span><br><span class="line">    _ <span class="string">&quot;expvar&quot;</span>  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>    <span class="string">&quot;net/http&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> customVar = <span class="built_in">new</span>(expvar.Map).Init()  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    customVar.Set(<span class="string">&quot;hi_count&quot;</span>, <span class="built_in">new</span>(expvar.Int))  </span><br><span class="line">    expvar.Publish(<span class="string">&quot;custom&quot;</span>, customVar)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    http.Handle(<span class="string">&quot;/hi&quot;</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter,  </span></span></span><br><span class="line"><span class="params"><span class="function">       r *http.Request)</span></span> &#123;  </span><br><span class="line">       <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">          customVar.Add(<span class="string">&quot;hi_count&quot;</span>, <span class="number">1</span>)  </span><br><span class="line">       &#125;()  </span><br><span class="line">       w.Write([]<span class="type">byte</span>(<span class="string">&quot;hi\n&quot;</span>))  </span><br><span class="line">    &#125;))  </span><br><span class="line">    fmt.Println(http.ListenAndServe(<span class="string">&quot;localhost:8080&quot;</span>, <span class="literal">nil</span>))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如以上示例所示，定义一个expvar.Map类型变量后，可以向该复合指标变量中添加指标，比如示例中的“hi_count”<br>然后重新运行例子。先调用两次 localhost:8080&#x2F;hi</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  test git:(main) ✗ curl localhost:8080/hi</span><br><span class="line">hi</span><br><span class="line">➜  test git:(main) ✗ curl localhost:8080/hi                </span><br><span class="line">hi</span><br><span class="line">➜  test git:(main) ✗ curl http://localhost:8080/debug/vars </span><br><span class="line">&#123;</span><br><span class="line">&quot;cmdline&quot;: [&quot;/Users/hxzhouh/Library/Caches/JetBrains/GoLand2023.3/tmp/GoLand/___go_build_github_com_hxzhouh_go_example_expvar&quot;],</span><br><span class="line">&quot;custom&quot;: &#123;&quot;hi_count&quot;: 2&#125;,</span><br><span class="line">&quot;memstats&quot;:&quot;.....&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>expvar 输出了我们想要的结果。实际上expvar 可以输出任何我们想要的结果，这里就不展开描述。</p>
<h1 id="输出数据的展示"><a href="#输出数据的展示" class="headerlink" title="输出数据的展示"></a>输出数据的展示</h1><p>通过&#x2F;debug&#x2F;vars服务端点，我们可以得到标准JSON格式的应用内部状态数据，数据采集出来后可根据不同开发者的需求进行转换和展示。JSON格式文本很容易反序列化，开发者可自行解析后使用，比如：编写一个Prometheus exporter，将数据导入Prometheus背后的存储（比如InfluxDB）中，并利用一些基于Web图形化的方式直观展示出来；或者导入Elasticsearch，再通过Kibana或Grafana的页面展示出来。<br>我们这里展示go开发者<a href="https://twitter.com/idanyliuk">Ivan Daniluk</a> 开发的 expvarmon， 首先安装它</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/divan/expvarmon</span><br></pre></td></tr></table></figure>

<p>然后查看数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expvarmon -ports=&quot;8080&quot; -vars=&quot;custom.hi_count,mem:memstats.Alloc,mem:memstats.Sys,mem:memstats.HeapAlloc,mem:memstats.HeapInuse,duration:memstats.PauseNs,duration:memstats.PauseTotalNs&quot;</span><br></pre></td></tr></table></figure>
<p>结果很geek<br><img src="https://images.hxzhouh.com/blog-images/2024/03/07330c38becc77adad1a63bc7503bb7b.png" alt="Pasted image 20240314195301"></p>
<p>expvar包不仅可用于辅助缩小定位性能瓶颈的范围，还可以用来输出度量数据以对应用的运行状态进行监控，这样当程序出现问题时，我们可以快速发现问题并利用输出的度量数据对程序进行诊断并快速定位问题</p>
<h1 id="跟-pprof-的区别"><a href="#跟-pprof-的区别" class="headerlink" title="跟 pprof 的区别"></a>跟 pprof 的区别</h1><p><code>pprof</code> 是 Go 语言另一个内置的性能剖析工具，主要用于分析程序的 CPU 使用情况和内存占用情况。与 <code>expvar</code> 提供实时监控服务内部变量不同，<code>pprof</code> 更多地用于性能分析和优化。简而言之，<code>expvar</code> 能够帮助我们观察程序的”活动”数据，而 <code>pprof</code> 专注于程序的”性能”数据。<br><code>expvar</code> 以简单的方式公开应用程序的实时状态数据，如当前活跃连接数或已处理请求的计数器。其设计意图是长期运行以监控应用状态，对于想要快速了解应用健康状况的开发者而言，这是一个非常直接的工具。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>expvar 是一个很强大的工具，他可以帮助我们实现应用内情况的监控，并且很方便的跟其他监控平台对接，是每个gopher 都应该掌握的工具。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 编程模式 05 修饰器（Decoration）</title>
    <url>/2024/03/04/Go%20%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F%2005%20%E4%BF%AE%E9%A5%B0%E5%99%A8%EF%BC%88Decoration%EF%BC%89/</url>
    <content><![CDATA[<p>Go 是一种静态类型的编译语言，它的设计目标是简洁、高效。虽然 Go 不是一种完全的面向对象语言，但是我们仍然可以使用一些设计模式来提高代码的可读性和可维护性。今天，我将介绍一种常见的设计模式：修饰器模式。</p>
<span id="more"></span>
<h2 id="01-什么是修饰器模式？"><a href="#01-什么是修饰器模式？" class="headerlink" title="01 什么是修饰器模式？"></a>01 什么是修饰器模式？</h2><p>修饰器模式是一种设计模式，它允许我们在运行时动态地添加行为到对象上，而不改变其实现。这是通过创建一个包装对象或修饰器来实现的，这个修饰器包含了原始对象，并提供了一个增强的接口来添加新的行为。</p>
<p>在 Go 中，我们可以使用函数作为修饰器，这是因为 Go 支持高阶函数，即函数可以作为参数传递，也可以作为返回值。</p>
<h2 id="02-一个例子"><a href="#02-一个例子" class="headerlink" title="02 一个例子"></a>02 一个例子</h2><p>为了更好地理解修饰器模式，让我们通过一个例子来看看如何在 Go 中实现它。</p>
<p>首先，我们定义一个函数类型 <code>Foo</code> 和一个修饰器类型 <code>FooDecorator</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooDecorator <span class="function"><span class="keyword">func</span><span class="params">(Foo)</span></span> Foo</span><br></pre></td></tr></table></figure>

<p>然后，我们可以创建一个修饰器，它接受一个 <code>Foo</code> 类型的函数，并返回一个新的 <code>Foo</code> 函数，这个新的函数在调用原始函数之前和之后添加了一些行为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithLog</span><span class="params">(decorated Foo)</span></span> Foo &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Before calling decorated function&quot;</span>)</span><br><span class="line">        result := decorated(s)</span><br><span class="line">        fmt.Println(<span class="string">&quot;After calling decorated function&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以创建一个 <code>Foo</code> 函数，并使用修饰器来增强它：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Foo function called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    foo = WithLog(foo)</span><br><span class="line">    foo(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>Foo</code> 函数，然后使用 <code>WithLog</code> 修饰器来增强它。当我们调用增强后的函数时，它会首先打印一条消息，然后调用原始的 <code>Foo</code> 函数，最后再打印一条消息。</p>
<p>这就是 Go 中的修饰器模式。通过使用修饰器，我们可以在不修改原始函数的情况下，动态地添加新的行为。</p>
<h1 id="HTTP-相关的一个示例"><a href="#HTTP-相关的一个示例" class="headerlink" title="HTTP 相关的一个示例"></a>HTTP 相关的一个示例</h1><p>接下来，我们再看一个处理 HTTP 请求的相关例子。先看一个简单的 HTTP Server 的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithServerHeader</span><span class="params">(h http.HandlerFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;---&gt;WithServerHeader()&quot;</span>)</span><br><span class="line">        w.Header().Set(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;HelloServer v0.0.1&quot;</span>)</span><br><span class="line">        h(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Recieved Request %s from %s\n&quot;</span>, r.URL.Path, r.RemoteAddr)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, World! &quot;</span>+r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/v1/hello&quot;</span>, WithServerHeader(hello))</span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中使用到了修饰器模式，WithServerHeader() 函数就是一个 Decorator，它会传入一个 http.HandlerFunc，然后返回一个改写的版本。这个例子还是比较简单的，用 WithServerHeader() 就可以加入一个 Response 的 Header。所以，这样的函数我们可以写出好多。如下所示，有写 HTTP 响应头的，有写认证 Cookie 的，有检查认证 Cookie 的，有打日志的……</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithServerHeader</span><span class="params">(h http.HandlerFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;---&gt;WithServerHeader()&quot;</span>)</span><br><span class="line">        w.Header().Set(<span class="string">&quot;Server&quot;</span>, <span class="string">&quot;HelloServer v0.0.1&quot;</span>)</span><br><span class="line">        h(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithAuthCookie</span><span class="params">(h http.HandlerFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;---&gt;WithAuthCookie()&quot;</span>)</span><br><span class="line">        cookie := &amp;http.Cookie&#123;Name: <span class="string">&quot;Auth&quot;</span>, Value: <span class="string">&quot;Pass&quot;</span>, Path: <span class="string">&quot;/&quot;</span>&#125;</span><br><span class="line">        http.SetCookie(w, cookie)</span><br><span class="line">        h(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithBasicAuth</span><span class="params">(h http.HandlerFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;---&gt;WithBasicAuth()&quot;</span>)</span><br><span class="line">        cookie, err := r.Cookie(<span class="string">&quot;Auth&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> || cookie.Value != <span class="string">&quot;Pass&quot;</span> &#123;</span><br><span class="line">            w.WriteHeader(http.StatusForbidden)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        h(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDebugLog</span><span class="params">(h http.HandlerFunc)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        log.Println(<span class="string">&quot;---&gt;WithDebugLog&quot;</span>)</span><br><span class="line">        r.ParseForm()</span><br><span class="line">        log.Println(r.Form)</span><br><span class="line">        log.Println(<span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line">        log.Println(<span class="string">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class="line">        log.Println(r.Form[<span class="string">&quot;url_long&quot;</span>])</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">            log.Println(<span class="string">&quot;key:&quot;</span>, k)</span><br><span class="line">            log.Println(<span class="string">&quot;val:&quot;</span>, strings.Join(v, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        h(w, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Recieved Request %s from %s\n&quot;</span>, r.URL.Path, r.RemoteAddr)</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, World! &quot;</span>+r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/v1/hello&quot;</span>, WithServerHeader(WithAuthCookie(hello)))</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/v2/hello&quot;</span>, WithServerHeader(WithBasicAuth(hello)))</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/v3/hello&quot;</span>, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))</span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多个修饰器的-Pipeline"><a href="#多个修饰器的-Pipeline" class="headerlink" title="多个修饰器的 Pipeline"></a>多个修饰器的 Pipeline</h2><p>在使用上，需要对函数一层层地套起来，看上去好像不是很好看，如果需要修饰器比较多的话，代码就会比较难看了。不过，我们可以重构一下。重构时，我们需要先写一个工具函数，用来遍历并调用各个修饰器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HttpHandlerDecorator <span class="function"><span class="keyword">func</span><span class="params">(http.HandlerFunc)</span></span> http.HandlerFunc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handler</span><span class="params">(h http.HandlerFunc, decors ...HttpHandlerDecorator)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> decors &#123;</span><br><span class="line">        d := decors[<span class="built_in">len</span>(decors)<span class="number">-1</span>-i] <span class="comment">// iterate in reverse</span></span><br><span class="line">        h = d(h)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们就可以像下面这样使用了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">&quot;/v4/hello&quot;</span>, Handler(hello,</span><br><span class="line">                WithServerHeader, WithBasicAuth, WithDebugLog))</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>再这篇文章中，我用两个例子演示了修饰器模式，但是因为<code>Go</code>语言中不支持注解这个语法糖，所以使用装饰器还是有点丑陋的，不过这个思想还是挺重要的，我们日常开发中可以参考这种思想，写出更优质的代码来。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>编程模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 解密： unsafe.Pointer</title>
    <url>/2024/04/11/Go%20%E8%A7%A3%E5%AF%86%EF%BC%9A%20unsafe.Pointer/</url>
    <content><![CDATA[<h1 id="unsafe-Pointer"><a href="#unsafe-Pointer" class="headerlink" title="unsafe.Pointer"></a>unsafe.Pointer</h1><p>再上一篇文章中，我们已经对比了Go 语言中的三种指针的区别， 您可以先去看一下这篇文章。<br>现在我们总结一下三种指针的区别。</p>
<blockquote>
<ul>
<li>普通指针。不支持指针运算，保存地址以及类型信息，指向数据不会被gc回收。</li>
<li><code>unsafe.Pointer</code>。不支持指针运算，保存地址但不保存类型信息，指向数据不会被gc回收。</li>
<li><code>uintptr</code>。支持地址运算，保存地址但不保存类型信息，指向数据会被gc回收。</li>
</ul>
</blockquote>
<p>相比较C语言而言，Go语言在设计的时候，为了编写方便、效率高以及降低复杂度，被设计成为一门强类型的静态语言。强类型意味着一旦定义了，它的类型就不能改变了；静态意味着类型检查在运行前就做了。<br>同时为了安全的考虑，Go语言是不允许两个指针类型进行转换的。为了解决这个问题， go 语言设计了<code>unsafe.Pointer</code> 。 <code>unsafe.Pointer</code>是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于C语言里的void*指针，全能型的。 </p>
<h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><p>在 <a href="https://pkg.go.dev/unsafe#Pointer">官方文档</a>中，我们看下关于<code>unsafe.Pointer</code>的4个规则。</p>
<ul>
<li>A pointer value of any type can be converted to a Pointer.</li>
<li>A Pointer can be converted to a pointer value of any type.</li>
<li>A uintptr can be converted to a Pointer.</li>
<li>A Pointer can be converted to a uintptr.<br>借助<code>unsafe.Pointer</code> 我们就可以实现两个类型之间的互相转换。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">    <span class="string">&quot;reflect&quot;</span>    <span class="string">&quot;unsafe&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//go:nosplit  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(p *<span class="type">int</span>)</span></span> *<span class="type">int32</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (*<span class="type">int32</span>)(unsafe.Pointer(p))  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span> = <span class="number">1</span>  </span><br><span class="line">    q := convert(&amp;i)  </span><br><span class="line">    fmt.Println(reflect.TypeOf(*q))  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  unsafe git:(main) ✗ go run main.go</span><br><span class="line">int32</span><br></pre></td></tr></table></figure>
<p>我们通过<code>unsafe.Pointer</code> 实现了不同类型变量的转化。<br>对于 第三条和第四条,我们可以使用一个复杂点的例子来测试一下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span>  </span><br><span class="line">    age  <span class="type">int32</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    user := &amp;User&#123;  </span><br><span class="line">       name: <span class="string">&quot;Tom&quot;</span>,  </span><br><span class="line">       age:  <span class="number">18</span>,  </span><br><span class="line">    &#125;  </span><br><span class="line">    fmt.Println(*user)  </span><br><span class="line">    pName := (*<span class="type">string</span>)(unsafe.Pointer(user))  </span><br><span class="line">    *pName = <span class="string">&quot;Bob&quot;</span>  </span><br><span class="line">    age := (*<span class="type">int32</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(user)) + unsafe.Offsetof(user.age)))  </span><br><span class="line">    *age = <span class="number">20</span>  </span><br><span class="line">    fmt.Println(*user)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OutPut:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  unsafe git:(main) ✗ go run main.go</span><br><span class="line">&#123;Tom 18&#125;</span><br><span class="line">&#123;Bob 20&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过内存偏移的方式，定位到我们需要操作的字段，然后改变他们的值。<br>首先，第一个修改<code>user</code>的<code>name</code>值的时候，因为<code>name</code>是第一个字段，所以不用偏移，我们获取<code>user</code>的指针，然后通过<code>unsafe.Pointer</code>转为<code>*string</code>进行赋值操作即可。<br>第二个修改<code>user</code>的<code>age</code>值的时候，因为<code>age</code>不是第一个字段，所以我们需要内存偏移，内存偏移牵涉到的计算只能通过<code>uintptr</code>，所我们要先把<code>user</code>的指针地址转为<code>uintptr</code>，然后我们再通过<code>unsafe.Offsetof(u.age)</code>获取需要偏移的值，进行地址运算(+)偏移即可。<br>现在偏移后，地址已经是<code>user</code>的<code>age</code>字段了，如果要给它赋值，我们需要把<code>uintptr</code>转为<code>*int</code>才可以。所以我们通过把<code>uintptr</code>转为<code>unsafe.Pointer</code>,再转为<code>*int</code>就可以操作了。<br>最终，我们在Go语言上实现了类似C语言的指针操作。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>unsafe是不安全的，所以我们应该尽可能少的使用它，比如内存的操纵，这是绕过Go本身设计的安全机制的，不当的操作，可能会破坏一块内存，而且这种问题非常不好定位。  </p>
<p><code>unsafe.Pointer</code>，多用于Go的编译时期；由于它可以绕过类型系统，直接去访问内存，所以它用起来效率会比较高。如果我们去反编译  <code>convert</code> 函数就会发现，他仅仅是将原本的MOVQ指令变成了MOVL，没有产生任何额外指令。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 解密 defer 的优雅陷阱</title>
    <url>/2024/04/02/Go%20%E8%A7%A3%E5%AF%86%EF%BC%9A%20defer%20%E7%9A%84%E4%BC%98%E9%9B%85%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p>在<a href="https://medium.com/gitconnected/decrypt-go-panic-and-recover-5304d0d436c4">上一篇</a>文章中，我们使用的defer 来recover panic，在gopher的实际工作中，defer 就像一个忠诚可靠的队友一样，总是再背后默默的帮我们处理收尾的工作。  比如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">wg.Add(goroutines)  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; goroutines; i++ &#123;  </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">       <span class="keyword">defer</span> wg.Done()  </span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; count/goroutines; j++ &#123;  </span><br><span class="line">          atomic.AddInt64(&amp;sum, <span class="number">1</span>)  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;()  </span><br><span class="line">&#125;  </span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<p>释放锁，或者其他任何资源。</p>
<blockquote>
<p>在Go中，只有在函数和方法内部才能使用defer；defer关键字后面只能接函数或方法，这些函数被称为deferred函数。<br>defer将它们注册到其所在goroutine用于存放deferred函数的栈数据结构中，这些deferred函数将在执行defer的函数退出前被按后进先出（LIFO）的顺序调度执行</p>
</blockquote>
<p><img src="https://images.hxzhouh.com/blog-images/2024/02/7ca8d7abc4864e3b4c698edd9144ecf6.png" alt="Pasted image 20240229205228"><br>无论是执行到函数体尾部返回，还是在某个错误处理分支显式调用return返回，抑或出现panic，已经存储到deferred函数栈中的函数都会被调度执行。因此，deferred函数是一个在任何情况下都可以为函数进行收尾工作的好场合。</p>
<h1 id="defer-的几个使用场景"><a href="#defer-的几个使用场景" class="headerlink" title="defer 的几个使用场景"></a>defer 的几个使用场景</h1><ul>
<li>panic 捕获,因为deferred 再任意场景下都会被执行，所以我们可以再defer中处理异常。（不建议这么做，如果是一般错误，不建议panic，如果必须panic ，就不要捕获）</li>
<li>释放资源</li>
<li>延迟执行，记录函数执行的时间比如<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(s time.Time)</span></span> &#123;</span><br><span class="line">		fmt.Println(time.Now().Sub(s))</span><br><span class="line">	&#125;(time.Now())</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="defer-带来的性能损耗"><a href="#defer-带来的性能损耗" class="headerlink" title="defer 带来的性能损耗"></a>defer 带来的性能损耗</h1><p>defer让进行资源释放（如文件描述符、锁）的过程变得优雅很多，也不易出错。但在性能敏感的程序中，defer带来的性能负担也是Gopher必须知晓和权衡的。<br><a href="https://gist.github.com/hxzhouh/a07dd587ba52a8afdb07d5655c8ca303">https://gist.github.com/hxzhouh/a07dd587ba52a8afdb07d5655c8ca303</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hxzhouh  atomic  ➜ ( main  1)  ♥ 20:16  go test -bench=BenchmarkFooWithDefer </span><br><span class="line">10000000</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: arm64</span><br><span class="line">pkg: github.com/hxzhouh/go-example/atomic</span><br><span class="line">BenchmarkFooWithDefer-10        189423524                6.353 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/hxzhouh/go-example/atomic    3.631s</span><br><span class="line">hxzhouh  atomic  ➜ ( main  1)  ♥ 21:05  go test -bench=BenchmarkFooWithoutDefer </span><br><span class="line">BenchmarkFooWithoutDefer-10     273232389                4.397 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/hxzhouh/go-example/atomic    2.875s</span><br></pre></td></tr></table></figure>

<p>在 go1.12 版本中相同的测试代码，非 defer 版本 要比defer 版本快7倍，经过1.13 1.14 两个大版本的优化，defer 的性能已经显著提高了，在我的电脑上，非defer 版本还是有着50%左右的性能领先。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在多数情况下，我们的程序对性能并不太敏感，我建议尽量使用defer，同时我们需要了解defer 运行的原理，以及几个要避免的地方。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 大杀器之性能剖析 PProf</title>
    <url>/2022/09/30/Golang%20%E5%A4%A7%E6%9D%80%E5%99%A8%E4%B9%8B%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%20pprof/</url>
    <content><![CDATA[<h1 id="Golang-大杀器之性能剖析-pprof"><a href="#Golang-大杀器之性能剖析-pprof" class="headerlink" title="Golang 大杀器之性能剖析 pprof"></a>Golang 大杀器之性能剖析 pprof</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写了几吨代码，实现了几百个接口。功能测试也通过了，终于成功的部署上线了<br>结果，性能不佳，什么鬼？😭</p>
<h2 id="想做性能分析？"><a href="#想做性能分析？" class="headerlink" title="想做性能分析？"></a>想做性能分析？</h2><h3 id="PProf"><a href="#PProf" class="headerlink" title="PProf"></a>PProf</h3><p>想要进行性能优化，首先瞩目在 Go 自身提供的工具链来作为分析依据，本文将带你学习、使用 Go 后花园，涉及如下：</p>
<ul>
<li>runtime&#x2F;pprof：采集程序（非 Server）的运行数据进行分析</li>
<li>net&#x2F;http&#x2F;pprof：采集 HTTP Server 的运行时数据进行分析</li>
</ul>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>pprof 是用于可视化和分析性能分析数据的工具<br>pprof 以 <a href="https://github.com/google/pprof/blob/master/proto/profile.proto">profile.proto</a> 读取分析样本的集合，并生成报告以可视化并帮助分析数据（支持文本和图形报告）<br>profile.proto 是一个 Protocol Buffer v3 的描述文件，它描述了一组 callstack 和 symbolization 信息， 作用是表示统计分析的一组采样的调用栈，是很常见的 stacktrace 配置文件格式</p>
<h3 id="支持什么使用模式"><a href="#支持什么使用模式" class="headerlink" title="支持什么使用模式"></a>支持什么使用模式</h3><ul>
<li>Report generation：报告生成</li>
<li>Interactive terminal use：交互式终端使用</li>
<li>Web interface：Web 界面</li>
</ul>
<h3 id="可以做什么"><a href="#可以做什么" class="headerlink" title="可以做什么"></a>可以做什么</h3><ul>
<li>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置<ul>
<li>一旦启用CPU数据采样，Go运行时会每隔一段短暂的时间（10ms）就中断一次（由SIGPROF信号引发）并记录当前所有goroutine的函数栈信息（存入cpu.prof）。</li>
</ul>
</li>
<li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏<ul>
<li>堆内存分配的采样频率可配置，默认&#x3D;&#x3D;每1000次&#x3D;&#x3D;堆内存分配会做一次采样（存入mem.prof）。</li>
</ul>
</li>
<li>Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置</li>
<li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</li>
</ul>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>我们将编写一个简单且有点问题的例子，用于基本的程序初步分析</p>
<h3 id="编写-demo-文件"><a href="#编写-demo-文件" class="headerlink" title="编写 demo 文件"></a>编写 demo 文件</h3><p>（1）demo.go，文件内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/EDDYCJY/go-pprof-example/data&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            log.Println(data.Add(<span class="string">&quot;https://github.com/EDDYCJY&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;0.0.0.0:6060&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）data&#x2F;d.go，文件内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> data</span><br><span class="line"><span class="keyword">var</span> datas []<span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    data := []<span class="type">byte</span>(str)</span><br><span class="line">    sData := <span class="type">string</span>(data)</span><br><span class="line">    datas = <span class="built_in">append</span>(datas, sData)</span><br><span class="line">    <span class="keyword">return</span> sData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个文件，你的 HTTP 服务会多出 &#x2F;debug&#x2F;pprof 的 endpoint 可用于观察应用程序的情况</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="一、通过-Web-界面"><a href="#一、通过-Web-界面" class="headerlink" title="一、通过 Web 界面"></a>一、通过 Web 界面</h4><p>查看当前总览：访问 <code>http://127.0.0.1:6060/debug/pprof/</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/debug/pprof/</span><br><span class="line">profiles:</span><br><span class="line">0    block</span><br><span class="line">5    goroutine</span><br><span class="line">3    heap</span><br><span class="line">0    mutex</span><br><span class="line">9    threadcreate</span><br><span class="line">full goroutine stack dump</span><br></pre></td></tr></table></figure>

<p>这个页面中有许多子页面，咱们继续深究下去，看看可以得到什么？</p>
<ul>
<li>cpu（CPU Profiling）: <code>$HOST/debug/pprof/profile</code>，默认进行 30s 的 CPU Profiling，得到一个分析用的 profile 文件</li>
<li>block（Block Profiling）：<code>$HOST/debug/pprof/block</code>，查看导致阻塞同步的堆栈跟踪</li>
<li>goroutine：<code>$HOST/debug/pprof/goroutine</code>，查看当前所有运行的 goroutines 堆栈跟踪</li>
<li>heap（Memory Profiling）: <code>$HOST/debug/pprof/heap</code>，查看活动对象的内存分配情况</li>
<li>mutex（Mutex Profiling）：<code>$HOST/debug/pprof/mutex</code>，查看导致互斥锁的竞争持有者的堆栈跟踪</li>
<li>threadcreate：<code>$HOST/debug/pprof/threadcreate</code>，查看创建新OS线程的堆栈跟踪</li>
</ul>
<h4 id="二、通过交互式终端使用"><a href="#二、通过交互式终端使用" class="headerlink" title="二、通过交互式终端使用"></a>二、通过交互式终端使用</h4><p>（1）go tool pprof <a href="http://localhost/">http://localhost</a>:6060&#x2F;debug&#x2F;pprof&#x2F;profile?seconds&#x3D;60</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go tool pprof http://localhost:6060/debug/pprof/profile\?seconds\=60</span></span><br><span class="line">Fetching profile over HTTP from http://localhost:6060/debug/pprof/profile?seconds=60</span><br><span class="line">Saved profile in /Users/eddycjy/pprof/pprof.samples.cpu.007.pb.gz</span><br><span class="line">Type: cpu</span><br><span class="line">Duration: 1mins, Total samples = 26.55s (44.15%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) </span><br></pre></td></tr></table></figure>

<p>执行该命令后，需等待 60 秒（可调整 seconds 的值），pprof 会进行 CPU Profiling。结束后将默认进入 pprof 的交互式命令模式，可以对分析的结果进行查看或导出。具体可执行 <code>pprof help</code> 查看命令说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(pprof) top10</span><br><span class="line">Showing nodes accounting for 25.92s, 97.63% of 26.55s total</span><br><span class="line">Dropped 85 nodes (cum &lt;= 0.13s)</span><br><span class="line">Showing top 10 nodes out of 21</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    23.28s 87.68% 87.68%     23.29s 87.72%  syscall.Syscall</span><br><span class="line">     0.77s  2.90% 90.58%      0.77s  2.90%  runtime.memmove</span><br><span class="line">     0.58s  2.18% 92.77%      0.58s  2.18%  runtime.freedefer</span><br><span class="line">     0.53s  2.00% 94.76%      1.42s  5.35%  runtime.scanobject</span><br><span class="line">     0.36s  1.36% 96.12%      0.39s  1.47%  runtime.heapBitsForObject</span><br><span class="line">     0.35s  1.32% 97.44%      0.45s  1.69%  runtime.greyobject</span><br><span class="line">     0.02s 0.075% 97.51%     24.96s 94.01%  main.main.func1</span><br><span class="line">     0.01s 0.038% 97.55%     23.91s 90.06%  os.(*File).Write</span><br><span class="line">     0.01s 0.038% 97.59%      0.19s  0.72%  runtime.mallocgc</span><br><span class="line">     0.01s 0.038% 97.63%     23.30s 87.76%  syscall.Write</span><br></pre></td></tr></table></figure>

<ul>
<li><p>flat：给定函数上运行耗时</p>
</li>
<li><p>flat%：同上的 CPU 运行耗时总比例</p>
</li>
<li><p>sum%：给定函数累积使用 CPU 总比例</p>
</li>
<li><p>cum：当前函数加上它之上的调用运行总耗时</p>
</li>
<li><p>cum%：同上的 CPU 运行耗时总比例<br>最后一列为函数名称，在大多数的情况下，我们可以通过这五列得出一个应用程序的运行情况，加以优化 🤔<br>（2）<code>go tool pprof [http://localhost](http://localhost/):6060/debug/pprof/heap</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go tool pprof http://localhost:6060/debug/pprof/heap</span><br><span class="line">Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap</span><br><span class="line">Saved profile in /Users/eddycjy/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space.008.pb.gz</span><br><span class="line">Type: inuse_space</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 837.48MB, 100% of 837.48MB total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  837.48MB   100%   100%   837.48MB   100%  main.main.func1</span><br></pre></td></tr></table></figure>
</li>
<li><p>-inuse_space：分析应用程序的常驻内存占用情况</p>
</li>
<li><p>-alloc_objects：分析应用程序的内存临时分配情况<br>（3） go tool pprof <a href="http://localhost/">http://localhost</a>:6060&#x2F;debug&#x2F;pprof&#x2F;block<br>（4） go tool pprof <a href="http://localhost/">http://localhost</a>:6060&#x2F;debug&#x2F;pprof&#x2F;mutex</p>
</li>
</ul>
<h4 id="三、PProf-可视化界面"><a href="#三、PProf-可视化界面" class="headerlink" title="三、PProf 可视化界面"></a>三、PProf 可视化界面</h4><p>这是令人期待的一小节。在这之前，我们需要简单的编写好测试用例来跑一下</p>
<h5 id="编写测试用例"><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h5><p>（1）新建 data&#x2F;d_test.go，文件内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;https://github.com/EDDYCJY&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    s := Add(url)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Test.Add error!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Add(url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）执行测试用例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">test</span> -bench=. -cpuprofile=cpu.prof</span></span><br><span class="line">pkg: github.com/EDDYCJY/go-pprof-example/data</span><br><span class="line">BenchmarkAdd-4       10000000           187 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/EDDYCJY/go-pprof-example/data    2.300s</span><br></pre></td></tr></table></figure>

<p>-memprofile 也可以了解一下</p>
<h5 id="启动-pprof-可视化界面"><a href="#启动-pprof-可视化界面" class="headerlink" title="启动 pprof 可视化界面"></a>启动 pprof 可视化界面</h5><p>方法一：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go tool pprof -http=:8080 cpu.prof</span></span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go tool pprof cpu.prof</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(pprof) web</span></span><br></pre></td></tr></table></figure>

<p>如果出现 <code>Could not execute dot; may need to install graphviz.</code>，就是提示你要安装 <code>graphviz</code> 了 （请右拐谷歌）</p>
<h5 id="查看-PProf-可视化界面"><a href="#查看-PProf-可视化界面" class="headerlink" title="查看 PProf 可视化界面"></a>查看 PProf 可视化界面</h5><p>（1）Top</p>
<img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200316152406.png"/>

<p>（2）Graph<br><img src="https://images.hxzhouh.com/blog-images/2024/02/d0e9e7808e59d9cdcdd22b893d1345d1.png"></p>
<p>框越大，线越粗代表它占用的时间越大哦<br>（3）Peek<br><img src="https://images.hxzhouh.com/blog-images/2024/02/0c2680e3f4e27bf49358421a4501c8bc.png"><br>（4）Source<br><img src="https://images.hxzhouh.com/blog-images/2024/02/355adcb3b34bede7aef069f1dbe07656.png"></p>
<p>通过 PProf 的可视化界面，我们能够更方便、更直观的看到 Go 应用程序的调用链、使用情况等，并且在 View 菜单栏中，还支持如上多种方式的切换<br>你想想，在烦恼不知道什么问题的时候，能用这些辅助工具来检测问题，是不是瞬间效率翻倍了呢 👌</p>
<h4 id="四、PProf-火焰图"><a href="#四、PProf-火焰图" class="headerlink" title="四、PProf 火焰图"></a>四、PProf 火焰图</h4><p>另一种可视化数据的方法是火焰图，需手动安装原生 PProf 工具：<br>（1） 安装 PProf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ go get -u github.com/google/pprof</span><br></pre></td></tr></table></figure>
<p>（2） 启动 PProf 可视化界面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pprof -http=:8080 cpu.prof</span><br></pre></td></tr></table></figure>
<p>（3） 查看 PProf 可视化界面<br>打开 PProf 的可视化界面时，你会明显发现比官方工具链的 PProf 精致一些，并且多了 Flame Graph（火焰图）</p>
<p>它就是本次的目标之一，它的最大优点是动态的。调用顺序由上到下（A -&gt; B -&gt; C -&gt; D），每一块代表一个函数，越大代表占用 CPU 的时间更长。同时它也支持点击块深入进行分析！</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/02/0534f37a2dddcf7127ce74175ae3b119.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本章节，粗略地介绍了 Go 的性能利器 PProf。在特定的场景中，PProf 给定位、剖析问题带了极大的帮助<br>希望本文对你有所帮助，另外建议能够自己实际操作一遍，最好是可以深入琢磨一下，内含大量的用法、知识点</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>你很优秀的看到了最后，那么有两道简单的思考题，希望拓展你的思路<br>（1）flat 一定大于 cum 吗，为什么？什么场景下 cum 会比 flat 大？<br>（2）本章节的 demo 代码，有什么性能问题？怎么解决它？<br>来，晒出你的想法</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>最佳实践</tag>
        <tag>pprof</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 通过 Consul 实现分布式锁</title>
    <url>/2020/03/24/Golang%20%E9%80%9A%E8%BF%87%20Consul%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="Consul-是什么"><a href="#Consul-是什么" class="headerlink" title="Consul 是什么"></a>Consul 是什么</h1><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.<br>命令行超级好用的虚拟机管理软件 vgrant 也是 HashiCorp 公司开发的产品.<br>一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制.</p>
<h1 id="Consul-的使用场景"><a href="#Consul-的使用场景" class="headerlink" title="Consul 的使用场景"></a>Consul 的使用场景</h1><ul>
<li>docker 实例的注册与配置共享</li>
<li>coreos 实例的注册与配置共享</li>
<li>vitess 集群</li>
<li>SaaS 应用的配置共享</li>
<li>与 confd 服务集成，动态生成 nginx 和 haproxy 配置文件</li>
</ul>
<h1 id="Consul-的优势"><a href="#Consul-的优势" class="headerlink" title="Consul 的优势"></a>Consul 的优势</h1><ul>
<li>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft.</li>
<li>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等. zookeeper 和 etcd 均不提供多数据中心功能的支持.</li>
<li>支持健康检查. etcd 不提供此功能.</li>
<li>支持 http 和 dns 协议接口. zookeeper 的集成较为复杂, etcd 只支持 http 协议.</li>
<li>官方提供web管理界面, etcd 无此功能.<br>综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究.</li>
</ul>
<h1 id="Consul-的角色"><a href="#Consul-的角色" class="headerlink" title="Consul 的角色"></a>Consul 的角色</h1><p>client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群.<br>server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其他数据中心通讯. 每个数据中心的 server 数量推荐为 3 个或是 5 个.</p>
<h1 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h1><p><strong>分布式锁</strong>，是控制<a href="https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F&action=edit&redlink=1" title="分布式系统（页面不存在）">分布式系统</a>之间同步访问共享<a href="https://zh.wikipedia.org/wiki/%E8%B5%84%E6%BA%90" title="资源">资源</a>的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5" title="互斥">互斥</a>来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。<br>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。<br>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。<br>在这里我们使用Consul来管理分布式锁。Consul内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key&#x2F;Value存储、多数据中心方案，不再需要依赖其他工具（比如<a href="http://tonybai.com/tag/zookeeper">ZooKeeper</a>等）。</p>
<h3 id="Sessions"><a href="#Sessions" class="headerlink" title="Sessions"></a>Sessions</h3><p><a href="https://o6rr5e4by.qnssl.com/wp-content/uploads/2017/01/consul-sessions-56bc7006.png"></a><br>session是一个远程进程和consul节点之间的链接，它由一个远程进程和可以显式无效或由于健康检查机制。根据会话配置，创建与已失效会话锁摧毁或释放。</p>
<h4 id="Health-checks"><a href="#Health-checks" class="headerlink" title="Health checks"></a>Health checks</h4><p>Consul支持多种检查 （如 HTTP、 TCP 等）。在session创建过程中可以定义的健康检查列表。这些检查将用于确定是否sessio需要使之失效。</p>
<h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>除了健康检查，会话也具有内置支持的 TTL。当 TTL 过期session被视为无效。远程进程负责更新session之前 TTL 过期。</p>
<h3 id="Golang-API"><a href="#Golang-API" class="headerlink" title="Golang API"></a>Golang API</h3><p><a href="https://godoc.org/github.com/hashicorp/consul/api">Consul API client</a> 提供一个方便的抽象，session和 K&#x2F;V 存储。有是一个锁结构与锁定、 解锁和破坏的方法。也有用于帮助创建锁实例方法。API 客户端还负责更新会话。</p>
<h4 id="Creating-the-Consul-client"><a href="#Creating-the-Consul-client" class="headerlink" title="Creating the Consul client"></a>Creating the Consul client</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">client, err := api.NewClient(&amp;api.Config&#123;Address: <span class="string">&quot;127.0.0.1:8500&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="Creating-Lock-instance"><a href="#Creating-Lock-instance" class="headerlink" title="Creating Lock instance"></a>Creating Lock instance</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LockOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key <span class="type">string</span> <span class="comment">// Must be set and have write permissions</span></span><br><span class="line">    Value []<span class="type">byte</span> <span class="comment">// Optional, value to associate with the lock</span></span><br><span class="line">    Session <span class="type">string</span> <span class="comment">// Optional, created if not specified</span></span><br><span class="line">    SessionOpts *SessionEntry <span class="comment">// Optional, options to use when creating a session</span></span><br><span class="line">    SessionName <span class="type">string</span> <span class="comment">// Optional, defaults to DefaultLockSessionName (ignored if SessionOpts is given)</span></span><br><span class="line">    SessionTTL <span class="type">string</span> <span class="comment">// Optional, defaults to DefaultLockSessionTTL (ignored if SessionOpts is given)</span></span><br><span class="line">    MonitorRetries <span class="type">int</span> <span class="comment">// Optional, defaults to 0 which means no retries</span></span><br><span class="line">    MonitorRetryTime time.Duration <span class="comment">// Optional, defaults to DefaultMonitorRetryTime</span></span><br><span class="line">    LockWaitTime time.Duration <span class="comment">// Optional, defaults to DefaultLockWaitTime</span></span><br><span class="line">    LockTryOnce <span class="type">bool</span> <span class="comment">// Optional, defaults to false which means try forever</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LockOptions 是所有可能的选项的容器，可以用于设置键和值、 定制会话或设置TTL。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">opts := &amp;api.LockOptions&#123;</span><br><span class="line">    Key: <span class="string">&quot;webhook_receiver/1&quot;</span>,</span><br><span class="line">    Value: []<span class="type">byte</span>(<span class="string">&quot;set by sender 1&quot;</span>),</span><br><span class="line">    SessionTTL: <span class="string">&quot;10s&quot;</span>,</span><br><span class="line">    SessionOpts: &amp;api.SessionEntry&#123;</span><br><span class="line">    Checks: []<span class="type">string</span>&#123;<span class="string">&quot;check1&quot;</span>, <span class="string">&quot;check2&quot;</span>&#125;,</span><br><span class="line">    Behavior: <span class="string">&quot;release&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">lock, err := client.LockOpts(opts)</span><br></pre></td></tr></table></figure>
<p>另一种常用的方法是 LockKey，它创建一个锁与所有选项设置为默认条目名称除外。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">lock, err := client.LockKey(<span class="string">&quot;webhook_receiver/1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Acquiring-lock"><a href="#Acquiring-lock" class="headerlink" title="Acquiring lock"></a>Acquiring lock</h4><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">lockCh, err := lock.Lock(stopCh)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">cancelCtx, cancelRequest := context.WithCancel(context.Background())</span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://example.com/webhook&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">req = req.WithContext(cancelCtx)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.DefaultClient.Do(req)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-cancelCtx.Done():</span><br><span class="line">log.Println(<span class="string">&quot;request cancelled&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Println(<span class="string">&quot;request done&quot;</span>)</span><br><span class="line">err = lock.Unlock()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Println(<span class="string">&quot;lock already unlocked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-lockCh</span><br><span class="line">cancelRequest()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 远程服务器免密登录</title>
    <url>/2023/09/22/Linux%20%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Linux-远程服务器免密登录"><a href="#Linux-远程服务器免密登录" class="headerlink" title="Linux 远程服务器免密登录"></a>Linux 远程服务器免密登录</h1><p>免密登录的原理：通过密钥认证登录，首先在自己的服务器上生成公钥和私钥，其次将公钥上传到远程服务中，在于远程服务器建立连接通信时，远程服务器首先会验证该服务器上是否包含请求服务器的公钥，若不包含则需要远程登录的用户输入密码。</p>
<span id="more"></span>

<p>免密登录的原理：通过密钥认证登录，首先在自己的服务器上生成公钥和私钥，其次将公钥上传到远程服务中，在于远程服务器建立连接通信时，远程服务器首先会验证该服务器上是否包含请求服务器的公钥，若不包含则需要远程登录的用户输入密码。</p>
<h2 id="创建本地密钥对"><a href="#创建本地密钥对" class="headerlink" title="创建本地密钥对"></a>创建本地密钥对</h2><p>（如果没有~&#x2F;.ssh文件夹，则新建一个.ssh文件夹，mkdir ～&#x2F;.ssh）在本地生成密钥对（公钥与私钥）<br><code>ssh-keygen -t rsa</code></p>
<p>敲下回车后会有三个交互，第一个是文件名，默认是id_rsa，如需修改，自己输入一个文件名即可。第二个与第三个是密码与密码确认，是以后使用该公钥时要输入的密码，一般不设置，如有强烈的安全需求，自己设置即可。最后会生成两个文件id_rsa，id_rsa.pub。以.pub结尾的公钥，另一个是私钥。</p>
<h2 id="上传公钥到目标服务器"><a href="#上传公钥到目标服务器" class="headerlink" title="上传公钥到目标服务器"></a>上传公钥到目标服务器</h2><p>进入～&#x2F;.ssh文件夹中有id_rsa（私钥文件）id_rsa.pub(公钥文件)，将公钥文件id_rsa.pub上传到服务器的.ssh&#x2F;authorized_keys文件中。<br>上传<br><code>scp  ～/.ssh/id_rsa.pub glt@10.112.1.1:~/</code><br>然后 进入远程服务器，找到上传的id_rsa.pub文件，然后将公钥添加到远程服务器的~&#x2F;.ssh&#x2F;authorized_keys 文件中:<br><code>cat ~/id_rsa.pub &gt;&gt; ~./.ssh/authorized_keys</code><br>或者直接用ssh-copy-id命令，将文件上传到服务器：<br>&#96;ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub <a href="mailto:&#x67;&#x6c;&#116;&#64;&#x31;&#x30;&#x2e;&#49;&#49;&#50;&#46;&#x31;&#x2e;&#x31;">&#x67;&#x6c;&#116;&#64;&#x31;&#x30;&#x2e;&#49;&#49;&#50;&#46;&#x31;&#x2e;&#x31;</a></p>
<blockquote>
<p>ssh-copy-id是用来将本地公钥拷贝到远程的authorized_keys文件的脚本命令，它还会将身份标识追加到远程服务器的 <code>～/.ssh/authorized_keys</code> 文件中，并给远程主机的用户目录适当的权限。</p>
</blockquote>
<ol>
<li>把专用密钥添加到ssh-agent的高速缓存中：<br><code>ssh-add</code></li>
<li>重启ssh服务<br><code>service sshd restart</code><br>或者<br><code>systemctl  restart  sshd</code></li>
</ol>
<p>6.使用ssh登录远程服务器系统<br><code>ssh 服务器用户名@服务器地址</code><br>补充：<br>如果上述配置失败。</p>
<ol>
<li>先在本地配置，配置自身服务器的免密登录，自己连接自己。</li>
<li>检查文件权限</li>
</ol>
<p>将authorized_keys 文件的权限修改为600： <code>chmod 600 authorized_keys</code><br>将 .ssh  文件夹的权限修改为700： <code>chmod 700  .ssh</code></p>
<p>3.查看配置文件sshd_config  :   </p>
<p>vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes        #RSA认证</span><br><span class="line">PubkeyAuthentication yes     #公钥认证</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys #公钥认证文件路径</span><br></pre></td></tr></table></figure>

<p>如果用root用户有失败的情况，检查PermitRootLogin yes  这个配置选项（注意，这是root用户的远程登录，比较危险）。</p>
<p>4.修改配置文件后，让配置文件生效<br>立即生效：source &#x2F;etc&#x2F;ssh&#x2F;sshd_coonfig<br>重启ssh服务：sudo &#x2F;etc&#x2F;init.d&#x2F;ssh restart  </p>
<h2 id="本地配置免密登录"><a href="#本地配置免密登录" class="headerlink" title="本地配置免密登录"></a>本地配置免密登录</h2><p>5.给远程登录配置别名</p>
<p>进入本地机器的目录～&#x2F;.ssh下找到config文件（若不存在，则创建一个touch config）, 按如下进行配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host  glt                                  # 给远程服务器取一个别名</span><br><span class="line">HostName  10.1.1.1       #目的机器的ip</span><br><span class="line">User username              #ssh登录时的用户名</span><br><span class="line">Port   22                         #ssh所使用的端口，默认是22</span><br><span class="line">IdentityFile  /home/用户名/.ssh/id_rsa.pub     #对应服务器公钥的本地私钥文件路径</span><br></pre></td></tr></table></figure>

<p>接下来就可以使用ssh glt   进行远程登录。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 解密：panic 出现的三种原因</title>
    <url>/2024/04/02/Go%20%E8%A7%A3%E5%AF%86%EF%BC%9Apanic%20%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h1 id="panic-是什么"><a href="#panic-是什么" class="headerlink" title="panic 是什么"></a>panic 是什么</h1><p>初学 Go 的时候，心里常常很多疑问，有时候看似懂了的问题，其实是是而非。<br>panic 究竟是什么？看似显而易见的问题，但是却回答不出个所以然来。今天我想彻底搞懂这个问题。</p>
<span id="more"></span>
<h1 id="panic-的三种原因"><a href="#panic-的三种原因" class="headerlink" title="panic 的三种原因"></a>panic 的三种原因</h1><p>什么时候会产生 panic ？  我们先从“形”来学习。从开发者的角度来看，可以分为主动和被动方式，被动的方式有两种，如下：<br><strong>主动方式</strong>：</p>
<ul>
<li>开发者主动调用 <code>panic()</code> 函数；<br><strong>被动的方式</strong>：</li>
<li>编译器的隐藏代码触发；</li>
<li>内核发送给进程信号触发 ；</li>
</ul>
<h2 id="编译器的隐藏代码"><a href="#编译器的隐藏代码" class="headerlink" title="编译器的隐藏代码"></a>编译器的隐藏代码</h2><p>Go 之所以简单又强大，编译器居功至伟。非常多的事情是编译器帮程序猿做了的，逻辑补充，内存的逃逸分析等等。<br><strong>包括 panic 的抛出！</strong><br>举个非常典型的例子：整数算法<strong>除零</strong>会发生 panic，怎么做到的？<br>看一段极简代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divzero</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; </span><br><span class="line">	c := a/b </span><br><span class="line">	<span class="keyword">return</span> c </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数就会有除零的风险，当 b 等于 0 的时候，程序就会触发 panic，然后退出，如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~/code/gopher/src/panic<span class="comment"># ./test_zero panic: runtime error: integer divide by zero goroutine 1 [running]: main.zero(0x64, 0x0, 0x0) /root/code/gopher/src/panic/test_zero.go:6 +0x52</span></span><br></pre></td></tr></table></figure>

<p><strong>问题来了：程序怎么触发的 panic ？</strong><br><strong>代码面前无秘密。</strong><br>可代码看不出啥呀，不就是一行 <code>c := a/b</code> 嘛？<br>是<strong>汇编代码</strong>。<strong>因为这段隐藏起来的逻辑，是编译器帮你加的。</strong><br>用 dlv 调试断点到 <code>divzero</code> 函数，然后执行 <code>disassemble</code> ，你就能看到秘密了。截取部分汇编，并备注了下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"> (dlv) disassemble</span><br><span class="line">TEXT main<span class="number">.</span><span class="meta">zero</span>(SB) /root/code/gopher/src/panic/test_zero<span class="number">.</span>go</span><br><span class="line">    // 判断 b 是否等于 <span class="number">0</span> </span><br><span class="line"><span class="symbol">    test_zero.go:</span><span class="number">6</span>  <span class="number">0x4aa3c1</span>    4885c9          <span class="keyword">test</span> <span class="built_in">rcx</span>, <span class="built_in">rcx</span></span><br><span class="line">    // 不等于 <span class="number">0</span> 就跳转到 <span class="number">0x4aa3c8</span> 执行指令，否则就往下执行</span><br><span class="line"><span class="symbol">    test_zero.go:</span><span class="number">6</span>  <span class="number">0x4aa3c4</span>    <span class="number">7502</span>            <span class="keyword">jnz</span> <span class="number">0x4aa3c8</span></span><br><span class="line">    // 执行到这里，就说明 b 是 <span class="number">0</span> 值，就跳转到 <span class="number">0x4aa3ed</span> ，也就是 <span class="keyword">call</span> $runtime<span class="number">.</span>panicdivide</span><br><span class="line">=&gt;  test_zero<span class="number">.</span>go:<span class="number">6</span>  <span class="number">0x4aa3c6</span>    eb25            <span class="keyword">jmp</span> <span class="number">0x4aa3ed</span></span><br><span class="line"><span class="symbol">    test_zero.go:</span><span class="number">6</span>  <span class="number">0x4aa3c8</span>    4883f9ff        <span class="keyword">cmp</span> <span class="built_in">rcx</span>, -<span class="number">0x1</span></span><br><span class="line"><span class="symbol">    test_zero.go:</span><span class="number">6</span>  <span class="number">0x4aa3cc</span>    <span class="number">7407</span>            <span class="keyword">jz</span> <span class="number">0x4aa3d5</span></span><br><span class="line"><span class="symbol">    test_zero.go:</span><span class="number">6</span>  <span class="number">0x4aa3ce</span>    <span class="number">4899</span>            <span class="keyword">cqo</span></span><br><span class="line"><span class="symbol">    test_zero.go:</span><span class="number">6</span>  <span class="number">0x4aa3d0</span>    48f7f9          <span class="keyword">idiv</span> <span class="built_in">rcx</span></span><br><span class="line">    // ...</span><br><span class="line"><span class="symbol">    test_zero.go:</span><span class="number">7</span>  <span class="number">0x4aa3ec</span>    c3              <span class="keyword">ret</span></span><br><span class="line">    // 看到神奇的函数了嘛 ！</span><br><span class="line"><span class="symbol">    test_zero.go:</span><span class="number">6</span>  <span class="number">0x4aa3ed</span>    e8ee27f8ff      <span class="keyword">call</span> $runtime<span class="number">.</span>panicdivide</span><br></pre></td></tr></table></figure>

<p>看到秘密的函数了吗？<br><strong>编译器偷偷加上了</strong>一段 <code>if/else</code> 的判断逻辑，并且还给加了 <code>runtime.panicdivide</code> 的代码。</p>
<ol>
<li>如果 b &#x3D;&#x3D; 0 ，那么跳转执行函数 <code>runtime.panicdivide</code> ；<br>再来看一眼 <code>panicdivide</code> 函数，这是一段极简的封装：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime/panic.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicdivide</span><span class="params">()</span></span> &#123;</span><br><span class="line">    panicCheck2(<span class="string">&quot;integer divide by zero&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(divideError)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了不，这里面调用的就是 <code>panic()</code> 函数。<br>除零触发的 panic 就是这样来的，它不是石头里蹦出来的，而是编译器多加的逻辑判断保证了除数为 0 的时候，触发 panic 函数。<br>编译器加的隐藏逻辑，调用了抛出 panic 的函数。</p>
<h2 id="进程信号触发"><a href="#进程信号触发" class="headerlink" title="进程信号触发"></a>进程信号触发</h2><p>最典型的是<strong>非法地址访问</strong>，比如， nil 指针 访问会触发 panic，怎么做到的？</p>
<p>看一个极简的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nilptr</span><span class="params">(b *<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; c := *b <span class="keyword">return</span> c &#125;</span><br></pre></td></tr></table></figure>

<p>当调用 <code>nilptr( nil )</code> 的时候，将会导致进程异常退出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~/code/gopher/src/panic<span class="comment"># ./test_nil panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x4aa3bc] goroutine 1 [running]: main.nilptr(0x0, 0x0) /root/code/gopher/src/panic/test_nil.go:6 +0x1c</span></span><br></pre></td></tr></table></figure>

<p>问题来了：这里的 panic 又是怎么形成的呢？</p>
<p>在 Go 进程启动的时候会注册默认的信号处理程序（ <code>sigtramp</code> ）</p>
<p>在 cpu 访问到 0 地址会触发 page fault 异常，这是一个非法地址，内核会发送 <code>SIGSEGV</code> 信号给进程，所以当收到 <code>SIGSEGV</code> 信号的时候，就会让 <code>sigtramp</code> 函数来处理，最终调用到 <code>panic</code> 函数 ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sigtramp （纯汇编代码） </span><br><span class="line">	-&gt; sigtrampgo （ signal_unix.go ） </span><br><span class="line">		-&gt; sighandler （ signal_sighandler.go ） </span><br><span class="line">			-&gt; preparePanic （ signal_amd64x.go ） </span><br><span class="line">				-&gt; sigpanic （ signal_unix.go ） </span><br><span class="line">					-&gt; panicmem </span><br><span class="line">						-&gt; panic </span><br></pre></td></tr></table></figure>

<p>在 <code>sigpanic</code> 函数中会调用到 <code>panicmem</code> ，在这个里面就会调用 panic 函数，从而走上了 Go 自己的 panic 之路。</p>
<p><code>panicmem</code> 和 <code>panicdivide</code> 类似，都是对 <code>panic( )</code> 的极简封装：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicmem</span><span class="params">()</span></span> &#123;</span><br><span class="line">	panicCheck2(<span class="string">&quot;invalid memory address or nil pointer dereference&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(memoryError) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方式是通过信号软中断的方式来走到 Go 注册的信号处理逻辑，从而调用到 <code>panic( )</code> 的函数。</strong><br>gophers 可能会好奇，信号处理的逻辑什么时候注册进去的？<br>在进程初始化的时候，创建 M0（线程）的时候用系统调用 <code>sigaction</code> 给信号注册处理函数为 <code>sigtramp</code> ，调用栈如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mstartm0 （proc.go） </span><br><span class="line">	-&gt; initsig (signal_unix.go:113) </span><br><span class="line">		-&gt; setsig （os_linux.go）</span><br></pre></td></tr></table></figure>

<p>这样的话，以后触发了信号软中断，就能调用到 Go 的信号处理函数，从而进行语言层面的 panic 处理 。<br>总的来说，这个是从系统层面到特定语言层面的处理转变。</p>
<h2 id="开发者主动panic"><a href="#开发者主动panic" class="headerlink" title="开发者主动panic"></a>开发者主动panic</h2><p>第三种方式，就是开发者自己主动调用 <code>panic</code> 抛出来的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;panic test&quot;</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的函数调用，这个超简单的。</p>
<h1 id="聊聊-panic-到底是什么？"><a href="#聊聊-panic-到底是什么？" class="headerlink" title="聊聊 panic 到底是什么？"></a>聊聊 panic 到底是什么？</h1><p>现在我们摸透了 panic 产生的姿势，以上三种方式，无论哪一种都归一到 <code>panic( )</code> 这个函数调用。<strong>所以有一点很明确：panic 这个东西是语言层面的处理逻辑。</strong></p>
<p>panic 发生之后，如果 Go 不做任何特殊处理，默认行为是打印堆栈，退出程序。<br>现在回到最本源的问题：panic 到底是什么？<br>这里不纠结概念，只描述几个简单的事实：</p>
<ol>
<li><code>panic()</code> 函数内部会产生一个关键的数据结构体 <code>_panic</code> ，并且挂接到 goroutine 之上；</li>
<li><code>panic()</code> 函数内部会执行 <code>_defer</code> 函数链条，并针对 <code>_panic</code> 的状态进行<strong>对应的处理</strong>；</li>
</ol>
<p>什么叫做 <code>panic()</code> 的对应的处理？<br>循环执行 goroutine 上面的 <code>_defer</code> 函数链，如果执行完了都还没有恢复 <code>_panic</code> 的状态，那就没得办法了，<strong>退出进程，打印堆栈</strong>。</p>
<p>如果在 goroutine 的 <code>_defer</code> 链上，有个朋友 recover 了一下，把这个 <code>_panic</code> 标记成恢复，那事情就到此为止，就从这个 <code>_defer</code> 函数执行后续正常代码即可，走 <code>deferreturn</code> 的逻辑。</p>
<p><strong>所以，panic 是什么 ？</strong><br>它就是个特殊函数调用，仅此而已。<br>有多特殊？我会在下篇剖析其深度原理。可以先思考几个小问题：</p>
<ul>
<li>panic 究竟是啥？是一个结构体？还是一个函数？</li>
<li>为什么 panic 会让 Go 进程退出的 ？</li>
<li>为什么 recover 一定要放在 defer 里面才生效？</li>
<li>为什么 recover 已经放在 defer 里面，但是进程还是没有恢复？</li>
<li>为什么 panic 之后，还能再 panic ？有啥影响？</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>panic 产生的三大姿势：程序猿主动，编译器辅助逻辑，软中断信号触发；</li>
<li>无论哪一种姿势，最终都是归一到 <code>panic()</code> 函数的处理，panic 只是语言层面的处理逻辑；</li>
<li>panic 发生之后，如果不做处理，默认行为是打印 panic 原因，打印堆栈，进程退出；</li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Obsidian 最佳实践 -持续更新</title>
    <url>/2023/09/24/Obsidian%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="Obsidian-最佳实践"><a href="#Obsidian-最佳实践" class="headerlink" title="Obsidian 最佳实践"></a>Obsidian 最佳实践</h1><p>#obsidian</p>
<h1 id="我用Obsidian-来做什么？"><a href="#我用Obsidian-来做什么？" class="headerlink" title="我用Obsidian 来做什么？"></a>我用Obsidian 来做什么？</h1><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>我的<a href="https://blog.hxzhouh.com/">blog</a> 是用Hugo 编译， 托管在Cloudflare 上面的，具体托管教程请参考：<a href="https://developers.cloudflare.com/pages/framework-guides/deploy-a-hugo-site/">Deploy a Hugo site</a> obsidian再中间的作用就是 管理文章了。我用软链接将 hugo 目录里面的content 连接到 obsidian 的目录，然后配合 插件 QuickAdd &amp; Template 插件，很方便的就添加一篇新的博客。<br>写完博客后，用Raycast 触发一下push（脚本），这样就搞定了。。</p>
<h2 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h2><p>配合 官方插件 + template </p>
<h2 id="使用简悦记录网络内容"><a href="#使用简悦记录网络内容" class="headerlink" title="使用简悦记录网络内容"></a>使用简悦记录网络内容</h2><h2 id="本地日记本。"><a href="#本地日记本。" class="headerlink" title="本地日记本。"></a>本地日记本。</h2><p><a href="https://github.com/Kenshin/simpread/discussions/3807">https://github.com/Kenshin/simpread/discussions/3807</a></p>
<h1 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h1><ul>
<li>在Preferences 中 选择编辑器，可以 关闭显示 文档的属性。</li>
<li>必须先设置好时间格式 ,我统一使用的格式是 YYYY-MM-DD(2023-12-31) 、YYYY-MM-DD HH:mm:ss (2023-12-31 15:06:59)</li>
</ul>
<h2 id="限定标签-显示关键字所在行"><a href="#限定标签-显示关键字所在行" class="headerlink" title="限定标签-显示关键字所在行"></a>限定标签-显示关键字所在行</h2><p><a href="https://coffeetea.top/zh/dataview-snippets/Dvjs-QueryTags-inlineKeywords.html">https://coffeetea.top/zh/dataview-snippets/Dvjs-QueryTags-inlineKeywords.html</a><br>用将所有关键字的笔记收集到一个页面。 emm 我也不知道有啥用。</p>
<h2 id="特定文件夹自动使用某个模板。"><a href="#特定文件夹自动使用某个模板。" class="headerlink" title="特定文件夹自动使用某个模板。"></a>特定文件夹自动使用某个模板。</h2><h1 id="正在使用的插件"><a href="#正在使用的插件" class="headerlink" title="正在使用的插件"></a>正在使用的插件</h1><ul>
<li><a href="https://github.com/argenos/nldates-obsidian">Natural Language Dates</a> 方便的输入时间，具体请参考 GitHub主页，后面一些自动化功能都是基于 <a href="https://github.com/argenos/nldates-obsidian">Natural Language Dates</a> 实现</li>
<li><a href="https://github.com/platers/obsidian-linter">Linter</a>：一个自动格式化工具，可以实现诸如自动添加创建时间 、更新时间到metadata，自动纠错等功能。很强大，也比较复杂，可以尝试了解一下。</li>
<li>template 插件 </li>
<li><a href="https://github.com/coddingtonbear/obsidian-local-rest-api">Obsidian Local REST API</a>该插件为 Obsidian 提供了 REST API，您可以与其他工具中的笔记进行交互，以便您可以自动化需要自动化的操作。目前我只用到了<a href="https://github.com/coddingtonbear/obsidian-web">Obsidian Web</a> 这个拓展，后面或许会写一些有意思的东西，活这个跟Raycast联动起来。。 需要琢磨一下。</li>
</ul>
<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>RWmutex：站在巨人肩膀上跳舞</title>
    <url>/2024/04/03/RWmutex%EF%BC%9A%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E8%82%A9%E8%86%80%E4%B8%8A%E8%B7%B3%E8%88%9E/</url>
    <content><![CDATA[<p>我们在使用mutex 的过程中，不管是读还是写，都通过 Mutex 来保证只有一个 goroutine 访问共享资源，这在某些情况下有点“浪费”。比如说，在写少读多的情况下，即使一段时间内没有写操作，大量并发的读访问也不得不在 Mutex 的保护下变成了串行访问，这个时候使用 Mutex，对性能的影响就比较大。  <strong>RWmutex 就是为了优化这问题而实现的</strong></p>
<p>如果您没有阅读过 mutex 文章，请先阅读我的这篇 关于mutex 的文章，RWmutex 是基于mutex 实现的，就像站在巨人肩膀上跳舞。<br><a href="https://medium.com/gitconnected/go-source-code-sync-mutex-3082a25ef092">https://medium.com/gitconnected/go-source-code-sync-mutex-3082a25ef092</a></p>
<span id="more"></span>
<h1 id="什么是-RWMutex"><a href="#什么是-RWMutex" class="headerlink" title="什么是 RWMutex"></a>什么是 RWMutex</h1><p>简单解释一下读写锁 RWMutex。标准库中的 RWMutex 是一个 reader&#x2F;writer 互斥锁。RWMutex 在某一时刻只能由任意数量的 reader 持有，或者是只被单个的 writer 持有。这就是 readers-writers 问题, readers-writers 问题一般有三类，基于对读和写操作的优先级，读写锁的设计和实现也分成三类。  </p>
<ul>
<li><strong>Read-preferring</strong>：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。这是因为，如果有大量的读，这种设计会导致只有所有的读都释放了锁之后，写才可能获取到锁。  </li>
<li><strong>Write-preferring</strong>：写优先的设计意味着，如果已经有一个 writer 在等待请求锁的话，它会阻止新来的请求锁的 reader 获取到锁，所以优先保障 writer。当然，如果有一些 reader 已经请求了锁的话，新请求的 writer 也会等待已经存在的 reader 都释放锁之后才能获取。所以，写优先级设计中的优先权是针对新来的请求而言的。这种设计主要避免了 writer 的饥饿问题。  </li>
<li><strong>不指定优先级</strong>：这种设计比较简单，不区分 reader 和 writer 优先级，某些场景下这种不指定优先级的设计反而更有效，因为第一类优先级会导致写饥饿，第二类优先级可能会导致读饥饿，这种不指定优先级的访问不再区分读写，大家都是同一个优先级，解决了饥饿的问题。<br>Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。</li>
</ul>
<h1 id="RWMutex-的实现"><a href="#RWMutex-的实现" class="headerlink" title="RWMutex 的实现"></a>RWMutex 的实现</h1><blockquote>
<p>本文基于go 1.21.4 </p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;  </span><br><span class="line">    w           Mutex        <span class="comment">// held if there are pending writers  </span></span><br><span class="line">    writerSem   <span class="type">uint32</span>       <span class="comment">// semaphore for writers to wait for completing readers  </span></span><br><span class="line">    readerSem   <span class="type">uint32</span>       <span class="comment">// semaphore for readers to wait for completing writers  </span></span><br><span class="line">    readerCount atomic.Int32 <span class="comment">// number of pending readers  </span></span><br><span class="line">    readerWait  atomic.Int32 <span class="comment">// number of departing readers  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryLock() <span class="type">bool</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryRLock() <span class="type">bool</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字段 readerCount：记录当前 reader 的数量（以及是否有 writer 竞争锁）；</li>
<li>readerWait：记录 writer 请求锁时需要等待 read 完成的 reader 的数量；</li>
</ul>
<h2 id="RLock-RUnlock-的实现"><a href="#RLock-RUnlock-的实现" class="headerlink" title="RLock&#x2F;RUnlock 的实现"></a>RLock&#x2F;RUnlock 的实现</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// rw.readerCount 是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠,</span></span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</span><br><span class="line">        rw.rUnlockSlow(r) <span class="comment">// 有等待的writer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 最后一个reader了，writer终于有机会获得锁了</span></span><br><span class="line">        runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 2 行是对 reader 计数加 1。<br>readerCount 这个字段有双重含义：没有 writer 竞争或持有锁时，readerCount 和我们正常理解的 reader 的计数是一样的；<br>如果有 writer 竞争锁或者持有锁时，那么，readerCount 不仅仅承担着 reader 的计数功能，还能够标识当前是否有 writer 竞争或持有锁（后面会说明），在这种情况下,reader会阻塞等待writer 唤醒（第四行）。<br>调用 RUnlock 的时候，我们需要将 Reader 的计数减去 1（第 8 行），因为 reader 的数量减少了一个。但是，第 8 行的 AddInt32 的返回值还有另外一个含义。如果它是负值，就表示当前有 writer 竞争锁，在这种情况下，还会调用 rUnlockSlow 方法，检查是不是 reader 都释放读锁了，如果读锁都释放了，那么可以唤醒请求写锁的 writer 了。<strong>当一个或者多个 reader 持有锁的时候，竞争锁的 writer 会等待这些 reader 释放完，才可能持有这把锁</strong>。</p>
<h2 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="comment">// 首先解决其他writer竞争问题</span></span><br><span class="line">    rw.w.Lock()</span><br><span class="line">    <span class="comment">// 反转readerCount，告诉reader有writer竞争锁</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</span><br><span class="line">    <span class="comment">// 如果当前有reader持有锁，那么需要等待</span></span><br><span class="line">    <span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</span><br><span class="line">        runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RWMutex 是一个多 writer 多 reader 的读写锁，所以同时可能有多个 writer 和 reader。那么，为了避免 writer 之间的竞争，RWMutex 就会使用一个 Mutex 来保证 writer 的互斥。一旦一个 writer 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(&gt;&#x3D;0) 修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。我们来看下下面的代码。第 5 行，还会记录当前活跃的 reader 数量，所谓活跃的 reader，就是指持有读锁还没有释放的那些 reader。</p>
<p>如果 readerCount 不是 0，就说明当前有持有读锁的 reader，RWMutex 需要把这个当前 readerCount 赋值给 readerWait 字段保存下来（第 7 行）， 同时，这个 writer 进入阻塞等待状态（第 8 行）。<br>每当一个 reader 释放读锁的时候（调用 RUnlock 方法时），readerWait 字段就减 1，直到所有的活跃的 reader 都释放了读锁，才会唤醒这个 writer。</p>
<h2 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="comment">// 告诉reader没有活跃的writer了</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 唤醒阻塞的reader们</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;</span><br><span class="line">        runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放内部的互斥锁</span></span><br><span class="line">    rw.w.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个 writer 释放锁的时候，它会再次反转 readerCount 字段。（由负数修改为正数），然后唤醒阻塞的reader。在 RWMutex 的 Unlock 返回之前，需要把内部的互斥锁释放。释放完毕后，其他的 writer 才可以继续竞争这把锁。</p>
<h2 id="TryLock-TryRLock"><a href="#TryLock-TryRLock" class="headerlink" title="TryLock &amp; TryRLock"></a>TryLock &amp; TryRLock</h2><p><code>TryRLock</code> 和 <code>TryLock</code> 的实现都很简单，都是尝试获取读锁或者写锁，如果获取不到就返回 <code>false</code>，获取到了就返回 <code>true</code>，这两个方法不会阻塞等待。直接看源代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryLock() <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> !rw.w.TryLock() &#123;   <span class="comment">// 有 goroutine 持有写锁</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 读锁被占用</span></span><br><span class="line">    <span class="keyword">if</span> !rw.readerCount.CompareAndSwap(<span class="number">0</span>, -rwmutexMaxReaders) &#123;  </span><br><span class="line">       rw.w.Unlock()  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TryRLock 尝试锁定 rw 以进行读取，并报告是否成功。 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> TryRLock() <span class="type">bool</span> &#123; </span><br><span class="line">	<span class="keyword">for</span> &#123; </span><br><span class="line">		c := rw.readerCount.Load() </span><br><span class="line">		<span class="comment">// 有 goroutine 持有写锁 </span></span><br><span class="line">		<span class="keyword">if</span> c &lt; <span class="number">0</span> &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">// 尝试获取读锁 </span></span><br><span class="line">		<span class="keyword">if</span> rw.readerCount.CompareAndSwap(c, c+<span class="number">1</span>) &#123;</span><br><span class="line">		 <span class="keyword">return</span> <span class="literal">true</span> </span><br><span class="line">		&#125; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="争议点"><a href="#争议点" class="headerlink" title="争议点"></a>争议点</h1><p>Mutex那些争议点，在RWMutex 这里也存在，比如不可重入，不可复制，写代码的时候需要仔细考虑。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个RWmutex 错误的使用例子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// writer,稍微等待，然后制造一个调用Lock的场景</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">        mu.Lock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;Lock&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        mu.Unlock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;Unlock&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        factorial(&amp;mu, <span class="number">10</span>) <span class="comment">// 计算10的阶乘, 10!</span></span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用计算阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(m *sync.RWMutex, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span> &#123; <span class="comment">// 阶乘退出条件 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;RLock&quot;</span>)</span><br><span class="line">    m.RLock()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;RUnlock&quot;</span>)</span><br><span class="line">        m.RUnlock()</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> factorial(m, n<span class="number">-1</span>) * n <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>RWMutex 是基于Mutex 实现的。</li>
<li>在读多写少的场景，我们可以使用RWMutex 替代Mutex 提高性能。</li>
<li>同一时间内，可以有多个reader通过RLock()持有RWMutex，</li>
<li>当一个wirter 通过Lock()加锁时，会先阻止新的reader 加锁，然后等待所有的所有的reader释放后再加锁。</li>
<li>writer 通过ULock()释放锁时，会唤醒等待的reader。</li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>aws ec2 切换到ipv6</title>
    <url>/2023/12/12/aws%20ec2%20%E5%88%87%E6%8D%A2%E5%88%B0ipv6/</url>
    <content><![CDATA[<p>ipv6 出来已经很久了，工作中也处理过很多次ipv6的task，但是从来没想过把自己的ec2切换到ipv4，昨天再邮件回收站里面看到了一个邮件，aws 的ipv4 2024.2.1 要收费了，这就不能忽略了😄，刚好今天有空就把他切换成了ipv6，过程有点折腾。 本文不仅适用ec2，其他linux 主机应该也支持。</p>
<span id="more"></span>

<p><img src="https://images.hxzhouh.com/blog-images/2023/12/c08e861b12930298c2ed4aea11b1c523.png" alt="image-20231212145049883"></p>
<h1 id="为ec2-添加一个ipv6-地址"><a href="#为ec2-添加一个ipv6-地址" class="headerlink" title="为ec2 添加一个ipv6 地址"></a>为ec2 添加一个ipv6 地址</h1><p>我的ec2 的dns 解析在Cloudflare，所以主要是参考这篇博客。<a href="https://blog.cloudflare.com/zh-cn/amazon-2bn-ipv4-tax-how-avoid-paying-zh-cn/">Amazon 的 20 亿 IPv4 税费 — 以及如何避免支付这笔费用</a></p>
<p>以及<a href="https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/vpc-migrate-ipv6.html">将 VPC 从 IPv4 迁移到 IPv6</a>。</p>
<p>需要注意的是<a href="https://docs.aws.amazon.com/zh_cn/vpc/latest/userguide/vpc-migrate-ipv6.html">将 VPC 从 IPv4 迁移到 IPv6</a>。这个demo中vpc是有一个公有子网以及一个私有子网，如果您像我一样只有一个公有子网，那这部分就不需要设置了。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2023/12/7c757c6ffdd0c2d7ffff2f4c00e93f29.png" alt="image-20231212145739848"></p>
<p>不得不说，aws 的文档写的真好，这一点，需要多多学习。</p>
<p>设置完成的结果应该是这样的。同时有ipv4 与ipv6 地址。在安全组中也为ipv6添加相同的规则。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2023/12/68699f4797ea3c86c62c3964407c0e3b.png" alt="image-20231212150653820"></p>
<h1 id="应用支持"><a href="#应用支持" class="headerlink" title="应用支持"></a>应用支持</h1><p>我的ec2 上只跑了一个nginx + docker，平时用ssh登录。所以需要为Nginx 与sshd 添加 ipv6支持。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>对于您的 HTTP 服务器块（监听端口 80 的那个），添加一行 <code>listen [::]:80;</code>。这使得 Nginx 同时监听 IPv4 和 IPv6 的 HTTP 流量。修改后的服务器块应该像这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    server_name hexo.hxzhouh.com;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个 HTTPS 服务器块（监听端口 443 的那些），在每个块中添加 <code>listen [::]:443 ssl;</code>。这将使得 Nginx 监听 IPv6 上的 HTTPS 流量。例如，对于第一个 HTTPS 服务器块，你需要做如下修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    listen [::]:443 ssl;</span><br><span class="line">    server_name hexo.hxzhouh.com;</span><br><span class="line">    # 其余配置...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对每个 HTTPS <code>server</code> 块进行这样的修改。然后测试一下 <code>Nginx -t</code> 如果没问题就重新加载Nginx配置 <code>systemctl reload nginx</code></p>
<h2 id="sshd"><a href="#sshd" class="headerlink" title="sshd"></a>sshd</h2><p>再sshd_config 修改，删除对<code>AddressFamily any</code>的注释（即删除前面的<code>#</code>），为 ssh 等应用程序开启 IPv6 监听。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Port 22</span></span><br><span class="line">AddressFamily any</span><br><span class="line">AddressFamily inet</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ListenAddress 0.0.0.0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ListenAddress ::</span></span><br></pre></td></tr></table></figure>

<p>然后重启 sshd <code>sudo systemctl reload sshd </code>，执行<code>netstat -tupln</code>命令，若出现以下报文，表示查 ssh 已成功监听 IPv6。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2023/12/1b5feee3b3f881dbbb252e82e789838e.png" alt="image-20231212152302361"></p>
<p>这样应用层就修改好了。</p>
<h1 id="dns-设置"><a href="#dns-设置" class="headerlink" title="dns 设置"></a>dns 设置</h1><p>最后，在Cloudflare 里面设置 一下dns，把以前的ipv4 的A记录全部改成AAAA 的ipv6  就可以了。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2023/12/1df24903dda8dbb4996968d55286d099.png" alt="image-20231212151550030"></p>
<h2 id="大功告成，测试一下如果没问题的话，就可以把ipv4地址删了。省的扣钱。"><a href="#大功告成，测试一下如果没问题的话，就可以把ipv4地址删了。省的扣钱。" class="headerlink" title="大功告成，测试一下如果没问题的话，就可以把ipv4地址删了。省的扣钱。"></a>大功告成，测试一下如果没问题的话，就可以把ipv4地址删了。省的扣钱。</h2><p>更新： 正在运行的实例无法删除ipv4地址，只能通过AMI 重建，折腾呀，但是aws 不再给我发邮件了。✌️  </p>
<p><a href="https://repost.aws/questions/QUVmpO9BWGSuGwQh5tXk3f5w/how-to-remove-ipv4-public-ip-address-from-ec2-instances-before-february-2024-ipv6">How to remove IPv4 public IP address from ec2 instances before February 2024? (IPv6)</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ipv6</tag>
      </tags>
  </entry>
  <entry>
    <title>go trace view trace 显示空白</title>
    <url>/2020/03/21/go%20trace%20view%20trace%20%E6%98%BE%E7%A4%BA%E7%A9%BA%E7%99%BD/</url>
    <content><![CDATA[<blockquote>
<p>go trace 用来跟踪 goroutines运行情况,跟pprof配合使用，可以起到事半功倍的效果。但是，go trace 的view trace 在chrome下一片空白。</p>
</blockquote>
<p>原因是因为谷歌在某一版本的chrome中禁用了本地<a href="crbug.com/1036492.">API</a></p>
<p>解决办法：</p>
<ol>
<li>注册一个chrome token <a href="https://developers.chrome.com/origintrials/#/register_trial/2431943798780067841">https://developers.chrome.com/origintrials/#/register_trial/2431943798780067841</a> 资料随便填写，记得最后一定要 feedback。</li>
<li>修改 go trace 代码 <code>src/cmd/trace/trace.go</code> 在head中添加一行 <meta http-equiv="origin-trial" content="YOUR_TOKEN_GOES_HERE"> 然后<code> go install</code> 一下</li>
<li>在 $gopath&#x2F;misc&#x2F;trace&#x2F;trace_viewer_full.html 中 看到</li>
</ol>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200428161814.png"></p>
<p>说明配置成功，</p>
<ol start="4">
<li>在使用 go trace得时候能够正常加载出 view trace。</li>
</ol>
<p>Enjoy！</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title>go 协程切换的性能分析</title>
    <url>/2024/03/20/go%20%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>[[Performance analysis of goroutine switching]]<br><img src="https://images.hxzhouh.com/blog-images/2024/03/057d94f39fc9a6838acdbc94b915f654.png" alt="Pasted image 20240320201037"><br>上一篇[[004-blog&#x2F;计算机中的时间 线程上下文切换会用掉你多少CPU？]]文章中，中我们用实验的方式验证了Linux进程和线程的上下文切换开销，大约是3-5us之间。这个开销确实不算大，但是海量互联网服务端和一般的计算机程序相比，特点是：</p>
<ul>
<li>高并发：每秒钟需要处理成千上万的用户请求。</li>
<li>周期短：每个用户处理耗时越短越好，经常是ms级别的</li>
<li>高网络IO：经常需要从其它机器上进行网络IO、如Redis、Mysql等等</li>
<li>低计算：一般CPU密集型的计算操作并不多<br>即使3-5us的开销，如果上下文切换量特别大的话，也仍然会显得是有那么一些性能低下。例如之前的Web Server之Apache，就是这种模型下的软件产品。（其实当时Linux操作系统在设计的时候，目标是一个通用的操作系统，并不是专门针对服务端高并发来设计的）</li>
</ul>
<p>为了避免频繁的上下文切换，还有一种异步非阻塞的开发模型。那就是用一个进程或线程去接收一大堆用户的请求，然后通过IO多路复用的方式来提高性能（进程或线程不阻塞，省去了上下文切换的开销）。Nginx和Node Js就是这种模型的典型代表产品。平心而论，从程序运行效率上来，这种模型最为机器友好，运行效率是最高的（比下面提到的协程开发模型要好）。所以Nginx已经取代了Apache成为了Web Server里的首选。但是这种编程模型的问题在于开发不友好，说白了就是过于机器化，离进程概念被抽象出来的初衷背道而驰。人类正常的线性思维被打乱，应用层开发们被逼得以非人类的思维去编写代码，代码调试也变得异常困难。</p>
<p>于是就有一些聪明的脑袋们继续在应用层又动起了主意，设计出了不需要进程&#x2F;线程上下文切换的“线程”，协程。用协程去处理高并发的应用场景，既能够符合进程涉及的初衷，让开发者们用人类正常的线性的思维去处理自己的业务，也同样能够省去昂贵的进程&#x2F;线程上下文切换的开销。因此可以说，协程就是Linux处理海量请求应用场景里的进程模型的一个很好的的补丁。</p>
<p>背景介绍完了，那么我想说的是，毕竟协程的封装虽然轻量，但是毕竟还是需要引入了一些额外的代价的。那么我们来看看这些额外的代价具体多小吧。</p>
<h1 id="协程开销测试"><a href="#协程开销测试" class="headerlink" title="协程开销测试"></a>协程开销测试</h1><blockquote>
<p>本文基于 go 1.22.1</p>
</blockquote>
<h2 id="协程切换CPU开销"><a href="#协程切换CPU开销" class="headerlink" title="协程切换CPU开销"></a>协程切换CPU开销</h2><pre><code>测试过程是不断在协程之间让出CPU。核心代码如下。
</code></pre>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">    <span class="string">&quot;runtime&quot;</span>    <span class="string">&quot;time&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;  </span><br><span class="line">       runtime.Gosched()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    runtime.GOMAXPROCS(<span class="number">1</span>)  </span><br><span class="line">    currentTime := time.Now()  </span><br><span class="line">    fmt.Println(currentTime)  </span><br><span class="line">    <span class="keyword">go</span> cal()  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++ &#123;  </span><br><span class="line">       runtime.Gosched()  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    fmt.Println(time.Now().Sub(currentTime) / <span class="number">2000000</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  trace git:(main) ✗ go run main.go              </span><br><span class="line">2024-03-20 19:52:24.772579 +0800 CST m=+0.000114834</span><br><span class="line">54ns</span><br><span class="line">➜  trace git:(main) ✗ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>平均每次协程切换的开销是 54ns 相对于前面文章测得的进程切换开销大约3.5us，大约是其1&#x2F;70。比系统调用的造成的开销还要低。  </p>
<h2 id="协程内存开销"><a href="#协程内存开销" class="headerlink" title="协程内存开销"></a>协程内存开销</h2><p>在空间上，协程初始化创建的时候为其分配的栈有2KB。而线程栈要比这个数字大的多，可以通过ulimit 命令查看，一般都在几兆，我的mac 上是8m 。如果对每个用户创建一个协程去处理，100万并发用户请求只需要2G内存就够了，而如果用线程模型则需要8T。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  trace git:(main) ✗ ulimit -a   </span><br><span class="line">-t: cpu time (seconds)              unlimited</span><br><span class="line">-f: file size (blocks)              unlimited</span><br><span class="line">-d: data seg size (kbytes)          unlimited</span><br><span class="line">-s: stack size (kbytes)             8176</span><br><span class="line">-c: core file size (blocks)         0</span><br><span class="line">-v: address space (kbytes)          unlimited</span><br><span class="line">-l: locked-in-memory size (kbytes)  unlimited</span><br><span class="line">-u: processes                       2666</span><br><span class="line">-n: file descriptors                12544</span><br></pre></td></tr></table></figure>

<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>协程由于是在用户态来完成上下文切换的，所以切换耗时只有区区50ns多一些，比进程切换要高70倍。单个协程需要的栈内存也足够小，只需要2KB。所以，近几年来协程大火，在互联网后端的高并发场景里大放光彩。</p>
<p>无论是空间还是时间性能都比进程（线程）好这么多，那么Linus为啥不把它在操作系统里实现？操作系统为了实现实时性更好的目的，对一些优先级比较高的进程是会抢占其它进程的CPU的。而协程无法实现这一点，还得依赖于挡前使用CPU的协程主动释放，于操作系统的实现目的不相吻合。所以协程的高效是以牺牲可抢占性为代价的。<br>协程最终也是附着在操作系统线程上执行的。<br>我们需要考虑的一个问题是。<br>难道用了协程，线程就不切换了吗？线程的切换频率，基本取决于线程的数量，使用协程，需要指定每个线程的任务，同样的任务量，协程需要的线程数量应该始终高于自动分配的线程池。<br>因而：<br>    使用线程 &#x3D; 线程切换开销（小）<br>    使用协程 &#x3D; 线程切换开销（大）+ 协程切换开销<br>    然后CPU开销：<br>    线程的指令周期 &#x3D; 中断检测 + 指令执行（包括取指、转换和执行）<br>    协程的指令周期 &#x3D; 中断检测 + 指令执行 + 中断检测 + 协程信号检测<br>    所以我有以下结论：<br>    性能上，io多路复用 + 线程池是完全碾压协程的；但是在方便程度上，还是协程好用  </p>
<p>由于go的协程调用起来太方便了，所以一些go的程序员就很随意使用go 这个关键字。要知道go这条指令在切换到协程之前，得先把协程创建出来。而一次创建加上调度开销就涨到400ns，差不多相当于一次系统调用的耗时了。虽然协程很高效，但是也不要乱用，否则Rob Pike花大精力优化出来的性能，被你随意一go又给葬送掉了。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go 怎么做stw</title>
    <url>/2020/04/28/go%20%E6%80%8E%E6%A0%B7%E5%81%9A%20stw/</url>
    <content><![CDATA[<blockquote>
<p>原文链接:  <a href="https://medium.com/a-journey-with-go/go-how-does-go-stop-the-world-1ffab8bc8846">Go: How Does Go Stop the World? </a>:<br>Author :   <a href="https://medium.com/@blanchon.vincent?source=post_page-----1ffab8bc8846----------------------">Vincent Blanchon</a></p>
</blockquote>
<p><strong>本文基于 go 1.13</strong></p>
<p>在垃圾回收算法中，Stop The Word（STW）是一个很重要的概念，他会中断程序运行，添加写屏障，<code>以便扫描内存</code> ,现在一起来看看它内部的原理以及可能存在的问题</p>
<h1 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h1><p>停止程序运行意味着停止所有运行态的<code>goroutines</code>,一个简单的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   runtime.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行垃圾回收算法将触发两个阶段的STW </p>
<blockquote>
<p>有关垃圾回收的更多细节，请参考同作者的另外一篇文章<em>“</em><a href="https://medium.com/a-journey-with-go/go-how-does-the-garbage-collector-mark-the-memory-72cfc12c6976"><em>Go: How Does the Garbage Collector Mark the Memory?</em></a></p>
</blockquote>
<h2 id="STW的步骤"><a href="#STW的步骤" class="headerlink" title="STW的步骤"></a>STW的步骤</h2><p>第一步，抢占所有正在运行的<code>goroutines</code></p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200428164159.png"></p>
<p>第二步，一旦 <code>goroutines</code>被抢占，正在运行的<code>goroutines</code>将在安全的地方暂停，然后所有的p<sup>[1]</sup>都将被标记为暂停，停止运行任何代码。</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200428164444.png"></p>
<p>第三步，然后，go调度器将M<sup>[2]</sup>与P分离,并且将M放到空闲列表里面。</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200428164609.png"></p>
<p>对于在每个M上运行的Goroutines，它们将在全局队列<sup>[3]</sup>&gt;中等待：</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200428164654.png"></p>
<p>那么，一旦所有的<code>goroutines</code>都停止了，那么唯一活跃的<code>goroutines</code> （垃圾回收<code>goroutines</code>）将会安全的运行，并且在垃圾回收完成后，重新拉起所有的<code>goroutines</code>。具体情况，可以通过 go trace查看。</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200428165140.png"></p>
<h1 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h1><p>STW时期可能会影响系统调用，因为系统调用可能会在stw时期返回，通过密集执行系统调用的程序来看看怎样处理这种情况，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">   wg.Add(<span class="number">10</span>)   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         http.Get(<span class="string">`https://httpstat.us/200`</span>)</span><br><span class="line">         wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;   wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的trace情况。</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200428165604.png"></p>
<p>系统调用在STW时期返回，但是现在已经没有P在运行了。所以他会放到全局队列里面,等待STW结束后再运行。</p>
<h1 id="Latencies"><a href="#Latencies" class="headerlink" title="Latencies"></a>Latencies</h1><p>STW的第三步将所有的M与P分离。然而，go将等待调度程序运行、系统调用等自动停止。等待goroutine被抢占应该很快，但是在某些情况下会产生一些延迟，下面是一个极端的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> t <span class="type">int</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">20</span> ;i++  &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">1000000000</span> ;i++ &#123;</span><br><span class="line">            t++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   runtime.GC()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>STW时长达到了2.6S</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200428172521.png"></p>
<p>没有函数调用的goroutine将不会被抢占，并且它的P在任务结束之前不会被释放。这将迫使STW等待他， 有几种解决方案可改善循环中的抢占，有关其的更多信息，可以查看作者另外一篇文章 [<a href="https://medium.com/a-journey-with-go/go-goroutine-and-preemption-d6bc2aa2f4b7">Go: Goroutine and Preemption).</a></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>hash table 一个古老的经典数据结构</title>
    <url>/2024/02/26/hash%20table%20%E4%B8%80%E4%B8%AA%E5%8F%A4%E8%80%81%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Hash_table">哈希表</a>一种古老的数据结构，在 1953 年就有人使用拉链法实现了哈希表，它能够通过键直接获取该键对应的值。</p>
<span id="more"></span>
<p>哈希表是计算机科学中的最重要数据结构之一，这不仅因为它 𝑂(1)的读写性能非常优秀，还因为它提供了键值之间的映射。想要实现一个性能优异的哈希表，需要注意两个关键点 —— 哈希函数和冲突解决方法。</p>
<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1><p>实现哈希表的关键点在于哈希函数的选择，哈希函数的选择在很大程度上能够决定哈希表的读写性能。在理想情况下，哈希函数应该能够将不同键映射到不同的索引上，这要求<strong>哈希函数的输出范围大于输入范围</strong>，但是由于键的数量会远远大于映射的范围，所以在实际使用时，这个理想的效果是不可能实现的。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/02/115908816b27b8962368c75184a9b3db.png" alt="Pasted image 20240226162401"></p>
<p>比较实际的方式是让哈希函数的结果能够尽可能的均匀分布，然后通过工程上的手段解决哈希碰撞的问题。哈希函数映射的结果一定要尽可能均匀，结果不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。</p>
<p>如果使用结果分布较为均匀的哈希函数，那么哈希的增删改查的时间复杂度为 𝑂(1)；但是如果哈希函数的结果分布不均匀，那么所有操作的时间复杂度可能会达到 𝑂(𝑛)，由此看来，使用好的哈希函数是至关重要的。</p>
<h1 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h1><p>就像我们之前所提到的，在通常情况下，哈希函数输入的范围一定会远远大于输出的范围，所以在使用哈希表时一定会遇到冲突，哪怕我们使用了完美的哈希函数，当输入的键足够多也会产生冲突。然而多数的哈希函数都是不够完美的，所以仍然存在发生哈希碰撞的可能，这时就需要一些方法来解决哈希碰撞的问题，常见方法的就是开放寻址法和拉链法。</p>
<blockquote>
<p>需要注意的是，这里提到的哈希碰撞不是多个键对应的哈希完全相等，可能是多个哈希的部分相等，例如：两个键对应哈希的前四个字节相同。</p>
</blockquote>
<h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p><a href="https://en.wikipedia.org/wiki/Open_addressing">开放寻址法</a>是一种在哈希表中解决哈希碰撞的方法，这种方法的核心思想是<strong>依次探测和比较数组中的元素以判断目标键值对是否存在于哈希表中</strong>，如果我们使用开放寻址法来实现哈希表，那么实现哈希表底层的数据结构就是数组，不过因为数组的长度有限，向哈希表写入 (author, draven) 这个键值对时会从如下的索引开始遍历：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">index := hash(<span class="string">&quot;author&quot;</span>) % array.<span class="built_in">len</span></span><br></pre></td></tr></table></figure>
<p>当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置：<br><img src="https://images.hxzhouh.com/blog-images/2024/02/36c3801d2fdec9f0f37196273076e6c6.png" alt="Pasted image 20240226163147"></p>
<p>如上图所示，当 Key3 与已经存入哈希表中的两个键值对 Key1 和 Key2 发生冲突时，Key3 会被写入 Key2 后面的空闲位置。当我们再去读取 Key3 对应的值时就会先获取键的哈希并取模，这会先帮助我们找到 Key1，找到 Key1 后发现它与 Key 3 不相等，所以会继续查找后面的元素，直到内存为空或者找到目标元素。</p>
<p>当需要查找某个键对应的值时，会从索引的位置开始线性探测数组，找到目标键值对或者空内存就意味着这一次查询操作的结束。</p>
<p>开放寻址法中对性能影响最大的是<strong>装载因子</strong>，它是数组中元素的数量与数组大小的比值。随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 𝑂(𝑛) 的，这时需要遍历数组中的全部元素，所以在实现哈希表时一定要关注装载因子的变化。</p>
<h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>与开放地址法相比，拉链法是哈希表最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p>
<p>实现拉链法一般会使用数组加上链表，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成可以扩展的二维数组：<br><img src="https://images.hxzhouh.com/blog-images/2024/02/c08cf7411207d7e1243b466d389c0d84.png" alt="Pasted image 20240226163743"></p>
<p>如上图所示，当我们需要将一个键值对 (Key5, Value5) 写入哈希表时，键值对中的键 Key5 都会先经过一个哈希函数，哈希函数返回的哈希会帮助我们选择一个桶，和开放地址法一样，选择桶的方式是直接对哈希返回的结果取模：</p>
<p>选择了 7 号桶后就可以遍历当前桶中的链表了，在遍历链表的过程中会遇到以下两种情况：</p>
<ol>
<li>找到键相同的键值对 — 更新键对应的值；</li>
<li>没有找到键相同的键值对 — 在链表的末尾追加新的键值对；</li>
</ol>
<p>如果要在哈希表中获取某个键对应的值，会经历如下的过程：<br><img src="https://images.hxzhouh.com/blog-images/2024/02/c83cdf09292493a641d1dca35f44b7b7.png" alt="Pasted image 20240226163932"><br>Key6 展示了一个键在哈希表中不存在的例子，当哈希表发现它命中 5 号桶时，它会依次遍历桶中的链表，然而遍历到链表的末尾也没有找到期望的键，所以哈希表中没有该键对应的值。</p>
<p>在一个性能比较好的哈希表中，每一个桶中都应该有 0<del>1 个元素，有时会有 2</del>3 个，很少会超过这个数量。计算哈希、定位桶和遍历链表三个过程是哈希表读写操作的主要开销，使用拉链法实现的哈希也有装载因子这一概念：</p>
<p><code>装载因子:=元素数量÷桶数量</code></p>
<p>与开放地址法一样，拉链法的装载因子越大，哈希的读写性能就越差。在一般情况下使用拉链法的哈希表装载因子都不会超过 1，当哈希表的装载因子较大时会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。如果有 1000 个桶的哈希表存储了 10000 个键值对，它的性能是保存 1000 个键值对的 1&#x2F;10，但是仍然比在链表中直接读写好 1000 倍。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文讲述了hashtable 的基本工作原理， 哈希表是一种非常重要的数据结构，它能提供快速的键值映射，并有良好的读写性能。哈希表的性能主要取决于两个关键点：哈希函数的选择和冲突解决方法。<br>实际上还有很多工程上的问题没有回答，比如hash函数的性能，hash 如何动态扩缩容，还有 基于红黑树优化bucket 的性能等，这些都是工程上的问题，不影响我们了解hashtable 的工作原理。<br>下一篇我们将基于 hashtable 的基础知识，深入了解go语言map 的设计与实现。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode解题笔记-114-原地算法</title>
    <url>/2020/03/24/leetcode%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0-114-%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, an <strong>in-place algorithm</strong> is an <a href="https://en.wikipedia.org/wiki/Algorithm">algorithm</a> which transforms input using no auxiliary <a href="https://en.wikipedia.org/wiki/Data_structure">data structure</a>. However a small amount of extra storage space is allowed for auxiliary variables. The input is usually overwritten by the output as the algorithm executes. In-place algorithm updates input sequence only through replacement or swapping of elements. An algorithm which is not in-place is sometimes called <strong>not-in-place</strong> or <strong>out-of-place</strong>.——摘自<a href="https://en.wikipedia.org/wiki/In-place_algorithm">原地算法</a>的维基百科</p>
</blockquote>
<p>一句话总结就是: 原地算法不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>假设要将具有 <em>n</em> 项内容的数组 a 翻转过来。一种看似简单的方法是创建一个大小相等的新数组，用适当的顺序填充副本，然后再删除：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">function reverse(a[<span class="number">0.</span>.n-<span class="number">1</span>])</span><br><span class="line">     allocate b[<span class="number">0.</span>.n-<span class="number">1</span>]  <span class="comment"># 额外设定一个数组</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to n-<span class="number">1</span> <span class="comment"># 从 0 到 n-1 遍历数组 a</span></span><br><span class="line">         b[n -<span class="number">1</span> - i] := a[i] </span><br><span class="line">     <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>

<p>这种方法虽然简单，但是需要 O(n) 的额外空间以使数组 a 和 b 同时可用。此外，分配存储空间和释放存储空间通常是缓慢的操作。如果我们不再需要数组 a 的话，可使用原地算法，用它自己翻转的内容来覆盖掉原先的内容。这样，无论数组有多大，它都只需要辅助变量 i 和 tmp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">function reverse_in_place(a[<span class="number">0.</span>.n-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">from</span> <span class="number">0</span> to floor((n-<span class="number">2</span>)/<span class="number">2</span>)</span><br><span class="line">        tmp := a[i]</span><br><span class="line">        a[i] := a[n − <span class="number">1</span> − i]</span><br><span class="line">        a[n − <span class="number">1</span> − i] := tmp</span><br></pre></td></tr></table></figure>

<p>这样既节省了存储器空间又加快了运算速度。</p>
<p>example:</p>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">leetCode 114</a></p>
<p>go 实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatten</span><span class="params">(root *TreeNode)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	flatten(root.Left)</span><br><span class="line">	flatten(root.Right)</span><br><span class="line">	temp := root.Right</span><br><span class="line">	root.Right = root.Left</span><br><span class="line">	root.Left = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">for</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">		root = root.Right</span><br><span class="line">	&#125;</span><br><span class="line">	root.Right = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是使用前序遍历把右边的树节点移动到左边</p>
<p>第一趟，处理的节点为3，保持不变</p>
<p>第二趟，处理节点 4 保持不变</p>
<p>第三趟，处理节点2 需要把 节点3移动到2的右节点，然后把4 移动到2的最右的右节点</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200324161451.png"></p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200324161514.png"></p>
<p>第四趟：处理节点6，不变。</p>
<p>第五趟处理节点 5 不变，</p>
<p>第六趟处理节点1 需要把 2 移动到 1 的右节点，然后把 5 移动到 1的最右右节点。</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200324161751.png"></p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200324161823.png"></p>
<p>到此，移动完毕，全程只用了一个变量temp。满足原地算法。</p>
]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>medium 写作一个月的心得</title>
    <url>/2024/02/19/medium%20%E5%86%99%E4%BD%9C%E4%B8%80%E4%B8%AA%E6%9C%88%E7%9A%84%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>1月份的时候，从一个网友那里得到经验，再medium上写作可以赚钱。于是开通<a href="https://x1mdx3wzpm.feishu.cn/docx/UA99drQcroan5Jx3aiXcwGoEnMg">会员计划</a>，然后。开始写作，1.9 到今天 2.19 已经写了22篇文章（都是我以前的文章翻译）总共有 73个follows<br>总阅读量 645，获得收益 $25.5<br><img src="https://images.hxzhouh.com/blog-images/2024/02/a086a96e967a82f1a4272b7f65ca3abb.png" alt="Pasted image 20240219174914"></p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/02/4c12d557403a2278a3e2c648385aa188.png" alt="Pasted image 20240219173904"></p>
<p>关于这一个月的总结：</p>
<ol>
<li><p>medium 的确能赚到钱，<br> 一月份的 $9.8 扣税后，已经到了我的支付宝。很多人通过medium 赚到了可观的收入（当然，这需要一点运气以及耐心） 。比如这个作者，通过一篇30分钟时间写的文章获得了10000多块的收入，并且还在持续增加中。 <a href="https://catcoding.me/p/my-writing-story-on-medium/">我如何写出一万元的文章</a></p>
</li>
<li><p>利用出版物<br> 当开始写作后，可以选择出版物发表文章，利用出版物自带的流量完成冷启动，比如我经常投稿的 <a href="https://levelup.gitconnected.com/">LevelUpCode</a>  就是一个流量不错的出版物。出版物如果支持投稿的话，会在他们主页写明<a href="https://levelup.gitconnected.com/how-to-get-published-on-gitconnected-dac547ef556b">wirte for us</a>,根据他们的要求做就是了。<br>  大概的流程就是</p>
<ol>
<li>在medium 写一篇文章，保存成草稿</li>
<li>将草稿连接发送给出版物的编辑，</li>
<li>编辑会给你回邮件，将你添加为作者（一周以内）</li>
<li>然后在medium 就可以选择出版物发表了（其实也是推送草稿给出版物的编辑）。</li>
<li>最后，编辑会审核你的文章，然后由他们发表。</li>
</ol>
</li>
<li><p>一些常用的软件以及web工具（mac）</p>
<ol>
<li>为博客制作封面图片 <a href="https://coverview.vercel.app/">https://coverview.vercel.app/</a> </li>
<li>屏幕录制软件 FocuSee </li>
<li>制作gif图片 picgif lite</li>
<li>画图软件 draw.io 或者 excalidraw</li>
<li>翻译工具 bob chatgpt</li>
<li>写作工具我用的是 typro，typro复制粘贴到 medium 能最大程度保持格式。</li>
</ol>
</li>
<li><p>关于阅读量和涨粉</p>
<ol>
<li>我现在主要是通过社区里面的朋友点赞😄。</li>
<li>春节期间，我没有上medium 也涨了30左右的粉丝，每天的阅读量也有50左右，应该都是来自出版物的自然流量。</li>
<li>多关注别人，用心评论别人的文章，蹭大佬的流量。 把medium当成学习的平台，而不是单纯只蹭流量。</li>
<li>看了比较多教人写meidium文章的文章，基本上都再说一个好标题，以及好的配图之类的 巴啦巴啦， 二月-三月我会实践一下，在写一篇如何提高阅读量的文章。<br>从启动到现在，大概就是做了这些事情把，也算是开始了，后面有新的想法，再更新。。。</li>
</ol>
</li>
</ol>
<p>good enjoy 😁</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>medium</tag>
      </tags>
  </entry>
  <entry>
    <title>medium能让你快速的赚到钱？ 不可能</title>
    <url>/2024/02/23/medium%E8%83%BD%E8%AE%A9%E4%BD%A0%E5%BF%AB%E9%80%9F%E7%9A%84%E8%B5%9A%E5%88%B0%E9%92%B1%EF%BC%9F%20%E4%B8%8D%E5%8F%AF%E8%83%BD/</url>
    <content><![CDATA[<p>medium能让你快速的赚到钱？ 不可能<br>我要用我两个月的经历告诉你们，这是不可能的</p>
<span id="more"></span>

<p>我很早就加入了medium，但是没有开通付费会员，也没有怎么使用，也没上面发表过文章，1月份，我在一个论坛里面知道加入MPP会员，写作然后就可以赚钱。这是一个很疯狂的想法。<br>我的主业是一个后端程序员，偶尔有写博客的习惯，但是以前也没有写博客赚钱的想法，我是一个写作上的新手。<br>我开始的时候陆续搬运自己以前写的博客到medium，然后，我的噩梦就开始了，</p>
<p>我开始每天盯着 我的follows数量，每天看reads 数量，等着更新收益， 然后得到一个0.0x 美元。<br>从一月到二月，我发表了15篇左右的付费文章，我的follows 数量是40，阅读数量大概在200左右。</p>
<p>我看到medium 上很多人教你，一个星期获得 follows ，2个月2k follows，收益$1000, 发表的文章都是让你如何快速获得follows，打造你的吸引力。。。。<br>可是，这个真的有用嘛？<br>我开始疯狂的给别人follow，给别人的帖子鼓掌，每天打开medium 100次，查看动态是不是有人follow，有时候会增加几个follows，我会开心的发疯，有时候看到掉了follows 我会很失落，我没有吸过毒，但是那种感觉我觉得就是吸毒。严重影响到了我的生活跟工作。<br>这样是不对的。<br>medium 是一个优秀的社区，里面有很多人分享自己写的优秀的文章，比如<a href="https://medium.com/@blanchon.vincent">Vincent</a>等，他是我学习go语言的导师。但是在我这里，变成了我想博人眼球的工具。不应该是这样的。medium 上有很多教人写作的文章，但是 绝对不是像我现在这样，这么计较follows 的数量，为了阅读、follows 不顾一切，有点本末倒置了。</p>
<p>下面我将这样做</p>
<ol>
<li>对我过去两个星期follows的表示真诚的道歉，我follow你们并不是我真的喜欢你的文章，而是我想要你follow 回我。</li>
<li>认真的对待我的每一篇文章，通过自己的写的文章来打动读者。</li>
<li>回归生活，热爱生活。多读书，而不是想着一天要写一篇文章，骗几个follows</li>
<li>medium 是个很好的平台，你的优秀作品能够在这里得到金钱的回报，但是不要太计较得失，作品写得好，自然会有人给你鼓掌。</li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>medium</tag>
        <tag>副业</tag>
      </tags>
  </entry>
  <entry>
    <title>new跟make 的区别</title>
    <url>/2020/03/21/new%E8%B7%9Fmake%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="new跟make-的区别"><a href="#new跟make-的区别" class="headerlink" title="new跟make 的区别"></a>new跟make 的区别</h1><blockquote>
<p>new 和 make 都可以用来分配空间，初始化类型，但是它们确有不同。</p>
</blockquote>
<h2 id="new-T-返回的是-T-的指针"><a href="#new-T-返回的是-T-的指针" class="headerlink" title="new(T) 返回的是 T 的指针"></a><strong>new(T) 返回的是 T 的指针</strong></h2><p>new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 *T，该指针指向 T 的新分配的零值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p1 := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;p1 --&gt; %#v \n &quot;</span>, p1) <span class="comment">//(*int)(0xc42000e250)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p1 point to --&gt; %#v \n &quot;</span>, *p1) <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> p2 *<span class="type">int</span></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">p2 = &amp;i</span><br><span class="line">fmt.Printf(<span class="string">&quot;p2 --&gt; %#v \n &quot;</span>, p2) <span class="comment">//(*int)(0xc42000e278)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;p2 point to --&gt; %#v \n &quot;</span>, *p2) <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>上面的代码是等价的，new(int) 将分配的空间初始化为 int 的零值，也就是 0，并返回 int 的指针，这和直接声明指针并初始化的效果是相同的。</p>
<h2 id="make-只能用于-slice-map-channel"><a href="#make-只能用于-slice-map-channel" class="headerlink" title="make 只能用于 slice,map,channel"></a><strong>make 只能用于 slice,map,channel</strong></h2><p>make 只能用于 slice，map，channel 三种类型，make(T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> s1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s1 is nil --&gt; %#v \n &quot;</span>, s1) <span class="comment">// []int(nil)</span></span><br><span class="line">&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> s2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s2 is nil --&gt; %#v \n &quot;</span>, s2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;s2 is not nill --&gt; %#v \n &quot;</span>, s2)<span class="comment">// []int&#123;0, 0, 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slice 的零值是 nil，使用 make 之后 slice 是一个初始化的 slice，即 slice 的长度、容量、底层指向的 array 都被 make 完成初始化，此时 slice 内容被类型 int 的零值填充，形式是 [0 0 0]，map 和 channel 也是类似的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> m1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;m1 is nil --&gt; %#v \n &quot;</span>, m1) <span class="comment">//map[int]string(nil)</span></span><br><span class="line">&#125;</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> m2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;m2 is nil --&gt; %#v \n &quot;</span>, m2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;m2 is not nill --&gt; %#v \n &quot;</span>, m2) <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> c1 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;c1 is nil --&gt; %#v \n &quot;</span>, c1) <span class="comment">//(chan string)(nil)</span></span><br><span class="line">&#125;</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> c2 == <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;c2 is nil --&gt; %#v \n &quot;</span>, c2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;c2 is not nill --&gt; %#v \n &quot;</span>, c2)<span class="comment">//(chan string)(0xc420016120)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="make-T-args-返回的是-T-的-引用"><a href="#make-T-args-返回的是-T-的-引用" class="headerlink" title="make(T, args) 返回的是 T 的 引用"></a><strong>make(T, args) 返回的是 T 的 引用</strong></h2><p>如果不特殊声明，go 的函数默认都是按值传参，即通过函数传递的参数是值的副本，在函数内部对值修改不影响值的本身，但是 make(T, args) 返回的值通过函数传递参数之后可以直接修改，即 map，slice，channel 通过函数穿参之后在函数内部修改将影响函数外部的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifySlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, s2) <span class="comment">//[]int&#123;0, 0, 0&#125;</span></span><br><span class="line">modifySlice(s2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, s2) <span class="comment">//[]int&#123;1, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>

<p>这说明 make(T, args) 返回的是引用类型，在函数内部可以直接更改原始值，对 map 和 channel 也是如此。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	m[<span class="number">0</span>] = <span class="string">&quot;string&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyChan</span><span class="params">(c <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	c &lt;- <span class="string">&quot;string&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> m2 == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m2 is nil --&gt; %#v \n &quot;</span>, m2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;m2 is not nill --&gt; %#v \n &quot;</span>, m2) <span class="comment">//map[int]string&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">modifyMap(m2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;m2 is not nill --&gt; %#v \n &quot;</span>, m2) <span class="comment">// map[int]string&#123;0:&quot;string&quot;&#125;</span></span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> c2 == <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c2 is nil --&gt; %#v \n &quot;</span>, c2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;c2 is not nill --&gt; %#v \n &quot;</span>, c2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> modifyChan(c2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;c2 is not nill --&gt; %#v &quot;</span>, &lt;-c2) <span class="comment">//&quot;string&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="很少需要使用-new"><a href="#很少需要使用-new" class="headerlink" title="很少需要使用 new"></a><strong>很少需要使用 new</strong></h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明初始化</span></span><br><span class="line"><span class="keyword">var</span> foo1 Foo</span><br><span class="line">fmt.Printf(<span class="string">&quot;foo1 --&gt; %#v\n &quot;</span>, foo1) <span class="comment">//main.Foo&#123;age:0, name:&quot;&quot;&#125;</span></span><br><span class="line">foo1.age = <span class="number">1</span></span><br><span class="line">fmt.Println(foo1.age)</span><br><span class="line"><span class="comment">//struct literal 初始化</span></span><br><span class="line">foo2 := Foo&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;foo2 --&gt; %#v\n &quot;</span>, foo2) <span class="comment">//main.Foo&#123;age:0, name:&quot;&quot;&#125;</span></span><br><span class="line">foo2.age = <span class="number">2</span></span><br><span class="line">fmt.Println(foo2.age)</span><br><span class="line"><span class="comment">//指针初始化</span></span><br><span class="line">foo3 := &amp;Foo&#123;&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;foo3 --&gt; %#v\n &quot;</span>, foo3) <span class="comment">//&amp;main.Foo&#123;age:0, name:&quot;&quot;&#125;</span></span><br><span class="line">foo3.age = <span class="number">3</span></span><br><span class="line">fmt.Println(foo3.age)</span><br><span class="line"><span class="comment">//new 初始化</span></span><br><span class="line">foo4 := <span class="built_in">new</span>(Foo)</span><br><span class="line">fmt.Printf(<span class="string">&quot;foo4 --&gt; %#v\n &quot;</span>, foo4) <span class="comment">//&amp;main.Foo&#123;age:0, name:&quot;&quot;&#125;</span></span><br><span class="line">foo4.age = <span class="number">4</span></span><br><span class="line">fmt.Println(foo4.age)</span><br><span class="line"><span class="comment">//声明指针并用 new 初始化</span></span><br><span class="line"><span class="keyword">var</span> foo5 *Foo = <span class="built_in">new</span>(Foo)</span><br><span class="line">fmt.Printf(<span class="string">&quot;foo5 --&gt; %#v\n &quot;</span>, foo5) <span class="comment">//&amp;main.Foo&#123;age:0, name:&quot;&quot;&#125;</span></span><br><span class="line">foo5.age = <span class="number">5</span></span><br><span class="line">fmt.Println(foo5.age)</span><br></pre></td></tr></table></figure>

<p>foo1 和 foo2 是同样的类型，都是 Foo 类型的值，foo1 是通过 var 声明，Foo 的 filed 自动初始化为每个类型的零值，foo2 是通过字面量的完成初始化。foo3，foo4 和 foo5 是一样的类型，都是 Foo 的指针 <em>Foo。</em>*<em>但是所有 foo 都可以直接使用 Foo 的 filed，读取或修改，为什么？</em>如果 x 是可寻址的，&amp;x 的 filed 集合包含 m，x.m 和 (&amp;x).m 是等同的，go 自动做转换，也就是 foo1.age 和 foo3.age 调用是等价的，go 在下面自动做了转换。因而可以直接使用 struct literal 的方式创建对象，能达到和 new 创建是一样的情况而不需要使用 new。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><ul>
<li><p>new(T) 返回 T 的指针 *T 并指向 T 的零值。</p>
</li>
<li><p>make(T) 返回的初始化的 T，只能用于 slice，map，channel。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么TCP断开的时候需要四次挥手</title>
    <url>/2024/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E6%96%AD%E5%BC%80%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<p>TCP协议是我们日常使用的网络协议之一，它不仅负责建立连接，还负责断开连接。上面上一篇<a href="https://levelup.gitconnected.com/why-tcp-requires-three-handshakes-to-establish-a-connection-31d814aac6b8">博客</a>，我们分析了 Why TCP requires three handshakes to establish a connection,建立连接时，我们需要保证历史连接以及序列号的问题。 与建立连接时的三次握手不同，断开连接时需要进行四次挥手（four-way handshake）。本文将探讨为什么TCP断开连接需要进行四次挥手，而不是三次或其他次数。</p>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在深入讨论为什么需要四次挥手之前，我们先来了解一下TCP连接的断开过程。通常情况下，当通信双方中的一方决定断开连接时，它会发送一个FIN（Finish）控制消息给对方，表示自己已经没有数据要发送了。接收到FIN消息的一方会发送一个ACK（Acknowledgment）控制消息作为确认，并进入半关闭状态，表示自己不再发送数据，但仍然可以接收数据。当另一方也没有数据要发送时，它会发送一个FIN消息给对方，表示自己也准备断开连接。接收到这个FIN消息的一方会再次发送一个ACK消息进行确认，然后两端的连接才会完全关闭。<br><img src="https://images.hxzhouh.com/blog-images/2024/03/a710aaf52810ad7ecd7423ca98a4f343.png" alt="Pasted image 20240201170632"></p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>为什么TCP断开连接需要进行四次挥手？下面我们从几个方面来分析这个问题：</p>
<h3 id="确保数据完整性"><a href="#确保数据完整性" class="headerlink" title="确保数据完整性"></a>确保数据完整性</h3><p>TCP协议是面向连接的可靠传输协议，它保证数据的可靠性和完整性。在断开连接时，双方可能还有未发送或未接收的数据包。如果只进行三次挥手，那么在最后一次挥手时，对方可能无法得知自己发送的FIN消息是否已经被接收。这样一来，可能会导致对方未能完全接收到自己的数据，造成数据的丢失。因此，通过进行四次挥手，可以确保双方都能够完整地接收到对方的数据，保证数据的完整性。</p>
<h3 id="处理网络延迟和丢包"><a href="#处理网络延迟和丢包" class="headerlink" title="处理网络延迟和丢包"></a>处理网络延迟和丢包</h3><p>在网络中，数据包可能会因为网络延迟或丢包而无法及时到达目的地。在断开连接时，如果只进行三次挥手，那么在最后一次挥手时，对方可能无法得知自己发送的FIN消息是否已经被接收，这就无法保证对方能够及时关闭连接。通过进行四次挥手，可以给网络提供足够的时间来处理延迟和丢包问题，确保连接能够正确地关闭。</p>
<h3 id="等待未发送的数据发送完毕"><a href="#等待未发送的数据发送完毕" class="headerlink" title="等待未发送的数据发送完毕"></a>等待未发送的数据发送完毕</h3><p>在断开连接时，双方可能还有未发送的数据包。如果只进行三次挥手，那么在最后一次挥手时，对方可能无法得知自己发送的FIN消息之前是否还有未发送完的数据。通过进行四次挥手，可以给双方足够的时间来发送和接收剩余的数据，确保数据的完整性和正确性。</p>
<h3 id="处理半关闭状态"><a href="#处理半关闭状态" class="headerlink" title="处理半关闭状态"></a>处理半关闭状态</h3><p>在TCP连接的断开过程中，一方先发送FIN消息进入半关闭状态，表示自己不再发送数据但仍然可以接收数据。如果只进行三次挥手，那么对方在接收到FIN消息后会立即关闭连接，这样就无法保证另一方能够正确地处理半关闭状态。通过进行四次挥手，可以确保双方都能够正确地处理半关闭状态，避免数据的丢失和混乱。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上分析，我们可以得出结论：TCP断开连接需要进行四次挥手是为了确保数据的完整性、处理网络延迟和丢包、等待未发送的数据发送完毕以及处理半关闭状态。通过四次挥手，双方能够更好地协调和处理连接的断开，确保数据的正确传输和连接的安全关闭。</p>
<p>在讨论TCP断开连接时，我们不应该执着于为什么使用四次挥手，而是应该理解为什么需要进行多次挥手来保证数据的完整性和连接的正确关闭。通过对TCP协议设计的深入理解，我们能够更好地应用和理解网络通信的原理和机制。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol - IETF Tools</a></li>
<li><a href="https://networkengineering.stackexchange.com/questions/24072/why-do-we-need-a-4-way-handshake-to-terminate-a-tcp-connection">Why do we need a 4-way handshake to terminate a TCP connection?</a></li>
<li><a href="https://www.geeksforgeeks.org/why-tcp-connect-termination-need-4-way-handshake">why-tcp-connect-termination-need-4-way-handshake</a></li>
</ul>
]]></content>
      <categories>
        <category>为什么这么设计</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么TCP连接时需要3次握手</title>
    <url>/2024/02/16/%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E8%BF%9E%E6%8E%A5%E6%97%B6%E9%9C%80%E8%A6%813%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    <content><![CDATA[<p>TCP 协议是我们几乎每天都会接触到的网络协议，绝大多数网络连接的建立都是基于 TCP 协议的，学过计算机网络或者对 TCP 协议稍有了解的人都知道 —— 使用 TCP 协议建立连接需要经过三次握手（three-way handshake）。</p>
<p>如果让我们简单说说 TCP 建立连接的过程，相信很多准备过面试的人都会非常了解，但是一旦想要深究『为什么 TCP 建立连接需要三次握手？』，作者相信大多数人都没有办法回答这个问题或者会给出错误的答案，这边文章就会讨论究竟为什么我们需要三次握手才能建立 TCP 连接？而不是四次、或者两次？</p>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在具体分析今天的问题之前，我们首先可以了解一下最常见的错误类比，这个对 TCP 连接过程的错误比喻误导了很多人，作者在比较长的一段时间内也认为它能够很好地描述 TCP 建立连接为什么需要三次握手：</p>
<ol>
<li>你听得到吗？</li>
<li>我能听到，你听得到？</li>
<li>我也能听到；<br>这种用类比来解释问题往往就会面临『十个类比九个错』的尴尬局面，如果别人用类比回答你的为什么，你需要仔细想一想它的类比里究竟哪里有漏洞；类比带来的解释往往只能有片面的相似性，我们永远也无法找到绝对正确的类比，它只在我们想要通俗易懂地展示事物的特性时才能发挥较大的作用，我们在文章的后面会介绍为什么这里的类比有问题，各位读者也可以带着疑问来阅读剩下的内容。</li>
</ol>
<p>很多人尝试回答或者思考这个问题的时候其实关注点都放在了三次握手中的<strong>三次</strong>上面，这确实很重要，但是如果重新审视这个问题，我们对于『什么是连接』真的清楚？只有知道<strong>连接的定义</strong>，我们才能去尝试回答为什么 TCP 建立连接需要三次握手。</p>
<blockquote>
<p>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p>
</blockquote>
<p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 文档中非常清楚地定义了 TCP 中的连接是什么，我们简单总结一下：<strong>用于保证可靠性和流控制机制的信息，包括 Socket、序列号以及窗口大小叫做连接</strong>。</p>
<p>所以，建立 TCP 连接就是通信的双方需要对上述的三种信息达成共识，连接中的一对 Socket 是由互联网地址标志符和端口组成的，窗口大小主要用来做流控制，最后的序列号是用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。</p>
<p>到这里，我们将原有的问题转换成了『为什么需要通过三次握手才可以初始化 Sockets、窗口大小和初始序列号？』，那么接下来我们就开始对这个细化的问题进行分析并寻找解释。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>这篇文章主要会从以下几个方面介绍为什么我们需要通过三次握手才可以初始化 Sockets、窗口大小、初始序列号并建立 TCP 连接：</p>
<ul>
<li>通过三次握手才能阻止重复历史连接的初始化；</li>
<li>通过三次握手才能对通信双方的初始序列号进行初始化；</li>
<li>讨论其他次数握手建立连接的可能性；<br>这几个论点中的第一个是 TCP 选择使用三次握手的最主要原因，其他的几个原因相比之下都是次要的原因，我们在这里对它们的讨论只是为了让整个视角更加丰富，通过多方面理解这一有趣的设计决策。</li>
</ul>
<h3 id="历史连接"><a href="#历史连接" class="headerlink" title="历史连接"></a>历史连接</h3><p><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 其实就指出了 TCP 连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接。</p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
</blockquote>
<p><img src="https://images.hxzhouh.com/blog-images/2024/02/25f77d0eeb97056245cda65f64a9883b.png" alt="Pasted image 20240130105811"></p>
<p>想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 TCP 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。</p>
<p>所以，TCP 选择使用三次握手来建立连接并在连接引入了 <code>RST</code> 这一控制消息，接收方当收到请求时会将发送方发来的 <code>SEQ+1</code> 发送给对方，这时由发送方来判断当前连接是否是历史连接：</p>
<ul>
<li>如果当前连接是历史连接，即 <code>SEQ</code> 过期或者超时，那么发送方就会直接发送 <code>RST</code> 控制消息中止这一次连接；</li>
<li>如果当前连接不是历史连接，那么发送方就会发送 <code>ACK</code> 控制消息，通信双方就会成功建立连接；</li>
</ul>
<p>使用三次握手和 <code>RST</code> 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 TCP 使用三次握手建立连接的最主要原因。</p>
<h3 id="初始序列号"><a href="#初始序列号" class="headerlink" title="初始序列号"></a>初始序列号</h3><p>另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，TCP 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，TCP 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 ACK 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>序列号在 TCP 连接中有着非常重要的作用，初始序列号作为 TCP 连接的一部分也需要在三次握手期间进行初始化，由于 TCP 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 <code>SYN</code> 控制消息并携带自己期望的初始化序列号 <code>SEQ</code>，对方在收到 <code>SYN</code> 消息之后会通过 <code>ACK</code> 控制消息以及 <code>SEQ+1</code> 来进行确认。</p>
<p>如上图所示，通信双方的两个 <code>TCP A/B</code> 分别向对方发送 <code>SYN</code> 和 <code>ACK</code> 控制消息，等待通信双方都获取到了自己期望的初始化序列号之后就可以开始通信了，由于 TCP 消息头的设计，我们可以将中间的两次通信合成一个，<code>TCP B</code> 可以向 <code>TCP A</code> 同时发送 <code>ACK</code> 和 <code>SYN</code> 控制消息，这也就帮助我们将四次通信减少至三次。</p>
<blockquote>
<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>
</blockquote>
<p>除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 TCP 可以通过不同的机制来初始化序列号，作为 TCP 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，TCP 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。</p>
<h3 id="通信次数"><a href="#通信次数" class="headerlink" title="通信次数"></a>通信次数</h3><p>当我们讨论 TCP 建立连接需要的通信次数时，我们经常会执着于为什么通信三次才可以建立连接，而不是两次或者四次；讨论使用更多的通信次数来建立连接往往是没有意义的，因为我们总可以<strong>使用更多的通信次数交换相同的信息</strong>，所以使用四次、五次或者更多次数建立连接在技术上都是完全可以实现的。<br>这种增加 TCP 连接通信次数的问题往往没有讨论的必要性，我们追求的其实是用更少的通信次数（理论上的边界）完成信息的交换，也就是为什么我们在上两节中也一再强调使用『两次握手』没有办法建立 TCP 连接，使用三次握手是建立连接所需要的最小次数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们在这篇文章中讨论了为什么 TCP 建立连接需要经过三次握手，在具体分析这个问题之前，我们首先重新思考了 TCP 连接究竟是什么，<a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol - IETF Tools</a> 对 TCP 连接有着非常清楚的定义 —— 用于保证可靠性和流控制机制的数据，包括 Socket、序列号以及窗口大小。</p>
<p>TCP 建立连接时通过三次握手可以有效地避免历史错误连接的建立，减少通信双方不必要的资源消耗，三次握手能够帮助通信双方获取初始化序列号，它们能够保证数据包传输的不重不丢，还能保证它们的传输顺序，不会因为网络传输的问题发生混乱，到这里不使用『两次握手』和『四次握手』的原因已经非常清楚了：</p>
<ul>
<li>『两次握手』：无法避免历史错误连接的初始化，浪费接收方的资源；</li>
<li>『四次握手』：TCP 协议的设计可以让我们同时传递 <code>ACK</code> 和 <code>SYN</code> 两个控制信息，减少了通信次数，所以不需要使用更多的通信次数传输相同的信息；</li>
</ul>
<p>我们重新回到在文章开头提的问题，为什么使用类比解释 TCP 使用三次握手是错误的？这主要还是因为，这个类比没有解释清楚核心问题 —— 避免历史上的重复连接。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol - IETF Tools</a></li>
<li><a href="https://networkengineering.stackexchange.com/questions/24068/why-do-we-need-a-3-way-handshake-why-not-just-2-way">Why do we need a 3-way handshake? Why not just 2-way?</a></li>
<li><a href="https://www.geeksforgeeks.org/tcp-3-way-handshake-process/"># TCP 3-Way Handshake Process</a></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是medium 的 publication</title>
    <url>/2024/03/12/%E4%BB%80%E4%B9%88%E6%98%AFmedium%20%E7%9A%84%20publication/</url>
    <content><![CDATA[<blockquote>
<p>This article is first published in the medium MPP plan. If you are a medium user, please follow me in <a href="https://medium.hxzhouh.com/">medium</a>. Thank you very much.</p>
</blockquote>
<p>publication即出版物，你可以把他理解成一本杂志，但是可以随时发布，随时修改。<br>每个 publication都有一个或者多个编辑，这个编辑负责审核你的文章，发表。总体流程 大概就这样子。</p>
<span id="more"></span>

<p><img src="https://images.hxzhouh.com/blog-images/2024/03/496a388d05f3aa5966560a4840832948.png" alt="Pasted image 20240312155507"><br>具体的细节可以看官网的说明：<br><a href="https://help.medium.com/hc/en-us/articles/115004681607-Getting-started-with-a-Medium-publication">https://help.medium.com/hc/en-us/articles/115004681607-Getting-started-with-a-Medium-publication</a></p>
<h1 id="有那些publication"><a href="#有那些publication" class="headerlink" title="有那些publication"></a>有那些publication</h1><p>官网好像没有具体的publication 排名，但是有一些 第三方网站 会追踪这些。<br>比如下面这些链接 </p>
<ul>
<li><a href="https://nickwolny.com/medium-publications/">https://nickwolny.com/medium-publications/</a></li>
<li><a href="https://medium.com/new-writers-welcome/the-big-list-of-medium-publications-2023-8f9860f74d54">https://medium.com/new-writers-welcome/the-big-list-of-medium-publications-2023-8f9860f74d54</a></li>
<li><a href="https://medium.com/@MediumStaff/list/mediums-huge-list-of-publications-accepting-submissions-7c0ec8037e61">https://medium.com/@MediumStaff/list/mediums-huge-list-of-publications-accepting-submissions-7c0ec8037e61</a><br>你可以从上面找一些流量比较大的 publication 重点关注一下。</li>
</ul>
<h1 id="如何成为作者"><a href="#如何成为作者" class="headerlink" title="如何成为作者"></a>如何成为作者</h1><p>以 Level Up Coding 为例子<br>不是每个publication都公开招募作者的，但是如果他们招募作者，就会再publication的官网显示出来。比如<a href="https://levelup.gitconnected.com/">Level Up Coding</a>这个<br><img src="https://images.hxzhouh.com/blog-images/2024/03/ee87da8b9690509d48da5472c6aac4f6.png" alt="Pasted image 20240312160108"><br>根据他们的要求，先写一篇草稿，然后把草稿发邮件给他们的编辑等待他们添加你到这个 publication 的作者。<br>这个时间 不确定，有的很快，有的很慢 （老外墨迹）Level Up Coding 我当初大概是三天，但是 <a href="https://docs.google.com/forms/d/e/1FAIpQLSd-uul5nrYehQxmUY6MTdxu8Fj6t1vSaUgG82oV42onrVJp_w/viewform">Dev Genius</a> 这个我提交了一个 超过一个星期了还没人回复。</p>
<h1 id="成为作者后，怎么发布文章。"><a href="#成为作者后，怎么发布文章。" class="headerlink" title="成为作者后，怎么发布文章。"></a>成为作者后，怎么发布文章。</h1><p>一般添加后都会有邮件回复，<br>然后在在你的草稿中选择 要出版的publish ，就像这样。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/e981881175716513b1aa586b03ca550f.gif" alt="how to push to publication"><br>提交到出版物后，不是立即就发表，而是要等 编辑审核，时间不确定，有时候还会拒绝。比如说你AI稿之类的。</p>
<h1 id="publication-优缺点"><a href="#publication-优缺点" class="headerlink" title="publication 优缺点"></a>publication 优缺点</h1><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>最大的缺点是磨叽，有时候等1个星期都不见任何反应。也不是所有的publication 乐意接受你成为作者的<br>还有一个缺点就是你的文章会显示成 publication 的域名，比如我这篇<a href="https://levelup.gitconnected.com/go-source-code-analysis-rwmutex-3498b6087d57?source=collection_home---4------1-----------------------">Go Source Code Analysis: RWmutex_</a>  ，如果你注重后期想自己发展独立站的话，这点需要考虑一下</p>
<h2 id="不明显的优点："><a href="#不明显的优点：" class="headerlink" title="不明显的优点："></a>不明显的优点：</h2><ol>
<li>可能会被审稿，提出专业的修改意见？我没遇到过 哈哈</li>
<li>出版物自带流量，比如Level Up Coding 全网100k+粉丝，你的文章发表后，会显示在它的主页，会给你增加流量吧？但是不明显<br>  <img src="https://images.hxzhouh.com/blog-images/2024/03/58e5dab79d0b28276ddec5210e73388d.png" alt="Pasted image 20240312161118"></li>
<li>publication 发表后的文章也可以随时修改，甚至撤下来，换其他的出版物，这点比较灵活。</li>
<li>看过很多写medium经验的文章，不要选择太大的出版物，因为提交的文章多，可能你的文章很快就被淹没了，一些小众的出版物，可能更好。我没尝试过。<br>总的来说，publication 就这么回事，没有明显的坏处，可能有点好处，但是也就那么多。enjoy。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>在VPS上搭建vaultwarden</title>
    <url>/2023/09/23/%E5%9C%A8VPS%E4%B8%8A%E6%90%AD%E5%BB%BAvaultwarden/</url>
    <content><![CDATA[<h1 id="在VPS上搭建vaultwarden"><a href="#在VPS上搭建vaultwarden" class="headerlink" title="在VPS上搭建vaultwarden"></a>在VPS上搭建vaultwarden</h1><p>之前一直在寻找一个支持跨平台的密码管理工具，先后尝试了 1Password 和 LastPass，迫于贫穷，切换到了开源的 <a href="https://bitwarden.com/">Bitwarden</a> 支持自托管服务端,但是 <a href="https://bitwarden.com/">Bitwarden</a> 对性能要求比较高， 退而求其次，用它的另一个实现 <a href="https://github.com/dani-garcia/vaultwarden">Vaultwarden</a>（原名 Bitwarden_rs） <a href="https://github.com/dani-garcia/vaultwarden">Vaultwarden</a> 完美兼容<a href="https://bitwarden.com/">Bitwarden</a> ，这样我们就在AWS 的免费主机上得到了一个  <a href="https://github.com/dani-garcia/vaultwarden">Vaultwarden</a> 做后端，<a href="https://bitwarden.com/">Bitwarden</a>做前端的 免费密码托管服务。<br>本文详细整理了使用vps 搭建 私有 vaultwarden服务，实现 bitwarden自托管的步骤，设置的内容有：#VPS，#反向代理，rclone 自动挂载Google Drive等。</p>
<span id="more"></span>
<h2 id="Vaultwarden-部署"><a href="#Vaultwarden-部署" class="headerlink" title="Vaultwarden 部署"></a>Vaultwarden 部署</h2><p>使用docker-compose  部署。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">vaultwarden:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">vaultwarden/server:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">vaultwarden</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3012</span><span class="string">:3012</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ADMIN_TOKEN:</span> <span class="string">V9ZE7sCSfR9hx8Pi3M+GhiBTSG1gag0G</span></span><br><span class="line">      <span class="attr">WEBSOCKET_ENABLED:</span> <span class="string">&quot;true&quot;</span> <span class="comment"># Enable WebSocket notifications.</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/vaultwarden/:/data/</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">backup:</span></span><br><span class="line">    <span class="comment">#备份服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">ttionya/vaultwarden-backup:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CRON:</span> <span class="string">&#x27;0 0 * * * ?&#x27;</span></span><br><span class="line">      <span class="attr">ZIP_ENABLE:</span> <span class="string">&#x27;TRUE&#x27;</span></span><br><span class="line">      <span class="attr">ZIP_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">      <span class="attr">ZIP_TYPE:</span> <span class="string">&#x27;zip&#x27;</span></span><br><span class="line">      <span class="attr">BACKUP_FILE_SUFFIX:</span> <span class="string">&#x27;%Y%m%d&#x27;</span></span><br><span class="line">      <span class="attr">ACKUP_KEEP_DAYS:</span> <span class="number">7</span></span><br><span class="line">      <span class="comment">#   PING_URL: &#x27;&#x27;</span></span><br><span class="line">      <span class="attr">MAIL_SMTP_ENABLE:</span> <span class="string">&#x27;TRUE&#x27;</span></span><br><span class="line">      <span class="attr">MAIL_SMTP_VARIABLES:</span> <span class="string">&#x27;  -S smtp-use-starttls \ -S smtp=smtp://smtp.164.com:587 \ -S smtp-auth=login \ -S smtp-auth-user=email-user \ -S smtp-auth-password=your-auth \ -S from=email-from(Vaultwarden_Backup)&#x27;</span></span><br><span class="line">      <span class="attr">MAIL_TO:</span> <span class="string">&#x27;example@gmail.com&#x27;</span></span><br><span class="line">      <span class="attr">MAIL_WHEN_SUCCESS:</span> <span class="string">&#x27;FALSE&#x27;</span></span><br><span class="line">      <span class="attr">MAIL_WHEN_FAILURE:</span> <span class="string">&#x27;TRUE&#x27;</span></span><br><span class="line">      <span class="attr">TIMEZONE:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">      <span class="attr">DATA_DIR:</span> <span class="string">&#x27;/data&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/vaultwarden/:/data/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vaultwarden-rclone-data:/config/</span></span><br><span class="line">    <span class="comment">#   - /path/to/env:/.env</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">vaultwarden-data:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">vaultwarden-data</span></span><br><span class="line">  <span class="attr">vaultwarden-rclone-data:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">vaultwarden-rclone-data</span></span><br></pre></td></tr></table></figure>
<p>这个docker-compose.yaml 文件包含 了 vaultwarden ，以及vaultwarden-backup 两部分。<br>运行这个前，需要设置一下 rclone，这里以 rclone 连接 google drive为例。</p>
<blockquote>
<p>rclone是一款开源的命令行工具，用于在不同云存储服务之间同步、复制和管理文件。它支持多种云存储提供商，包括Google Drive、Dropbox、Amazon S3等，允许用户通过简单的命令实现文件的上传、下载和同步，还提供了加密和缓存等功能，是一个强大的云存储管理工具。</p>
</blockquote>
<p>运行 下面的指令，进入配置页面， 参考文章 <a href="https://pickstar.today/2022/05/vps%e4%bd%bf%e7%94%a8rclone%e6%8c%82%e8%bd%bdgoogle-drive%e8%af%a6%e7%bb%86%e8%ae%b0%e5%bd%95/">vps使用rclone挂载Google Drive详细记录</a>进行设置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it \</span><br><span class="line">  --mount type=volume,source=vaultwarden-rclone-data,target=/config/ \</span><br><span class="line">  ttionya/vaultwarden-backup:latest \</span><br><span class="line">  rclone config</span><br></pre></td></tr></table></figure>

<p>然后查看一下配置的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -it \</span><br><span class="line">  --mount type=volume,source=vaultwarden-rclone-data,target=/config/ \</span><br><span class="line">  ttionya/vaultwarden-backup:latest \</span><br><span class="line">  rclone config show</span><br></pre></td></tr></table></figure>

<p><img src="https://images.hxzhouh.com/blog-images/2023/09/3781bb366cac1dcc520970ff606ff536.png" alt="image.png"></p>
<p>这样就好了。</p>
<p>再用docker-compose 启动vaultwarden 以及vaultwarden-backup。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2023/09/c79a80b302ac3bbaff32a97b0798ff81.png" alt="image.png"></p>
<h2 id="cloudflare-反向代理"><a href="#cloudflare-反向代理" class="headerlink" title="cloudflare 反向代理"></a>cloudflare 反向代理</h2><p>vaultwarden 很多功能依赖 https 实现，所以我们需要给vps:8080端口套一个域名 + 证书，</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>为了方便起见，这里直接使用了 cloudflare 代理域名，同时可以前往 SSL&#x2F;TLS -&gt; 源服务器下载其生成的主机证书，用来加密 cloudflare 与主机间的通讯。</p>
<p>将私钥与公钥分别保存在 <code>/etc/nginx/cert/private.key</code> <code>/etc/nginx/cert/public.pem</code>。<br>然后再VPS nginx 里面配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ip-172-31-20-69:~$ cat /etc/nginx/nginx.conf</span><br><span class="line">user www-data;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">include /etc/nginx/modules-enabled/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">	worker_connections 768;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">multi_accept on;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">	sendfile on;</span><br><span class="line">	tcp_nopush on;</span><br><span class="line">	types_hash_max_size 2048;</span><br><span class="line">	include /etc/nginx/mime.types;</span><br><span class="line">	default_type application/octet-stream;</span><br><span class="line">	ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE</span><br><span class="line">	ssl_prefer_server_ciphers on;</span><br><span class="line">	access_log /var/log/nginx/access.log;</span><br><span class="line">	gzip on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	include /etc/nginx/conf.d/*.conf;</span><br><span class="line">	include /etc/nginx/sites-enabled/*;</span><br><span class="line">	server &#123;</span><br><span class="line">    		listen 80;</span><br><span class="line">    		server_name vaultwarden.example.com;</span><br><span class="line">		return 301 https://$host$request_uri;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">ssl配置</span></span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 443 ssl default_server;</span><br><span class="line">		server_name vaultwarden.example.com;</span><br><span class="line">		ssl_certificate /etc/nginx/cert/public.pem;</span><br><span class="line">		ssl_certificate_key /etc/nginx/cert/private.key;</span><br><span class="line">		location / &#123;</span><br><span class="line">        		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        		proxy_set_header Host $http_host;</span><br><span class="line">        		proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        		proxy_set_header Range $http_range;</span><br><span class="line">        		proxy_set_header If-Range $http_if_range;</span><br><span class="line">        		proxy_redirect off;</span><br><span class="line">        		proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="客户端设置"><a href="#客户端设置" class="headerlink" title="客户端设置"></a>客户端设置</h2><p><a href="https://bitwarden.com/">Bitwarden</a> 客户端支持全平台，包括浏览器。所以 可以把所有的密码都保存到vaultwarden 中来</p>
<p>具体使用 ，请参考 <a href="https://blog.tsinbei.com/archives/731/#4-4%E3%80%81%E4%BD%BF%E7%94%A8"># Vaultwarden：安全私密的个人密码管理器</a></p>
<hr>
<p>Enjoy 😄</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
        <tag>密码托管</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用 github copilot搭建 chatgpt-4  服务</title>
    <url>/2024/01/12/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%20github%20copilot%E6%90%AD%E5%BB%BA%20chatgpt-4%20%20%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="如何利用-github-copilot搭建-chatgpt-4-服务"><a href="#如何利用-github-copilot搭建-chatgpt-4-服务" class="headerlink" title="如何利用 github copilot搭建 chatgpt-4  服务"></a>如何利用 github copilot搭建 chatgpt-4  服务</h1><p>Github Copilot 是 GitHub 开发 AI 助手，它可以帮助开发者编写代码。它是一个基于 OpenAI Codex 的 Visual Studio Code 插件，它可以为你提供代码提示、自动补全、自动修复、自动重构等功能。现在 Github Copilot 还支持chat功能，它的底层逻辑基于GPT-4，但是目前仅支持在vs code 中使用， 但是我日常开发环境是Golang，本文将介绍如何利用github copilot搭建chatgpt-4服务，使得我们可以在任何地方使用chatgpt-4。</p>
<span id="more"></span>

<h1 id="本文涉及的开源组建"><a href="#本文涉及的开源组建" class="headerlink" title="本文涉及的开源组建"></a>本文涉及的开源组建</h1><ul>
<li><a href="https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web">ChatGPT-Next-Web</a> One-Click to get a well-designed cross-platform ChatGPT web UI, with GPT3, GPT4 &amp; Gemini Pro support.</li>
<li><a href="https://github.com/aaamoon/copilot-gpt4-service">copilot-gpt4-service</a></li>
<li>一个 aws ec2 服务器， 我们需要再上面运行 copilot-gpt4-service 服务，您也可以选择您喜欢的云服务商。或者在本地运行都可以。</li>
<li>Vercel 一个免费的静态网站托管服务，我们需要再上面部署 ChatGPT-Next-Web 服务</li>
<li>cloudflare 一个免费的cdn服务，我们用来解析域名。</li>
</ul>
<h1 id="获取-GitHub-Copilot-token"><a href="#获取-GitHub-Copilot-token" class="headerlink" title="获取 GitHub Copilot token"></a>获取 GitHub Copilot token</h1><p>请参考这个文档 [GitHub Copilot token](<a href="https://github.com/aaamoon/copilot-gpt4-service/blob/master/README_CN.md#%E8%8E%B7%E5%8F%96-copilot-token%EF%BC%89">https://github.com/aaamoon/copilot-gpt4-service/blob/master/README_CN.md#%E8%8E%B7%E5%8F%96-copilot-token）</a><br>在 mac 电脑上，您可以使用下面的命令获取 token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.sh)&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.hxzhouh.com/blog-images/2024/01/d3343f8fc1b209783fb653e11ff4577a.png"></p>
<p>如图所示。您需要将token 复制到剪切板，后面会用到。</p>
<h1 id="运行-copilot-gpt4-service-服务"><a href="#运行-copilot-gpt4-service-服务" class="headerlink" title="运行 copilot-gpt4-service 服务"></a>运行 copilot-gpt4-service 服务</h1><ol>
<li>copilot-gpt4-service  支持docker部署，官方提供 <a href="https://github.com/aaamoon/copilot-gpt4-service/blob/master/docker-compose.yml">docker-compose</a> 文件，我们只需要修改一下环境变量即可。<br><img src="https://images.hxzhouh.com/blog-images/2024/01/6807404147e2cf24aab940f711af877c.png" alt="image-20240112110203576"></li>
<li>再nginx 上添加一个server<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        listen [::]:443 ssl;</span><br><span class="line">        server_name chat.example.com;</span><br><span class="line"></span><br><span class="line">        ssl_certificate /etc/nginx/cert/public.pem;</span><br><span class="line">        ssl_certificate_key /etc/nginx/cert/private.key;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1:8086/;  # copilot-gpt4-service  addr </span><br><span class="line">                rewrite ^/(.*)$ /$1 break;</span><br><span class="line">                proxy_redirect off;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                proxy_set_header Upgrade-Insecure-Requests 1;</span><br><span class="line">                proxy_set_header X-Forwarded-Proto https;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
别忘记 重新加载nginx 配置文件  </li>
<li>再cloudflare 上添加一个域名解析 chat.example.com  解析到nginx 服务器的ip地址</li>
</ol>
<h1 id="再-Vercel-上部署-ChatGPT-Next-Web-服务"><a href="#再-Vercel-上部署-ChatGPT-Next-Web-服务" class="headerlink" title="再 Vercel 上部署 ChatGPT-Next-Web 服务"></a>再 Vercel 上部署 ChatGPT-Next-Web 服务</h1><p>ChatGPT-Next-Web 支持 一键部署到vercel。 您不用改动任何东西。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/01/53e4d610736d7d7784c66113bfee8cf1.png">部署完成后，您可以在vercel 上添加一个个性化的域名。比如 chatnext.example.com</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>打开浏览器，输入 chatnext.example.com， 点击左下角的设置按钮，选择自定义接口，输入 <a href="https://chat.example.com,/">https://chat.example.com，</a> api token 使用 第一步复制的 GitHub Copilot token， 点击保存，然后就可以开始聊天了。</p>
<p>ps： 我不知道这种做法是不是符合github copilot 的使用协议，但是我这么做只是为了方便我的使用，我不会分享给其他人使用，如果您也部署了 自己的服务，也请不要分享给其他人使用。</p>
<hr>
<p>如果您喜欢我的文章，麻烦给我follow、鼓掌，这对我很有帮助。谢谢！</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>copilot</tag>
        <tag>chatgpt-4</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用汇编分析Go代码</title>
    <url>/2024/01/16/%E5%A6%82%E4%BD%95%E7%94%A8%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90Go%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>今天介绍几个常用的查看 Go 汇编代码、调试 Go 程序的命令和工具，</p>
<span id="more"></span>
<p>比较这两段代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Class <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = &amp;Student&#123;<span class="number">1</span>&#125;</span><br><span class="line">	<span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>的执行效率要高于下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Class <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = Student&#123;<span class="number">1</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> b = &amp;a</span><br><span class="line">	<span class="built_in">println</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且给你讲了一通道理，你好像没法辩赢他。怎么办？<br>直接用一行命令生成汇编代码，马上可以戳穿他，打他的脸。</p>
<h1 id="go-tool-生成汇编"><a href="#go-tool-生成汇编" class="headerlink" title="go tool 生成汇编"></a>go tool 生成汇编</h1><p>其实很简单，有两个命令可以做到：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>

<p>和：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go build main.go &amp;&amp; go tool objdump ./main</span><br></pre></td></tr></table></figure>

<p> 前者是编译，即将源代码编译成 <code>.o</code> 目标文件，并输出汇编代码。<br>后者是反汇编，即从可执行文件反编译成汇编，所以要先用 <code>go build</code> 命令编译出可执行文件。<br>二者不尽相同，但都能看到前面两个示例代码对应的汇编代码是一致的。同事的“谣言”不攻自破，脸都被你打疼了。</p>
<h1 id="找到-runtime-源码"><a href="#找到-runtime-源码" class="headerlink" title="找到 runtime 源码"></a>找到 runtime 源码</h1><p>Go 是一门有 runtime 的语言，什么是 runtime？其实就是一段辅助程序，用户没有写的代码，runtime 替我们写了，比如 Go 调度器的代码。</p>
<p>我们只需要知道用 go 关键字创建 goroutine，就可以疯狂堆业务了。至于 goroutine 是怎么被调度的，根本不需要关心，这些是 runtime 调度器的工作。</p>
<p>那我们自己写的代码如何和 runtime 里的代码对应起来呢？</p>
<p>前面介绍的方法就可以做到，只需要加一个 <code>grep</code> 就可以。</p>
<p>例如，我想知道 go 关键字对应 runtime 里的哪个函数，于是写了一段测试代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="number">1</span>+<span class="number">2</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>go func()&#123;&#125;()</code> 那一行代码在第 4 行，所以，grep 的时候加一个条件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go tool compile -S main.go | grep <span class="string">&quot;main.go:4&quot;</span></span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">go build main.go &amp;&amp; go tool objdump ./main | grep <span class="string">&quot;main.go:4&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://images.hxzhouh.com/blog-images/2024/01/ddda1a97dad5e145c1b83e0cf89bf1f7.png" alt="Pasted image 20240116112336"></p>
<p>马上就能看到 <code>go func()&#123;&#125;()</code> 对应 <code>newproc()</code> 函数，这时再深入研究下 <code>newproc()</code> 函数就大概知道 goroutine 是如何被创建的。</p>
<h1 id="与dlv调试代码"><a href="#与dlv调试代码" class="headerlink" title="与dlv调试代码"></a>与dlv调试代码</h1><p>那有同学问了，有没有其他可以调试 Go、以及和 Go 程序互动的方法呢？其实是有的！这就是我们要介绍的 dlv 调试工具，目前它对调试 Go 的程序支持是最好的。</p>
<p>之前没我怎么研究它，只会一些非常简单的命令，这次学会了几个进阶的指令，威力挺大，也进一步加深了对 Go 的理解。</p>
<p>下面我们带着一个任务来讲解 dlv 如何使用。</p>
<p>我们知道，向一个 nil 的 slice append 元素，不会有任何问题。但是向一个 nil 的 map 插入新元素，马上就会报 panic。这是为什么呢？又是在哪 panic 呢？</p>
<p>首先写出让 map 产生 panic 的示例程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">	m[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着用 <code>go build</code> 命令编译生成可执行文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure>

<p>然后，使用 dlv 进入调试状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dlv <span class="built_in">exec</span> ./main</span><br></pre></td></tr></table></figure>

<p>使用 <code>b</code> 这个命令打断点，有三种方法：</p>
<ol>
<li>b + 地址</li>
<li>b + 代码行数</li>
<li>b + 函数名</li>
</ol>
<p>我们要在对 map 赋值的地方加个断点。位置是第五行，我们在第五行加一个断点。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(dlv) b main.go:5</span><br><span class="line">Breakpoint 1 <span class="built_in">set</span> at 0x104203070 <span class="keyword">for</span> main.main() ./main.go:5</span><br><span class="line">(dlv)</span><br></pre></td></tr></table></figure>

<p>执行 <code>c</code> 命令，直接运行到断点处,执行 <code>disass</code> 命令，可以看到汇编指令：<br><img src="https://images.hxzhouh.com/blog-images/2024/01/108eac7ada0934c2e59e6405c399e3ca.png" alt="Pasted image 20240116165330"></p>
<p>这时使用 <code>si</code> 命令，执行单条指令，多次执行 <code>si</code>，就会执行到 map 赋值函数 &#96;mapassign_fast64:<br><img src="https://images.hxzhouh.com/blog-images/2024/01/df61dc4321789a163071d054e2d40f4b.png" alt="Pasted image 20240116165429"><br><img src="https://images.hxzhouh.com/blog-images/2024/01/c9223b5250b9fdf891adfaeee8493633.png" alt="Pasted image 20240116170428"><br>然后我们在 map_fast64.go上面添加一个断点，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">b /opt/homebrew/Cellar/go/1.21.6/libexec/src/runtime/map_fast64.go:93</span><br></pre></td></tr></table></figure>
<p>这时再用单步命令 <code>s</code>，就会进入判断 h 的值为 nil 的分支，然后执行 <code>panic</code> 函数：<br><img src="https://images.hxzhouh.com/blog-images/2024/01/3c305ca7f39d3b6bd35f5d640d5d7ef1.png" alt="Pasted image 20240116170619"></p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/01/123a0062745492be1a90b5028331faea.png" alt="Pasted image 20240116170945"><br>至此，向 nil 的 map 赋值时，产生 panic 的代码就被我们找到了。接着，按图索骥找到对应 runtime 源码的位置，就可以进一步探索了。</p>
<p>除此之外，我们还可以使用 <code>bt</code> 命令看到调用栈：<br><img src="https://images.hxzhouh.com/blog-images/2024/01/6cd9f5f16328f257c5020ac976a8ba42.png" alt="Pasted image 20240116171018"><br>使用 <code>frame 1</code> 命令可以跳转到相应位置。这里 <code>1</code> 对应图中的 <code>main.go:5</code>，也就是我们前面打断点的地方，是不是非常酷炫。</p>
<p>上面这张图里我们也能清楚地看到，用户 goroutine 其实是被 goexit 函数一路调用过来的。当用户 goroutine 执行完毕后，就会回到 goexit 函数做一些收尾工作。当然，这是题外话了。</p>
<h2 id="另外，用-dlv-也能干第二部分“找到-runtime-源码”的活。-总结今天系统地讲了几招通过命令和工具查看用户代码对应的-runtime-源码或者汇编代码的方法，非常实用。最后再汇总一下：1-go-tool-compile2-go-tool-objdump3-dlv后面，我们会用这些工具继续分析-go语言的源码，比如map-slice-等，有了这些工具，我们的学习过程会事半功倍。"><a href="#另外，用-dlv-也能干第二部分“找到-runtime-源码”的活。-总结今天系统地讲了几招通过命令和工具查看用户代码对应的-runtime-源码或者汇编代码的方法，非常实用。最后再汇总一下：1-go-tool-compile2-go-tool-objdump3-dlv后面，我们会用这些工具继续分析-go语言的源码，比如map-slice-等，有了这些工具，我们的学习过程会事半功倍。" class="headerlink" title="另外，用 dlv 也能干第二部分“找到 runtime 源码”的活。# 总结今天系统地讲了几招通过命令和工具查看用户代码对应的 runtime 源码或者汇编代码的方法，非常实用。最后再汇总一下：1. go tool compile2. go tool objdump3. dlv后面，我们会用这些工具继续分析 go语言的源码，比如map slice 等，有了这些工具，我们的学习过程会事半功倍。 "></a>另外，用 dlv 也能干第二部分“找到 runtime 源码”的活。<br># 总结<br>今天系统地讲了几招通过命令和工具查看用户代码对应的 runtime 源码或者汇编代码的方法，非常实用。最后再汇总一下：<br>1. go tool compile<br>2. go tool objdump<br>3. dlv<br>后面，我们会用这些工具继续分析 go语言的源码，比如map slice 等，有了这些工具，我们的学习过程会事半功倍。 </h2><p>如果你喜欢我的文章，欢迎给我following跟 👏，这对我很有帮助。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>我在13年后如何编写Go的HTTP服务|Grafana Labs</title>
    <url>/2024/02/16/%E6%88%91%E5%9C%A813%E5%B9%B4%E5%90%8E%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99Go%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%20Grafana%20Labs/</url>
    <content><![CDATA[<p>将近六年前，我写了一篇博客文章，概述了<a href="https://pace.dev/blog/2018/05/09/how-I-write-http-services-after-eight-years.html">我如何编写Go的HTTP服务</a>，现在，我再次告诉你，我如何编写HTTP服务。</p>
<span id="more"></span>

<hr>
<blockquote>
<p>Grafana Labs的首席工程师、Go Time播客的主持人Mat Ryer分享了他在编写Go的HTTP服务方面超过十几年的经验。<br>原文链接：<a href="https://grafana.com/blog/2024/02/09/how-i-write-http-services-in-go-after-13-years/">https://grafana.com/blog/2024/02/09/how-i-write-http-services-in-go-after-13-years/</a></p>
</blockquote>
<p>那篇原始的博文引发了一些热议，对我现在的编码方式产生了一些影响。经过多年主持<a href="https://changelog.com/gotime">Go Time播客</a>、在<a href="https://twitter.com/matryer">Twitter</a>上讨论Go、以及在维护这样的代码方面积累了更多的经验后，我觉得是时候进行一次更新了。</p>
<p>（对于那些注意到Go并不完全有13年历史的学究们，我开始在Go <a href="https://go.dev/doc/devel/pre_go1#r59">版本 .r59</a>中编写HTTP服务。）<br>本文涵盖了与使用Go构建服务相关的各种主题，包括：</p>
<ul>
<li>为了最大限度地提高可维护性而构建服务器和处理程序的结构</li>
<li>优化快速启动和优雅关闭的技巧和窍门</li>
<li>如何处理适用于多种类型请求的常见工作</li>
<li>深入探讨如何正确测试您的服务</li>
</ul>
<p>从小型项目到大型项目，这些实践对我来说经受住了时间的考验，我希望它们对你也同样有效。</p>
<h2 id="这篇文章适合谁？"><a href="#这篇文章适合谁？" class="headerlink" title="这篇文章适合谁？"></a>这篇文章适合谁？</h2><p>这篇文章适合你。它适用于计划使用Go编写某种类型的HTTP服务的每个人。如果你正在学习Go，你可能会发现这个有用，因为很多示例都遵循了良好的实践。有经验的Go开发者也可能会学到一些不错的模式。</p>
<p>要使这篇文章对你最有用，你需要了解Go的基础知识。如果你觉得自己还没有掌握，我强烈推荐阅读Chris James的<a href="https://quii.gitbook.io/learn-go-with-tests/">《通过测试学习Go》</a>。如果你想听更多关于Chris的内容，你可以看看我们在Go Time上与Ben Johnson一起讨论的<a href="https://changelog.com/gotime/278">《Go项目的文件和文件夹》</a>的那一集。</p>
<p>如果你熟悉之前版本的这篇文章，本节将对现在的不同之处进行了快速总结。如果你想从头开始阅读，可以跳到下一节。</p>
<ol>
<li>我的处理程序过去是作为服务器结构的方法存在的，但现在我不再这样做了。如果处理程序函数需要某个依赖项，它可以直接作为参数传递。当你只是想测试单个处理程序时，不再会出现意外的依赖项。</li>
<li>我过去更喜欢使用<code>http.HandlerFunc</code>而不是<code>http.Handler</code>，但现在大多数第三方库都优先考虑<code>http.Handler</code>，所以采用它是有道理的。<code>http.HandlerFunc</code>仍然非常有用，但现在大多数东西都表示为接口类型。无论选择哪种方式，都没有太大区别。</li>
<li>我增加了更多关于测试的内容，包括一些“意见”。</li>
<li>我增加了更多的章节，所以建议每个人都进行全面阅读。</li>
</ol>
<h2 id="NewServer构造函数"><a href="#NewServer构造函数" class="headerlink" title="NewServer构造函数"></a><code>NewServer</code>构造函数</h2><p>让我们首先看一下任何Go服务的核心部分：服务器。<code>NewServer</code>函数创建主要的<code>http.Handler</code>。通常我每个服务只有一个<code>NewServer</code>，并且我依赖HTTP路由将流量导向每个服务中的正确处理程序，原因如下：</p>
<ul>
<li><code>NewServer</code>是一个大型的构造函数，它将所有依赖项作为参数传入</li>
<li>如果可能的话，它返回一个<code>http.Handler</code>，对于更复杂的情况可以是一个专用类型</li>
<li>它通常会配置自己的muxer并调用<code>routes.go</code></li>
</ul>
<p>例如，你的代码可能类似于以下示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(logger *Logger, config *Config, commentStore *commentStore, anotherStore *anotherStore)</span></span> http.Handler &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    addRoutes(mux, logger, config, commentStore, anotherStore)</span><br><span class="line">    <span class="keyword">var</span> handler http.Handler = mux</span><br><span class="line">    handler = someMiddleware(handler)</span><br><span class="line">    handler = someMiddleware2(handler)</span><br><span class="line">    handler = someMiddleware3(handler)</span><br><span class="line">    <span class="keyword">return</span> handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不需要所有依赖项的测试用例中，我将<code>nil</code>作为信号传入，表示不会使用它们。</p>
<p><code>NewServer</code>构造函数负责适用于所有端点的顶层HTTP内容，例如CORS、身份验证中间件和日志记录：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler http.Handler = mux</span><br><span class="line">handler = logging.NewLoggingMiddleware(logger, handler)</span><br><span class="line">handler = logging.NewGoogleTraceIDMiddleware(logger, handler)</span><br><span class="line">handler = checkAuthHeaders(handler)</span><br><span class="line"><span class="keyword">return</span> handler</span><br></pre></td></tr></table></figure>

<p>通常，通过使用Go的内置<code>http</code>包将服务器设置起来是一个简单的过程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">srv := NewServer(logger, config, tenantsStore, slackLinkStore, msteamsLinkStore, proxy)</span><br><span class="line">httpServer := &amp;http.Server&#123;</span><br><span class="line">    Addr:    net.JoinHostPort(config.Host, config.Port),</span><br><span class="line">    Handler: srv,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;listening on %s\n&quot;</span>, httpServer.Addr)</span><br><span class="line">    <span class="keyword">if</span> err := httpServer.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;error listening and serving: %s\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &lt;-ctx.Done() <span class="comment">// make a new context for the Shutdown (thanks Alessandro Rosetti)</span></span><br><span class="line">    shutdownCtx := context.Background()</span><br><span class="line">    shutdownCtx, cancel := context.WithTimeout(ctx, <span class="number">10</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="keyword">if</span> err := httpServer.Shutdown(shutdownCtx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;error shutting down http server: %s\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="长参数列表"><a href="#长参数列表" class="headerlink" title="长参数列表"></a>长参数列表</h3><p>在某个点上，可能会达到不适合继续添加依赖项的限制，但大多数情况下，我乐意将依赖项列表作为参数添加进去。虽然有时参数列表可能会变得很长，但我发现这样做仍然是值得的。</p>
<p>是的，这样做可以避免创建一个结构体，但真正的好处是，通过参数，我可以获得稍微更多的类型安全性。我可以创建一个跳过我不喜欢的任何字段的结构体，但函数会强制我必须查找字段，才能知道如何在结构体中设置它们，否则无法调用函数。</p>
<p>如果将其格式化为垂直列表，就不会那么糟糕，就像我在现代前端代码中看到的那样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">srv := NewServer(</span><br><span class="line">    logger,</span><br><span class="line">    config,</span><br><span class="line">    tenantsStore,</span><br><span class="line">    commentsStore,</span><br><span class="line">    conversationService,</span><br><span class="line">    chatGPTService,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="在routes-go中映射整个API接口"><a href="#在routes-go中映射整个API接口" class="headerlink" title="在routes.go中映射整个API接口"></a>在<code>routes.go</code>中映射整个API接口</h2><p>这个文件是服务中列出所有路由的地方。</p>
<p>有时你可能无法避免将它们分散在不同地方，但能够在每个项目的一个文件中查看其API接口是非常有帮助的。</p>
<p>由于<code>NewServer</code>构造函数中有大型的依赖参数列表，您通常会在路由函数中看到相同的列表。但同样，这并不是很糟糕。而且，由于Go的类型检查功能，如果您忘记了某些内容或者顺序不正确，您很快就会发现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addRoutes</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    mux *http.ServeMux,</span></span></span><br><span class="line"><span class="params"><span class="function">    logger *logging.Logger,</span></span></span><br><span class="line"><span class="params"><span class="function">    config Config,</span></span></span><br><span class="line"><span class="params"><span class="function">    tenantsStore *TenantsStore,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentsStore *CommentsStore,</span></span></span><br><span class="line"><span class="params"><span class="function">    conversationService *ConversationService,</span></span></span><br><span class="line"><span class="params"><span class="function">    chatGPTService *ChatGPTService,</span></span></span><br><span class="line"><span class="params"><span class="function">    authProxy *authProxy,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    mux.Handle(<span class="string">&quot;/api/v1/&quot;</span>, handleTenantsGet(logger, tenantsStore))</span><br><span class="line">    mux.Handle(<span class="string">&quot;/oauth2/&quot;</span>, handleOAuth2Proxy(logger, authProxy))</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/healthz&quot;</span>, handleHealthzPlease(logger))</span><br><span class="line">    mux.Handle(<span class="string">&quot;/&quot;</span>, http.NotFoundHandler())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的示例中，<code>addRoutes</code>不返回错误。任何可能引发错误的内容都被移到了<code>run</code>函数中，在到达这一点之前进行了处理，从而使该函数保持简单和扁平。当然，如果任何处理程序由于某种原因返回错误，那么这个函数也可以返回错误。</p>
<h2 id="func-main-只调用run"><a href="#func-main-只调用run" class="headerlink" title="func main()只调用run()"></a><code>func main()</code>只调用<code>run()</code></h2><p><code>run</code>函数类似于<code>main</code>函数，只是它接受操作系统的基本功能作为参数，并返回错误。</p>
<p>我希望<code>func main()</code>是<code>func main() error</code>。或者像在C语言中一样，可以返回退出代码：<code>func main() int</code>。通过拥有一个非常简单的<code>main</code>函数，你也可以实现自己的梦想：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(ctx context.Context, w io.Writer, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    ctx, cancel := signal.NotifyContext(ctx, os.Interrupt)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="keyword">if</span> err := run(ctx, os.Stdout, os.Args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;%s\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>编辑：我过去在<code>main</code>函数中执行了<code>signal.NotifyContext</code>的部分，但是Dave Henderson（和其他几个人）指出<code>cancel</code>函数不会被调用，所以我将其移到了<code>run</code>函数中。</p>
</blockquote>
<p>上面的代码直接调用了<code>run</code>函数，它会创建一个上下文，并在接收到<code>Ctrl+C</code>或等效信号时取消。如果<code>run</code>函数返回<code>nil</code>，则函数会正常退出。如果返回错误，则将其写入<code>stderr</code>并以非零代码退出。如果我正在编写一个需要考虑退出代码的命令行工具，我还可以返回一个整数，这样我就可以编写测试来断言返回的正确代码。</p>
<p>操作系统的基本功能作为参数传递给<code>run</code>。例如，如果它支持标志，则可以传入<code>os.Args</code>，甚至可以传入<code>os.Stdin</code>、<code>os.Stdout</code>和<code>os.Stderr</code>等依赖项。这样，你的程序在测试时会更容易，因为测试代码可以调用<code>run</code>来执行你的程序，通过传递不同的参数来控制参数和所有流。</p>
<p>下表显示了运行函数的输入参数示例：</p>
<table>
<thead>
<tr>
<th><strong>值</strong></th>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>os.Args</code></td>
<td><code>[]string</code></td>
<td>在执行程序时传入的参数。也用于解析标志。</td>
</tr>
<tr>
<td><code>os.Stdin</code></td>
<td><code>io.Reader</code></td>
<td>用于读取输入</td>
</tr>
<tr>
<td><code>os.Stdout</code></td>
<td><code>io.Writer</code></td>
<td>用于写入输出</td>
</tr>
<tr>
<td><code>os.Stderr</code></td>
<td><code>io.Writer</code></td>
<td>用于写入错误日志</td>
</tr>
<tr>
<td><code>os.Getenv</code></td>
<td><code>func(string) string</code></td>
<td>用于读取环境变量</td>
</tr>
<tr>
<td><code>os.Getwd</code></td>
<td><code>func() (string, error)</code></td>
<td>获取工作目录</td>
</tr>
</tbody></table>
<p>如果避免使用全局作用域数据，通常可以在更多地方使用<code>t.Parallel()</code>，以加快测试套件的速度。一切都是自包含的，因此对<code>run</code>的多次调用不会相互干扰。</p>
<p>通常，我最终会得到以下<code>run</code>函数的签名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">    args []<span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    getenv <span class="keyword">func</span>(<span class="type">string</span>)</span></span> <span class="type">string</span>,</span><br><span class="line">    stdin io.Reader,</span><br><span class="line">    stdout, stderr io.Writer,</span><br><span class="line">) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>现在我们进入了<code>run</code>函数，可以回到正常的Go代码编写，可以像没有人在乎一样返回错误。我们gopher们喜欢返回错误，我们越早承认这一点，那些在互联网上的人就越早能赢得胜利并消失。</p>
<h3 id="优雅关闭"><a href="#优雅关闭" class="headerlink" title="优雅关闭"></a>优雅关闭</h3><p>如果你运行大量的测试，当每个测试完成时，让你的程序停止是很重要的。（或者你可能决定保持一个实例运行所有的测试，但这取决于你。）</p>
<p>上下文被传递。如果终止信号进入程序，它将被取消，因此在每个级别都尊重它是很重要的。至少，将其传递给你的依赖项。最好，检查任何长时间运行或循环代码中的<code>Err()</code>方法，如果返回错误，则停止正在进行的操作并将其返回。这将有助于服务器优雅地关闭。如果你启动了其他的goroutine，你也可以使用上下文来决定是否停止它们。</p>
<h3 id="控制环境"><a href="#控制环境" class="headerlink" title="控制环境"></a>控制环境</h3><p><code>args</code>和<code>getenv</code>参数为我们提供了一些控制程序行为的方法，通过标志和环境变量。标志使用args进行处理（只要你不使用全局空间版本的flags，并在<code>run</code>内部使用<code>flags.NewFlagSet</code>），因此我们可以使用不同的值调用run：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">args := []<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;myapp&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--out&quot;</span>, outFile,</span><br><span class="line">    <span class="string">&quot;--fmt&quot;</span>, <span class="string">&quot;markdown&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> run(ctx, args, etc.)</span><br></pre></td></tr></table></figure>

<p>如果你的程序使用环境变量而不是标志（甚至两者都使用），那么<code>getenv</code>函数允许你插入不同的值，而不需要更改实际的环境。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">getenv := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> key &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;MYAPP_FORMAT&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;markdown&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;MYAPP_TIMEOUT&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;5s&quot;</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> run(ctx, args, getenv)</span><br></pre></td></tr></table></figure>

<p>对我来说，使用这种<code>getenv</code>技术比使用<code>t.SetEnv</code>控制环境变量更好，因为你可以通过调用<code>t.Parallel()</code>继续并行运行测试，而<code>t.SetEnv</code>不允许这样做。</p>
<p>当然，当你在编写命令行工具时，这种技术更加有用，因为你经常希望以不同的设置运行程序，以测试其所有行为。</p>
<p>在<code>main</code>函数中，我们可以传入真正的东西：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="keyword">if</span> err := run(ctx, os.Getenv, os.Stderr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Fprintf(os.Stderr, <span class="string">&quot;%s\n&quot;</span>, err)</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Maker函数返回处理程序"><a href="#使用Maker函数返回处理程序" class="headerlink" title="使用Maker函数返回处理程序"></a>使用Maker函数返回处理程序</h2><p>我的处理程序函数不直接实现<code>http.Handler</code>或<code>http.HandlerFunc</code>，它们返回它们。具体来说，它们返回<code>http.Handler</code>类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// handleSomething处理那些你经常听到的网络请求。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSomething</span><span class="params">(logger *Logger)</span></span> http.Handler &#123;</span><br><span class="line">    thing := prepareThing()</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 使用thing处理请求</span></span><br><span class="line">        logger.Info(r.Context(), <span class="string">&quot;msg&quot;</span>, <span class="string">&quot;handleSomething&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式为每个处理程序提供了独立的闭包环境。你可以在这个空间中进行初始化工作，并且当调用处理程序时，数据将可用。</p>
<p>确保只读取共享数据。如果处理程序修改任何内容，你将需要一个互斥锁或其他东西来保护它。</p>
<p>通常情况下，不建议在这里存储程序状态。在大多数云环境中，你不能保证代码会持续运行很长时间。根据你的生产环境，服务器通常会关闭以节省资源，或者仅仅因为其他原因崩溃。你的服务可能会以不可预测的方式在许多实例之间负载均衡。在这种情况下，每个实例只能访问自己的本地数据。因此，在真实项目中最好使用数据库或其他存储API来持久化数据。</p>
<h2 id="在一个地方处理解码-编码"><a href="#在一个地方处理解码-编码" class="headerlink" title="在一个地方处理解码&#x2F;编码"></a>在一个地方处理解码&#x2F;编码</h2><p>每个服务都需要解码请求体和编码响应体。这是一个经得起时间考验的合理抽象。</p>
<p>我通常会有一对辅助函数叫做encode和decode。使用泛型的示例版本向您展示，实际上您只是在包装几行基本代码，我通常不会这样做，但当您需要为所有API进行更改时，这将变得非常有用。（例如，假设您的新老板还停留在上世纪90年代，并且他们想要添加XML支持。）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encode</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(w http.ResponseWriter, r *http.Request, status <span class="type">int</span>, v T)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">    w.WriteHeader(status)</span><br><span class="line">    <span class="keyword">if</span> err := json.NewEncoder(w).Encode(v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;encode json: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(r *http.Request)</span></span> (T, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> v T</span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v, fmt.Errorf(<span class="string">&quot;decode json: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有趣的是，编译器能够从参数中推断出类型，因此在调用encode时不需要传递类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := encode(w, r, http.StatusOK, obj)</span><br></pre></td></tr></table></figure>

<p>但由于decode中的返回参数，您需要指定您期望的类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">decoded, err := decode[CreateSomethingRequest](r)</span><br></pre></td></tr></table></figure>

<p>我尽量不过度使用这些函数，但过去我对一个简单的验证接口非常满意，它很好地适应了decode函数。</p>
<h2 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h2><p>我喜欢简单的接口。实际上，我非常喜欢它们。单方法接口很容易实现。所以当涉及到验证对象时，我喜欢这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Validator是一个可以进行验证的对象。</span></span><br><span class="line"><span class="keyword">type</span> Validator <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Valid检查对象并返回任何问题。</span></span><br><span class="line">    <span class="comment">// 如果len(problems) == 0，则对象有效。</span></span><br><span class="line">    Valid(ctx context.Context) (problems <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Valid</code>方法接受一个上下文（这是可选的，但在过去对我很有用），并返回一个映射。如果字段有问题，它的名称将用作键，并将问题的人类可读解释设置为值。</p>
<p>该方法可以执行任何需要验证结构体字段的操作。例如，它可以检查以下内容：</p>
<ul>
<li>必填字段不能为空</li>
<li>具有特定格式（如电子邮件）的字符串是否正确</li>
<li>数字是否在可接受范围内</li>
</ul>
<p>如果您需要执行更复杂的操作，比如在数据库中检查字段，那么应该在其他地方进行；它可能太重要，以至于不能被视为快速验证检查的一部分，并且您不会期望在这样的函数中找到这种类型的内容，因此它可能很容易被隐藏起来。</p>
<p>然后，我使用类型断言来判断对象是否实现了该接口。或者，在泛型世界中，我可能选择更明确地说明正在发生的事情，通过更改decode方法来坚持要求实现该接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decodeValid</span>[<span class="title">T</span> <span class="title">Validator</span>]<span class="params">(r *http.Request)</span></span> (T, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> v T</span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v, <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;decode json: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> problems := v.Valid(r.Context()); <span class="built_in">len</span>(problems) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v, problems, fmt.Errorf(<span class="string">&quot;invalid %T: %d problems&quot;</span>, v, <span class="built_in">len</span>(problems))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此代码中，<code>T</code>必须实现<code>Validator</code>接口，并且<code>Valid</code>方法必须返回零个问题，以便将对象视为成功解码。</p>
<p>对于问题，返回<code>nil</code>是安全的，因为我们将检查<code>len(problems)</code>，对于<code>nil</code>映射，它将为<code>0</code>，但不会引发恐慌。</p>
<h2 id="适配器模式用于中间件"><a href="#适配器模式用于中间件" class="headerlink" title="适配器模式用于中间件"></a>适配器模式用于中间件</h2><p>中间件函数接受一个<code>http.Handler</code>并返回一个新的<code>http.Handler</code>，可以在调用原始处理程序之前和&#x2F;或之后运行代码，或者甚至可以决定根本不调用原始处理程序。</p>
<p>一个示例是检查用户是否为管理员：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adminOnly</span><span class="params">(h http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !currentUser(r).IsAdmin &#123;</span><br><span class="line">            http.NotFound(w, r)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        h(w, r)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理程序内部的逻辑可以选择是否调用原始处理程序。在上面的示例中，如果<code>IsAdmin</code>为false，则处理程序将返回<code>HTTP 404 Not Found</code>并返回（或中止）；请注意，不调用<code>h</code>处理程序。如果<code>IsAdmin</code>为true，则允许用户访问路由，因此将执行传递给<code>h</code>处理程序。</p>
<p>通常，我将中间件列在<code>routes.go</code>文件中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> app</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addRoutes</span><span class="params">(mux *http.ServeMux)</span></span> &#123;</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/api/&quot;</span>, handleAPI())</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/about&quot;</span>, handleAbout())</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/&quot;</span>, handleIndex())</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/admin&quot;</span>, adminOnly(handleAdminIndex()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看端点映射，这使得非常清晰，可以知道应用了哪些中间件。如果列表开始变得更长，请尝试将它们分成多行 - 我知道，我知道，但您会习惯的。</p>
<h2 id="有时返回中间件"><a href="#有时返回中间件" class="headerlink" title="有时返回中间件"></a>有时返回中间件</h2><p>上述方法对于简单情况非常好，但如果中间件需要许多依赖项（一个记录器，一个数据库，一些API客户端，一个包含“Never Gonna Give You Up”数据的字节数组，供以后的恶作剧使用），那么我可能会编写一个返回中间件函数的函数。</p>
<p>问题是，您最终会得到这样的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">mux.Handle(<span class="string">&quot;/route1&quot;</span>, middleware(logger, db, slackClient, rroll []<span class="type">byte</span>, handleSomething(handlerSpecificDeps))</span><br><span class="line">mux.Handle(<span class="string">&quot;/route2&quot;</span>, middleware(logger, db, slackClient, rroll []<span class="type">byte</span>, handleSomething2(handlerSpecificDeps))</span><br><span class="line">mux.Handle(<span class="string">&quot;/route3&quot;</span>, middleware(logger, db, slackClient, rroll []<span class="type">byte</span>, handleSomething3(handlerSpecificDeps))</span><br><span class="line">mux.Handle(<span class="string">&quot;/route4&quot;</span>, middleware(logger, db, slackClient, rroll []<span class="type">byte</span>, handleSomething4(handlerSpecificDeps))</span><br></pre></td></tr></table></figure>

<p>这样会使代码膨胀，并且实际上并没有提供任何有用的东西。相反，我会让中间件函数接受依赖项，但返回一个只接受下一个处理程序的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMiddleware</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    logger Logger,</span></span></span><br><span class="line"><span class="params"><span class="function">    db *DB,</span></span></span><br><span class="line"><span class="params"><span class="function">    slackClient *slack.Client,</span></span></span><br><span class="line"><span class="params"><span class="function">    rroll []<span class="type">byte</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(h http.Handler)</span></span> http.Handler</span><br></pre></td></tr></table></figure>

<p>返回类型<code>func(h http.Handler) http.Handler</code>是我们在设置路由时将调用的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">middleware := newMiddleware(logger, db, slackClient, rroll)</span><br><span class="line">mux.Handle(<span class="string">&quot;/route1&quot;</span>, middleware(handleSomething(handlerSpecificDeps))</span><br><span class="line">mux.Handle(<span class="string">&quot;/route2&quot;</span>, middleware(handleSomething2(handlerSpecificDeps))</span><br><span class="line">mux.Handle(<span class="string">&quot;/route3&quot;</span>, middleware(handleSomething3(handlerSpecificDeps))</span><br><span class="line">mux.Handle(<span class="string">&quot;/route4&quot;</span>, middleware(handleSomething4(handlerSpecificDeps))</span><br></pre></td></tr></table></figure>

<p>有些人喜欢（但我不喜欢）以这种方式正式化函数类型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// middleware是一个包装http.Handlers的函数</span></span><br><span class="line"><span class="comment">// 在执行h处理程序之前和之后提供功能</span></span><br><span class="line"><span class="keyword">type</span> middleware <span class="function"><span class="keyword">func</span><span class="params">(h http.Handler)</span></span> http.Handler</span><br></pre></td></tr></table></figure>

<p>这样也可以。如果您喜欢，请这样做。我不会在您的工作周围等待，然后在您身边走来走去，用一种令人生畏的方式搂着您的肩膀，问您是否对自己感到满意。</p>
<p>我不这样做的原因是因为它增加了额外的间接性。当您查看上面的<code>newMiddleware</code>函数的签名时，很明显正在发生什么。如果返回类型是<code>middleware</code>，则需要额外的工作。实际上，我优化的是阅读代码，而不是编写代码。</p>
<h3 id="隐藏请求-响应类型的机会"><a href="#隐藏请求-响应类型的机会" class="headerlink" title="隐藏请求&#x2F;响应类型的机会"></a>隐藏请求&#x2F;响应类型的机会</h3><p>如果一个端点有自己的请求和响应类型，通常它们只对该特定处理程序有用。</p>
<p>如果是这样的情况，您可以在函数内部定义它们。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleSomething</span><span class="params">()</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">type</span> request <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="type">string</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">type</span> response <span class="keyword">struct</span> &#123;</span><br><span class="line">        Greeting <span class="type">string</span> <span class="string">`json:&quot;greeting&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以使全局空间保持清晰，并防止其他处理程序依赖于您可能不认为是稳定的数据。</p>
<p>当您的测试代码需要使用相同的类型时，有时会遇到这种方法的摩擦。公平地说，这是一个将它们拆分出来的好理由，如果您想这样做的话。</p>
<h2 id="在测试中使用内联请求-响应类型进行额外的故事叙述"><a href="#在测试中使用内联请求-响应类型进行额外的故事叙述" class="headerlink" title="在测试中使用内联请求&#x2F;响应类型进行额外的故事叙述"></a>在测试中使用内联请求&#x2F;响应类型进行额外的故事叙述</h2><p>如果您的请求&#x2F;响应类型在处理程序内部隐藏，您可以在测试代码中声明新类型。</p>
<p>这是一个机会，可以向未来需要理解您的代码的人讲述一些故事。</p>
<p>例如，假设我们的代码中有一个<code>Person</code>类型，并且我们在许多端点上重复使用它。如果我们有一个<code>/greet</code>端点，我们可能只关心他们的姓名，所以我们可以在测试代码中表达这一点：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGreet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    is := is.New(t)</span><br><span class="line"></span><br><span class="line">    person := <span class="keyword">struct</span> &#123;</span><br><span class="line">        Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        Name: <span class="string">&quot;Mat Ryer&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    err := json.NewEncoder(&amp;buf).Encode(person)</span><br><span class="line">    is.NoErr(err)</span><br><span class="line"></span><br><span class="line">    req, err := http.NewRequest(http.MethodPost, <span class="string">&quot;/greet&quot;</span>, &amp;buf)</span><br><span class="line">    is.NoErr(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... more test code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个测试中可以明确看出，我们只关心<code>Name</code>字段。</p>
<h2 id="使用sync-Once延迟设置"><a href="#使用sync-Once延迟设置" class="headerlink" title="使用sync.Once延迟设置"></a>使用<code>sync.Once</code>延迟设置</h2><p>如果在准备处理程序时需要执行任何昂贵的操作，我会将其推迟到首次调用该处理程序时。</p>
<p>这提高了应用程序的启动时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleTemplate</span><span class="params">(files <span class="type">string</span>...)</span></span> http.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        init   sync.Once</span><br><span class="line">        tpl    *template.Template</span><br><span class="line">        tplerr <span class="type">error</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        init.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            tpl, tplerr = template.ParseFiles(files...)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tplerr != <span class="literal">nil</span> &#123;</span><br><span class="line">            http.Error(w, tplerr.Error(), http.StatusInternalServerError)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use tpl</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sync.Once</code>确保代码只执行一次，并且其他调用（其他人发起相同请求）将阻塞，直到完成。</p>
<ul>
<li>错误检查位于<code>init</code>函数之外，因此如果出现问题，我们仍然会显示错误，并且不会在日志中丢失它。</li>
<li>如果不调用处理程序，则不会执行昂贵的工作 - 这可能在很大程度上有益，这取决于代码的部署方式。</li>
</ul>
<p>请记住，通过这样做，您将初始化时间从启动时移动到运行时（首次访问端点时）。我经常使用Google App Engine，所以对我来说这是有意义的，但您的情况可能不同，因此值得考虑何时何地以这种方式使用<code>sync.Once</code>。</p>
<h2 id="为可测试性设计"><a href="#为可测试性设计" class="headerlink" title="为可测试性设计"></a>为可测试性设计</h2><p>这些模式的发展部分是因为它们在测试代码中非常容易测试代码。<code>run</code>函数是从测试代码中直接运行程序的简单方法。</p>
<p>在Go中，有很多测试选项，它们不是关于对与错的问题，而是关于：</p>
<ul>
<li>查看测试代码是否可以轻松理解您的程序在做什么？</li>
<li>您是否可以轻松更改代码而不必担心破坏其他部分？</li>
<li>如果所有测试都通过，您是否可以推送到生产环境，还是还需要涵盖更多内容？</li>
</ul>
<h3 id="单元测试的单元是什么？"><a href="#单元测试的单元是什么？" class="headerlink" title="单元测试的单元是什么？"></a>单元测试的单元是什么？</h3><p>遵循这些模式，处理程序本身也是可以独立测试的，但我通常不这样做，我将在下面解释为什么。您必须考虑对于您的项目来说什么是最佳方法。</p>
<p>要仅测试处理程序，您可以：</p>
<ol>
<li>调用函数以获取<code>http.Handler</code> - 您必须传递所有所需的依赖项（这是一项功能）。</li>
<li>使用真实的<code>http.Request</code>和来自<code>httptest</code>包的<code>ResponseRecorder</code>调用<code>ServeHTTP</code>方法（请参阅<a href="https://pkg.go.dev/net/http/httptest#ResponseRecorder">https://pkg.go.dev/net/http/httptest#ResponseRecorder</a>）。</li>
<li>对响应进行断言（检查状态码，解码主体并确保正确，检查任何重要的标头等）。</li>
</ol>
<p>如果这样做，您将跳过任何像身份验证这样的中间件，直接进入处理程序代码。如果有特定的复杂性需要构建一些测试支持，这是很好的。然而，当您的测试代码像真实用户一样调用API时，会有一个优势。在这个层面上，我更倾向于端到端测试，而不是单元测试所有内部部件。</p>
<p>我宁愿调用<code>run</code>函数以尽可能接近它在生产环境中运行的方式运行整个程序。这将解析任何参数，连接到任何依赖项，迁移数据库，无论它在野外做什么，最终启动服务器。然后，当我从测试代码中访问API时，我会穿过所有层，并与真实数据库交互。我还会同时测试<code>routes.go</code>。</p>
<p>我发现，通过这种方法，我能够更早地发现更多的问题，并且可以避免特定地测试样板代码。它还减少了测试中的重复。如果我勤奋地测试每一层，我可能会以稍微不同的方式多次说相同的事情。您必须维护所有这些内容，因此如果您想要更改某些内容，更新一个函数和三个测试并不感觉非常有效率。通过端到端测试，您只需一个主要测试集，描述用户与系统之间的交互。</p>
<p>在其中适当的情况下，我仍然在其中使用单元测试。如果我使用TDD（我经常这样做），那么我通常已经完成了很多测试，我很乐意维护它们。但是，如果这些测试在重复与端到端测试中相同的内容，我将返回并删除它们。</p>
<p>这个决定将取决于很多因素，从周围人的意见到项目的复杂性，因此像本文中的所有建议一样，如果这对您来说行不通，不要强求。</p>
<h3 id="使用run函数进行测试"><a href="#使用run函数进行测试" class="headerlink" title="使用run函数进行测试"></a>使用<code>run</code>函数进行测试</h3><p>我喜欢在每个测试中调用<code>run</code>函数。每个测试都会获得一个独立的程序实例。对于每个测试，我可以传递不同的参数、标志值、标准输入和输出管道，甚至环境变量。</p>
<p>由于<code>run</code>函数接受一个<code>context.Context</code>，而且我们的所有代码都遵守上下文（对吧，大家都遵守上下文，对吧？），我们可以通过调用<code>context.WithCancel</code>来获得一个取消函数。通过延迟执行<code>cancel</code>函数，当测试函数返回时（即测试运行结束时），上下文将被取消，程序将优雅地关闭。在Go 1.14中，他们添加了<code>t.Cleanup</code>方法，它是对使用<code>defer</code>关键字的替代方法，如果你想了解更多关于为什么要这样做的原因，请查看这个问题：<a href="https://github.com/golang/go/issues/37333">https://github.com/golang/go/issues/37333</a>。</p>
<p>这一切只需要很少的代码就能实现。当然，你还必须一直检查<code>ctx.Err</code>或<code>ctx.Done</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    t.Cleanup(cancel)</span><br><span class="line">    <span class="keyword">go</span> run(ctx) <span class="comment">// 测试代码放在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="等待就绪状态"><a href="#等待就绪状态" class="headerlink" title="等待就绪状态"></a>等待就绪状态</h3><p>由于<code>run</code>函数在一个goroutine中执行，我们不知道它何时准备就绪。如果我们要像真正的用户一样开始使用API，我们需要知道何时它准备就绪。</p>
<p>我们可以设置一种信号就绪的方式，比如一个通道之类的东西，但我更喜欢在服务器上运行一个<code>/healthz</code>或<code>/readyz</code>端点。正如我年迈的祖母常说的那样，布丁的真正好坏在于实际的HTTP请求（她当时就很先进）。</p>
<p>这是一个例子，我们努力使代码更具可测试性，也让我们了解到用户的需求。他们可能也想知道服务是否已经就绪，那为什么不提供一种官方的方式来获取这个信息呢？</p>
<p>要等待服务就绪，你可以编写一个循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// waitForReady调用指定的端点，直到收到200响应，或者上下文被取消，或者超时达到。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitForReady</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">    timeout time.Duration,</span></span></span><br><span class="line"><span class="params"><span class="function">    endpoint <span class="type">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    client := http.Client&#123;&#125;</span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        req, err := http.NewRequestWithContext(</span><br><span class="line">            ctx,</span><br><span class="line">            http.MethodGet,</span><br><span class="line">            endpoint,</span><br><span class="line">            <span class="literal">nil</span>,</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create request: %w&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        resp, err := client.Do(req)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Error making request: %s\n&quot;</span>, err.Error())</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> resp.StatusCode == http.StatusOK &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Endpoint is ready!&quot;</span>)</span><br><span class="line">            resp.Body.Close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        resp.Body.Close()</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> time.Since(startTime) &gt;= timeout &#123;</span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;timeout reached while waiting for endpoint&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次检查之间等待一小段时间</span></span><br><span class="line">            time.Sleep(<span class="number">250</span> * time.Millisecond)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="将所有这些付诸实践"><a href="#将所有这些付诸实践" class="headerlink" title="将所有这些付诸实践"></a>将所有这些付诸实践</h2><p>使用这些技术来构建简单的API仍然是我最喜欢的方法。它符合我追求的目标，即通过易于阅读、易于通过复制模式扩展、易于新人使用、易于修改而无需担心、明确地不使用任何魔法来实现可维护性的卓越代码。即使在我使用像我们自己的<a href="https://github.com/pacedotdev/oto">Oto包</a>这样的代码生成框架来根据我自定义的模板为我编写样板代码的情况下，这一点仍然成立。</p>
<p>在更大的项目或较大的组织中，特别是像Grafana Labs这样的组织，你经常会遇到影响这些决策的特定技术选择。gRPC就是一个很好的例子。在已经形成了一些模式和经验、或者其他广泛使用的工具或抽象存在的情况下，你经常会发现自己做出实用主义的选择，跟随潮流，尽管我怀疑（或者说希望？）这篇文章对你仍然有一些有用的东西。</p>
<p>我的日常工作是与Grafana Labs内部的一组才华横溢的人员一起构建新的<a href="https://grafana.com/products/cloud/irm/">Grafana IRM</a>套件。本文讨论的模式帮助我们交付可靠的工具。听到你在屏幕前大喊“告诉我更多关于这些伟大的工具的事情！”。</p>
<p>大多数人使用Grafana来可视化他们的系统运行情况，并且通过Grafana Alerting在指标超出可接受范围时收到通知。有了Grafana OnCall，你的计划和升级规则将自动化处理出现问题时与正确人员联系的过程。</p>
<p>Grafana Incident让你管理那些不可避免的全员参与时刻，这对我们大多数人来说都太熟悉了。它为你创建Zoom会议室，一个专用的Slack频道，并跟踪事件的时间线，让你专注于解决问题。在Slack中，你在频道中以机器人表情符号作为反应标记的任何内容都将添加到时间线中。这样，在进行总结或事后审查讨论时，很容易收集关键事件。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>翻译</tag>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>每个人都应该考虑采用的 Linux 内核安全可调</title>
    <url>/2024/03/15/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E9%87%87%E7%94%A8%E7%9A%84%20Linux%20%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E5%8F%AF%E8%B0%83/</url>
    <content><![CDATA[<h1 id="每个人都应该考虑采用的Linux内核安全可调"><a href="#每个人都应该考虑采用的Linux内核安全可调" class="headerlink" title="每个人都应该考虑采用的Linux内核安全可调"></a>每个人都应该考虑采用的Linux内核安全可调</h1><p>原文连接：<a href="https://blog.cloudflare.com/linux-kernel-hardening/">https://blog.cloudflare.com/linux-kernel-hardening/</a></p>
<p>本文介绍了一些Linux内核的功能，这些功能帮助我们保持生产系统更安全。我们将深入探讨它们的工作原理以及为什么您也应该考虑启用它们。</p>
<span id="more"></span>

<p><img src="https://images.hxzhouh.com/blog-images/2024/03/b6bf3148716461c32a9f1e5447cb2c62.png" alt="Linux内核安全调整：每个人都应该考虑采用的方法"></p>
<p>Linux内核是许多现代生产系统的核心。它决定了何时允许运行任何代码以及哪些程序&#x2F;用户可以访问哪些资源。它管理内存，调解对硬件的访问，并在程序运行时的幕后代表程序执行大部分工作。由于内核始终参与任何代码执行，它处于最佳位置来保护系统免受恶意程序的侵害，执行所需的系统安全策略，并为更安全的生产环境提供安全功能。</p>
<p>在本文中，我们将回顾Cloudflare在Linux内核安全配置方面的一些使用方法，以及它们如何帮助阻止或减少潜在的系统妥协。</p>
<h2 id="安全启动"><a href="#安全启动" class="headerlink" title="安全启动"></a>安全启动</h2><p>当机器（无论是笔记本还是服务器）启动时，它经历了几个引导阶段：</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/a960262885fbf648dbdc2bd800cde2ca.png" alt="image3-17"></p>
<p>在安全启动架构中，上图中的每个阶段在传递执行权之前都会验证下一个阶段的完整性，从而形成所谓的安全启动链。这样，“可信度”就扩展到引导链中的每个组件，因为如果我们验证了特定阶段的代码完整性，我们可以相信该代码可以验证下一个阶段的完整性。</p>
<p>我们之前已经介绍过Cloudflare在引导过程的初始阶段实现安全启动的方法。在本文中，我们将重点介绍Linux内核。</p>
<p>安全启动是任何操作系统安全机制的基石。Linux内核是操作系统安全配置和策略的主要执行者，因此我们必须确保Linux内核本身没有被篡改。在我们之前关于安全启动的文章中，我们展示了如何使用UEFI Secure Boot来确保Linux内核的完整性。</p>
<p>但接下来会发生什么呢？内核执行后，它可能尝试加载其他驱动程序，或者在Linux世界中称为内核模块。内核模块加载不仅限于引导过程。模块可以在运行时的任何时候加载——当插入新设备并需要驱动程序时，需要对网络堆栈进行一些附加扩展（例如，用于细粒度防火墙规则），或者只是由系统管理员手动加载。</p>
<p>然而，不受控制的内核模块加载可能对系统完整性构成重大风险。与常规程序不同，内核模块是直接注入并在Linux内核地址空间中直接执行的代码片段。在不同的内核模块和核心内核子系统中，代码和数据之间没有分离，因此一切都可以访问一切。这意味着一个恶意的内核模块可以完全使操作系统的可信度失效，并使安全启动变得无效。例如，考虑一个简单的Debian 12（Bookworm安装），但启用了SELinux配置和强制执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ lsb_release --all</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Debian</span><br><span class="line">Description:	Debian GNU/Linux 12 (bookworm)</span><br><span class="line">Release:	12</span><br><span class="line">Codename:	bookworm</span><br><span class="line">ignat@dev:~$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux dev 6.1.0-18-cloud-amd64 <span class="comment">#1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 GNU/Linux</span></span><br><span class="line">ignat@dev:~$ sudo getenforce</span><br><span class="line">Enforcing</span><br></pre></td></tr></table></figure>

<p>现在我们需要进行一些研究。首先，我们看到我们正在运行6.1.76 Linux内核。如果我们探索源代码，我们会发现<a href="https://elixir.bootlin.com/linux/v6.1.76/source/security/selinux/hooks.c#L107">在内核内部，SELinux配置存储在一个单例结构中</a>，该结构<a href="https://elixir.bootlin.com/linux/v6.1.76/source/security/selinux/include/security.h#L92">定义如下</a>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">selinux_state</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY_SELINUX_DISABLE</span></span><br><span class="line">	<span class="type">bool</span> disabled;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY_SELINUX_DEVELOP</span></span><br><span class="line">	<span class="type">bool</span> enforcing;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">bool</span> checkreqprot;</span><br><span class="line">	<span class="type">bool</span> initialized;</span><br><span class="line">	<span class="type">bool</span> policycap[__POLICYDB_CAP_MAX];</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">status_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">status_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">selinux_avc</span> *<span class="title">avc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">selinux_policy</span> __<span class="title">rcu</span> *<span class="title">policy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">policy_mutex</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，如果内核配置启用了<code>CONFIG_SECURITY_SELINUX_DEVELOP</code>，则该结构将具有一个名为<code>enforcing</code>的布尔变量，该变量控制SELinux在运行时的强制执行状态。这正是上面的<code>$ sudo getenforce</code>命令返回的内容。我们可以再次检查Debian内核确实已启用该配置选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep CONFIG_SECURITY_SELINUX_DEVELOP /boot/config-`<span class="built_in">uname</span> -r` CONFIG_SECURITY_SELINUX_DEVELOP=y</span><br></pre></td></tr></table></figure>

<p>很好！现在我们在内核中有一个变量，负责某种安全执行，我们可以尝试攻击它。但有一个问题是<code>__randomize_layout</code>属性：由于我们的Debian内核实际上没有设置<code>CONFIG_SECURITY_SELINUX_DISABLE</code>，因此<code>enforcing</code>实际上将是结构体的第一个成员。因此，如果我们知道结构体的位置，我们立即就知道了<code>enforcing</code>标志的位置。使用<code>__randomize_layout</code>，在内核编译期间，编译器可能会将成员放置在结构体的任意位置，因此创建通用的漏洞利用变得更加困难。但是，在内核中任意结构体随机化<a href="https://elixir.bootlin.com/linux/v6.1.76/source/security/Kconfig.hardening#L301">可能会引入性能影响</a>，因此通常被禁用，并且对于Debian内核而言，它是被禁用的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep RANDSTRUCT /boot/config-`<span class="built_in">uname</span> -r` CONFIG_RANDSTRUCT_NONE=y</span><br></pre></td></tr></table></figure>

<p>我们还可以使用<a href="https://git.kernel.org/pub/scm/devel/pahole/pahole.git/">pahole工具</a>和内核调试符号（如果可用）或（在现代内核上，如果启用）内核<a href="https://www.kernel.org/doc/html/next/bpf/btf.html">BTF</a>信息来确认<code>enforcing</code>标志的编译位置。我们将使用后者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ pahole -C selinux_state /sys/kernel/btf/vmlinux</span><br><span class="line">struct selinux_state &#123;</span><br><span class="line">	bool                       enforcing;            /*     0     1 */</span><br><span class="line">	bool                       checkreqprot;         /*     1     1 */</span><br><span class="line">	bool                       initialized;          /*     2     1 */</span><br><span class="line">	bool                       policycap[8];         /*     3     8 */</span><br><span class="line"></span><br><span class="line">	/* XXX 5 bytes hole, try to pack */</span><br><span class="line"></span><br><span class="line">	struct page *              status_page;          /*    16     8 */</span><br><span class="line">	struct mutex               status_lock;          /*    24    32 */</span><br><span class="line">	struct selinux_avc *       avc;                  /*    56     8 */</span><br><span class="line">	/* --- cacheline 1 boundary (64 bytes) --- */</span><br><span class="line">	struct selinux_policy *    policy;               /*    64     8 */</span><br><span class="line">	struct mutex               policy_mutex;         /*    72    32 */</span><br><span class="line"></span><br><span class="line">	/* size: 104, cachelines: 2, members: 9 */</span><br><span class="line">	/* <span class="built_in">sum</span> members: 99, holes: 1, <span class="built_in">sum</span> holes: 5 */</span><br><span class="line">	/* last cacheline: 40 bytes */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>因此，<code>enforcing</code>确实位于结构体的开头，我们甚至不需要成为特权用户即可确认这一点。</p>
<p>太棒了！我们只需要内核内的<code>selinux_state</code>变量的运行时地址：<br>（shell&#x2F;bash）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ sudo grep selinux_state /proc/kallsyms</span><br><span class="line">ffffffffbc3bcae0 B selinux_state</span><br></pre></td></tr></table></figure>

<p>有了所有这些信息，我们可以编写一个几乎完全符合教科书的简单内核模块来操纵SELinux状态：</p>
<p>Mymod.c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mod_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> *selinux_enforce = (<span class="type">bool</span> *)<span class="number">0xffffffffbc3bcae0</span>;</span><br><span class="line">	*selinux_enforce = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mod_fini</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mod_init);</span><br><span class="line">module_exit(mod_fini);</span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A somewhat malicious module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Ignat Korchagin &lt;ignat@cloudflare.com&gt;&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以及相应的<code>Kbuild</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m := mymod.o</span><br></pre></td></tr></table></figure>

<p>使用这两个文件，我们可以根据<a href="https://docs.kernel.org/kbuild/modules.html">官方内核文档</a>构建一个完整的内核模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">cd</span> mymod/</span><br><span class="line">ignat@dev:~/mymod$ <span class="built_in">ls</span></span><br><span class="line">Kbuild  mymod.c</span><br><span class="line">ignat@dev:~/mymod$ make -C /lib/modules/`<span class="built_in">uname</span> -r`/build M=<span class="variable">$PWD</span></span><br><span class="line">make: Entering directory <span class="string">&#x27;/usr/src/linux-headers-6.1.0-18-cloud-amd64&#x27;</span></span><br><span class="line">  CC [M]  /home/ignat/mymod/mymod.o</span><br><span class="line">  MODPOST /home/ignat/mymod/Module.symvers</span><br><span class="line">  CC [M]  /home/ignat/mymod/mymod.mod.o</span><br><span class="line">  LD [M]  /home/ignat/mymod/mymod.ko</span><br><span class="line">  BTF [M] /home/ignat/mymod/mymod.ko</span><br><span class="line">Skipping BTF generation <span class="keyword">for</span> /home/ignat/mymod/mymod.ko due to unavailability of vmlinux</span><br><span class="line">make: Leaving directory <span class="string">&#x27;/usr/src/linux-headers-6.1.0-18-cloud-amd64&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果现在尝试加载此模块，系统可能不允许，因为SELinux策略的原因：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~/mymod$ sudo insmod mymod.ko insmod: ERROR: could not load module mymod.ko: Permission denied</span><br></pre></td></tr></table></figure>

<p>我们可以通过将模块复制到标准模块路径中的某个位置来解决此问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~/mymod$ sudo <span class="built_in">cp</span> mymod.ko /lib/modules/`<span class="built_in">uname</span> -r`/kernel/crypto/</span><br></pre></td></tr></table></figure>

<p>现在让我们试试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~/mymod$ sudo getenforce Enforcing ignat@dev:~/mymod$ sudo insmod /lib/modules/`<span class="built_in">uname</span> -r`/kernel/crypto/mymod.ko ignat@dev:~/mymod$ sudo getenforce Permissive</span><br></pre></td></tr></table></figure>

<p>我们不仅通过恶意内核模块静默地禁用了SELinux保护，而且还完成了这一操作。正常的<code>sudo setenforce 0</code>即使被允许，也会通过官方的<a href="https://elixir.bootlin.com/linux/v6.1.76/source/security/selinux/selinuxfs.c#L173">selinuxfs接口，并发出审核消息</a>。我们的代码直接操作内核内存，因此没有人会发出警报。这说明为什么不受控制的内核模块加载非常危险，这也是为什么大多数安全标准和商业安全监控产品主张密切监控内核模块加载的原因。</p>
<p>但是，在Cloudflare上，我们不需要监视内核模块。让我们在Cloudflare生产内核上重复这个过程（为简洁起见，跳过模块重新编译）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep MODULE_SIG /boot/config-6.1.0-18-cloud-amd64</span><br><span class="line">CONFIG_MODULE_SIG_FORMAT=y</span><br><span class="line">CONFIG_MODULE_SIG=y</span><br><span class="line"><span class="comment"># CONFIG_MODULE_SIG_FORCE is not set</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>当尝试加载模块时，我们会收到“Key was rejected by service”错误，并且内核日志将显示以下消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~/mymod$ sudo dmesg | <span class="built_in">tail</span> -n 1 [41515.037031] Loading of unsigned module is rejected</span><br></pre></td></tr></table></figure>

<p>这是因为Cloudflare内核要求所有内核模块具有有效的签名，因此我们无需担心恶意模块在某个时间点被加载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep MODULE_SIG_FORCE /boot/config-`<span class="built_in">uname</span> -r` CONFIG_MODULE_SIG_FORCE=y</span><br></pre></td></tr></table></figure>

<p>为了完整起见，值得注意的是，Debian标准内核也支持模块签名，但不强制执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep MODULE_SIG /boot/config-6.1.0-18-cloud-amd64 CONFIG_MODULE_SIG_FORMAT=y CONFIG_MODULE_SIG=y <span class="comment"># CONFIG_MODULE_SIG_FORCE is not set …</span></span><br></pre></td></tr></table></figure>

<p>上述配置意味着，如果可用，内核将验证模块签名。但是如果没有签名-模块将被加载，并发出警告消息，<a href="https://docs.kernel.org/admin-guide/tainted-kernels.html">内核将被污染</a>。</p>
<h3 id="内核模块签名的密钥管理"><a href="#内核模块签名的密钥管理" class="headerlink" title="内核模块签名的密钥管理"></a>内核模块签名的密钥管理</h3><p>签名的内核模块非常好，但是它会带来密钥管理问题：要签名一个模块，我们需要一个由内核信任的签名密钥对。密钥对的公钥通常直接嵌入到内核二进制文件中，因此内核可以轻松使用它来验证模块签名。密钥对的私钥需要受到保护和安全，因为如果泄漏，任何人都可以编译和签名一个潜在恶意的内核模块，而我们的内核将接受它。</p>
<p>但是，如何消除丢失风险呢？首先不要一开始就拥有它！幸运的是，内核构建系统<a href="https://elixir.bootlin.com/linux/v6.6.17/source/certs/Makefile#L36">将为模块签名生成一个随机密钥对</a>，如果没有提供密钥。在Cloudflare，我们使用该功能在内核编译阶段对所有内核模块进行签名。但是，在编译和签名完成后，我们不会将私钥存储在安全的位置，而是销毁私钥：</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/46b61bf0a9163c9836837b598bc64d9e.png" alt="image1-19"></p>
<p>因此，根据上述过程：</p>
<ol>
<li>内核构建系统为模块签名生成了一个随机密钥对，并编译内核和模块</li>
<li>公钥嵌入到内核映像中，私钥用于签名所有模块</li>
<li>私钥被销毁</li>
</ol>
<p>通过这种方案，我们不仅无需担心模块签名密钥管理问题，而且我们还为每个发布到生产环境的内核使用不同的密钥。因此，即使某个特定的构建过程被劫持并且签名密钥未被销毁并且有可能泄漏，当发布内核更新时，该密钥将不再有效。</p>
<p>然而，值得注意的是，Debian内核的库存版本也支持模块签名，但不强制执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep MODULE_SIG /boot/config-6.1.0-18-cloud-amd64 CONFIG_MODULE_SIG_FORMAT=y CONFIG_MODULE_SIG=y <span class="comment"># CONFIG_MODULE_SIG_FORCE is not set …</span></span><br></pre></td></tr></table></figure>

<p>上述配置意味着，如果可用，内核将验证模块签名。但是如果没有签名-模块将被加载，并发出警告消息，<a href="https://docs.kernel.org/admin-guide/tainted-kernels.html">内核将被污染</a>。</p>
<h3 id="KEXEC"><a href="#KEXEC" class="headerlink" title="KEXEC"></a>KEXEC</h3><p><a href="https://en.wikipedia.org/wiki/Kexec">KEXEC</a>（或<code>kexec_load()</code>）是Linux中一个有趣的系统调用，它允许一个内核直接执行（或跳转到）另一个内核。这个想法是在不经过完整的重新启动过程的情况下更快地切换&#x2F;更新&#x2F;降级内核，以减少潜在的系统停机时间。然而，它是在很久以前开发的，当时安全启动和系统完整性还不是一个问题。因此，它的原始设计存在安全缺陷，可以<a href="https://mjg59.dreamwidth.org/28746.html">绕过安全启动并潜在地破坏系统完整性</a>。</p>
<p>我们可以根据<a href="https://man7.org/linux/man-pages/man2/kexec_load.2.html">系统调用的定义</a>看到这些问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kexec_segment</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *buf;</span><br><span class="line">	<span class="type">size_t</span> bufsz;</span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *mem;</span><br><span class="line">	<span class="type">size_t</span> memsz;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">long</span> <span class="title function_">kexec_load</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> entry, <span class="type">unsigned</span> <span class="type">long</span> nr_segments, <span class="keyword">struct</span> kexec_segment *segments, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p>因此，内核期望的只是一组要执行的代码缓冲区。在当时，内核内部没有太多的数据解析的愿望，因此，解析要执行的内核映像是在用户空间中完成的，并且仅向内核提供其所需的数据。此外，为了在旧内核关闭时接管并且新内核尚未执行时，我们需要一个中间程序。在kexec世界中，此程序称为<a href="https://git.kernel.org/pub/scm/utils/kernel/kexec/kexec-tools.git/tree/purgatory">purgatory</a>。因此，问题显而易见：我们向内核提供一堆代码，它将愉快地以最高特权级别执行它。但是，与原始内核或purgatory代码相反，我们可以轻松地提供类似于本文中演示的代码，该代码禁用SELinux（或对内核执行其他操作）。</p>
<p>在Cloudflare上，我们已经将<code>kexec_load()</code>禁用了一段时间，仅因为这个原因。使用kexec实现更快的重新启动的优点是，<a href="https://elixir.bootlin.com/linux/v6.6.17/source/kernel/Kconfig.kexec#L30">硬件可能未正确初始化</a>，因此即使没有安全问题，也不值得使用它。但是，kexec确实提供了一个有用的功能-它是Linux内核<a href="https://docs.kernel.org/admin-guide/kdump/kdump.html">崩溃转储解决方案</a>的基础。简而言之，如果内核在生产中崩溃（由于错误或其他错误），备份内核（使用kexec预先加载）可以接管，收集并保存内存转储以供进一步调查。这使得在生产中更有效地调查内核和其他问题成为可能，因此它是一个强大的工具。</p>
<p>幸运的是，自从<a href="https://mjg59.dreamwidth.org/28746.html">指出了kexec的原始问题</a>以来，Linux开发了一种替代的<a href="https://elixir.bootlin.com/linux/v6.6.17/source/kernel/Kconfig.kexec#L36">安全的kexec接口</a>：与其使用代码缓冲区，它期望使用包含要执行的内核映像和initrd的文件描述符，并在内核内部进行解析。因此，只能提供有效的内核映像。在此基础上，我们可以<a href="https://elixir.bootlin.com/linux/v6.6.17/source/kernel/Kconfig.kexec#L48">配置</a>并<a href="https://elixir.bootlin.com/linux/v6.6.17/source/kernel/Kconfig.kexec#L62">要求</a>kexec以确保所提供的映像具有正确的签名，因此只有经授权的代码可以在kexec场景中执行。一个安全的kexec配置如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep KEXEC /boot/config-`<span class="built_in">uname</span> -r` CONFIG_KEXEC_CORE=y CONFIG_HAVE_IMA_KEXEC=y <span class="comment"># CONFIG_KEXEC is not set CONFIG_KEXEC_FILE=y CONFIG_KEXEC_SIG=y CONFIG_KEXEC_SIG_FORCE=y CONFIG_KEXEC_BZIMAGE_VERIFY_SIG=y …</span></span><br></pre></td></tr></table></figure>

<p>以上配置确保了禁用了传统的<code>kexec_load()</code>系统调用，通过禁用<code>CONFIG_KEXEC</code>来实现，但仍然可以使用新的<code>kexec_file_load()</code>系统调用通过<code>CONFIG_KEXEC_FILE=y</code>进行Linux内核崩溃转储的配置，并强制执行签名检查（<code>CONFIG_KEXEC_SIG=y</code>和<code>CONFIG_KEXEC_SIG_FORCE=y</code>）。</p>
<p>请注意，Debian内核的库存版本启用了传统的<code>kexec_load()</code>系统调用，并且不强制执行<code>kexec_file_load()</code>的签名检查（类似于模块签名检查）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep KEXEC /boot/config-6.1.0-18-cloud-amd64 CONFIG_KEXEC=y CONFIG_KEXEC_FILE=y CONFIG_ARCH_HAS_KEXEC_PURGATORY=y CONFIG_KEXEC_SIG=y <span class="comment"># CONFIG_KEXEC_SIG_FORCE is not set CONFIG_KEXEC_BZIMAGE_VERIFY_SIG=y …</span></span><br></pre></td></tr></table></figure>

<h2 id="内核地址空间布局随机化（KASLR）"><a href="#内核地址空间布局随机化（KASLR）" class="headerlink" title="内核地址空间布局随机化（KASLR）"></a>内核地址空间布局随机化（KASLR）</h2><p>即使在库存的Debian内核上，如果您尝试在系统重新启动后重复我们在“安全启动”部分中描述的练习，您可能会发现它无法再禁用SELinux。这是因为我们在恶意内核模块中硬编码了<code>selinux_state</code>的内核地址，但现在地址已更改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ sudo grep selinux_state /proc/kallsyms ffffffffb41bcae0 B selinux_state</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.kernel.org/security/self-protection.html#kernel-address-space-layout-randomization-kaslr">内核地址空间布局随机化（或KASLR）</a>是一个简单的概念：它在每次启动时都会轻微且随机地移动内核代码和数据：</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/70708d7d7185c3edd9a77c712198af8c.png" alt="Screenshot-2024-03-06-at-13.53.23-2"></p>
<p>这是为了对抗基于对内核内部结构和代码位置的了解的有针对性的利用（如本文中的恶意模块）。对于像Debian这样的流行Linux发行版内核尤其有用，因为大多数用户使用相同的二进制文件，任何人都可以下载调试符号和包含所有内核内部地址的System.map文件。只要注意：它不会阻止模块加载和造成伤害，但它可能无法实现禁用SELinux的有针对性效果。相反，它将修改随机的内核内存片段，可能导致内核崩溃。</p>
<p>Cloudflare内核和Debian内核都启用了此功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep RANDOMIZE_BASE /boot/config-`<span class="built_in">uname</span> -r` CONFIG_RANDOMIZE_BASE=y</span><br></pre></td></tr></table></figure>

<h3 id="受限制的内核指针"><a href="#受限制的内核指针" class="headerlink" title="受限制的内核指针"></a>受限制的内核指针</h3><p>虽然KASLR有助于针对性的利用，但很容易绕过，因为每次只是通过单个随机偏移量移动所有内容，如上图所示。因此，如果攻击者知道至少一个运行时内核地址，他们可以通过将运行时地址从内核的System.map文件中的相同符号（函数或数据结构）的编译时地址中减去来恢复此偏移量。一旦他们知道了偏移量，他们就可以通过调整它们来恢复所有其他符号的地址。</p>
<p>因此，现代内核为了至少不将内核地址泄漏给非特权用户而采取了预防措施。其中一个主要的调整选项是<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#kptr-restrict">kptr_restrict sysctl</a>。将其至少设置为<code>1</code>以禁止普通用户查看内核指针是一个好主意：<br>（shell&#x2F;bash）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ sudo sysctl -w kernel.kptr_restrict=1</span><br><span class="line">kernel.kptr_restrict = 1</span><br><span class="line">ignat@dev:~$ grep selinux_state /proc/kallsyms</span><br><span class="line">0000000000000000 B selinux_state</span><br></pre></td></tr></table></figure>

<p>特权用户仍然可以查看指针：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ sudo grep selinux_state /proc/kallsyms ffffffffb41bcae0 B selinux_state</span><br></pre></td></tr></table></figure>

<p>类似于<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#kptr-restrict">kptr_restrict sysctl</a>，还有<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#dmesg-restrict">dmesg_restrict</a>，如果设置，将阻止普通用户读取内核日志（通过其消息也可能泄漏内核指针）。虽然您需要在每次启动时显式设置<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#kptr-restrict">kptr_restrict sysctl</a>的值（或使用一些系统sysctl配置实用程序，如<a href="https://www.freedesktop.org/software/systemd/man/latest/systemd-sysctl.service.html">此工具</a>），但您可以通过<code>CONFIG_SECURITY_DMESG_RESTRICT</code>内核配置选项来配置<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#dmesg-restrict">dmesg_restrict</a>的初始值。Cloudflare内核和Debian内核都通过这种方式强制执行<a href="https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#dmesg-restrict">dmesg_restrict</a>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep CONFIG_SECURITY_DMESG_RESTRICT /boot/config-`<span class="built_in">uname</span> -r` CONFIG_SECURITY_DMESG_RESTRICT=y</span><br></pre></td></tr></table></figure>

<p>值得注意的是，&#x2F;proc&#x2F;kallsyms和内核日志不是潜在的内核指针泄漏的唯一来源。Linux内核中有很多遗留问题，而且<a href="https://docs.kernel.org/latest/admin-guide/kernel-parameters.html#debug-kernel-parameters">新的泄漏来源不断被发现和修复</a>。这就是为什么及时跟上最新的内核错误修复版本非常重要。</p>
<h2 id="Lockdown-LSM"><a href="#Lockdown-LSM" class="headerlink" title="Lockdown LSM"></a>Lockdown LSM</h2><p><a href="https://www.kernel.org/doc/html/latest/admin-guide/LSM/index.html">Linux Security Modules (LSM)</a>是一个基于钩子的框架，用于在Linux内核中实现安全策略和强制访问控制。我们之前[介绍过我们使用的另一个LSM模块，BPF-LSM]。</p>
<p>BPF-LSM是我们内核安全性的一个有用的基础组件，但在本文中，我们要提到我们使用的另一个有用的LSM模块——<a href="https://man7.org/linux/man-pages/man7/kernel_lockdown.7.html">Lockdown LSM</a>。Lockdown可以处于三种状态（由<code>/sys/kernel/security/lockdown</code>特殊文件控制）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">cat</span> /sys/kernel/security/lockdown [none] integrity confidentiality</span><br></pre></td></tr></table></figure>

<p><code>none</code>是未执行任何操作并且模块实际上被禁用的状态。当Lockdown处于<code>integrity</code>状态时，内核尝试阻止任何可能破坏其完整性的操作。我们在本文中已经涵盖了其中的一些示例：加载未签名的模块和通过KEXEC执行未签名的代码。但是，该LSM还尝试阻止<a href="https://man7.org/linux/man-pages/man7/kernel_lockdown.7.html">LSM的man页中提到的其他潜在方式</a>。<code>confidentiality</code>是最严格的模式，其中Lockdown还尝试阻止内核信息泄漏。在实践中，这对于服务器工作负载来说可能过于严格，因为它会阻止所有运行时调试功能，如<code>perf</code>或eBPF。</p>
<p>让我们看看Lockdown LSM的实际效果。在一个基本的Debian系统上，初始状态是<code>none</code>，意味着没有被锁定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">uname</span> -a Linux dev 6.1.0-18-cloud-amd64 <span class="comment">#1 SMP PREEMPT_DYNAMIC Debian 6.1.76-1 (2024-02-01) x86_64 GNU/Linux ignat@dev:~$ cat /sys/kernel/security/lockdown [none] integrity confidentiality</span></span><br></pre></td></tr></table></figure>

<p>我们可以将系统切换到<code>integrity</code>模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">echo</span> integrity | sudo <span class="built_in">tee</span> /sys/kernel/security/lockdown integrity ignat@dev:~$ <span class="built_in">cat</span> /sys/kernel/security/lockdown none [integrity] confidentiality</span><br></pre></td></tr></table></figure>

<p>值得注意的是，我们只能将系统设置为更严格的状态，而不能返回。也就是说，一旦进入<code>integrity</code>模式，我们只能切换到<code>confidentiality</code>模式，而不能切换回<code>none</code>模式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ <span class="built_in">echo</span> none | sudo <span class="built_in">tee</span> /sys/kernel/security/lockdown none <span class="built_in">tee</span>: /sys/kernel/security/lockdown: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>现在，即使在库存的Debian内核上，我们也无法再加载潜在恶意的未签名内核模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ sudo insmod mymod/mymod.ko insmod: ERROR: could not insert module mymod/mymod.ko: Operation not permitted</span><br></pre></td></tr></table></figure>

<p>而且内核日志会友好地指出这是由于Lockdown LSM引起的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ sudo dmesg | <span class="built_in">tail</span> -n 1 [21728.820129] Lockdown: insmod: unsigned module loading is restricted; see man kernel_lockdown.7</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，Lockdown LSM有助于加强内核的安全性，否则可能不会启用其他强制执行位，如库存的Debian内核。</p>
<p>如果您自己编译内核，您可以更进一步，将<a href="https://elixir.bootlin.com/linux/v6.6.17/source/security/lockdown/Kconfig#L33">Lockdown LSM的初始状态设置为比none更严格的状态</a>。这正是我们为Cloudflare生产内核所做的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ignat@dev:~$ grep LOCK_DOWN /boot/config-6.6.17-cloudflare-2024.2.9 <span class="comment"># CONFIG_LOCK_DOWN_KERNEL_FORCE_NONE is not set CONFIG_LOCK_DOWN_KERNEL_FORCE_INTEGRITY=y # CONFIG_LOCK_DOWN_KERNEL_FORCE_CONFIDENTIALITY is not set</span></span><br></pre></td></tr></table></figure>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在本文中，我们回顾了Cloudflare在Linux内核安全配置方面使用的一些有用方法。这只是一个小的子集，还有许多其他可用的功能，并且Linux内核社区不断开发、审查和改进更多功能。我们希望本文能够为您介绍这些安全功能，并且如果您尚未这样做，您可以考虑在Linux系统中启用它们。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Go 主流日志库：从设计层学习如何集成日志轮转与切割功能</title>
    <url>/2024/02/16/%E6%B5%85%E6%9E%90Go%20%E4%B8%BB%E6%B5%81%E6%97%A5%E5%BF%97%E5%BA%93%EF%BC%9A%E4%BB%8E%E8%AE%BE%E8%AE%A1%E5%B1%82%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90%E6%97%A5%E5%BF%97%E8%BD%AE%E8%BD%AC%E4%B8%8E%E5%88%87%E5%89%B2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>在现有的日志库中，包括 <code>go</code> 1.21.0 引入的 <code>slog</code> 日志库，它们通常都支持对日志文件进行轮转与切割，只不过这些功能并不直接被内置，而是需要我们主动配置来启用。</p>
<p>本文将探讨几个热门的日志库如 <code>logrus</code>、<code>zap</code> 和官网的 <code>slog</code>，我将分析这些库的的关键设计元素，探讨它们是如何支持日志轮转与切割功能的配置。</p>
<span id="more"></span>
<h1 id="浅析-logrus、zap-和-slog-的设计"><a href="#浅析-logrus、zap-和-slog-的设计" class="headerlink" title="浅析 logrus、zap 和 slog 的设计"></a>浅析 logrus、zap 和 slog 的设计</h1><p>在对 <code>logrus</code>、<code>zap</code> 和 <code>slog</code> 这几个日志库的设计进行对比分析时，一个显著的共同点是它们都包含了 <code>io.Writer</code> 这个关键的属性。这一属性在日志框架设计中起着核心作用，它决定了日志输出的目标位置。</p>
<h2 id="logrus-日志库"><a href="#logrus-日志库" class="headerlink" title="logrus 日志库"></a>logrus 日志库</h2><p><code>logrus</code> 是一个功能丰富的Go语言日志库，它提供了结构化日志记录、日志级别控制等功能。</p>
<p>当使用 <code>logrus</code> 时，可以调用 <code>logrus.New()</code> 函数来创建 <code>Logger</code> 实例。通过该实例我们执行很多操作，例如自定义日志输出的位置和打印日志等。我们看看下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">logger := logrus.New()  </span><br><span class="line">logger.Out = os.Stdout <span class="comment">// stdout  </span></span><br><span class="line"><span class="comment">// or redirects to file</span></span><br><span class="line"><span class="comment">//out, err := os.OpenFile(&quot;file.log&quot;, os.O_CREATE|os.O_WRONLY, 0666)  </span></span><br><span class="line"><span class="comment">//if err != nil &#123;  </span></span><br><span class="line"><span class="comment">// panic(err)  </span></span><br><span class="line"><span class="comment">//&#125;  </span></span><br><span class="line"><span class="comment">//logger.Out = out</span></span><br></pre></td></tr></table></figure>

<p><code>Logger</code> 结构体的定义如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;  </span><br><span class="line">Out io.Writer  </span><br><span class="line">Hooks LevelHooks  </span><br><span class="line">Formatter Formatter  </span><br><span class="line"><span class="comment">// other field...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键属性 <code>Out</code>，其类型为 <code>io.Writer</code>，这一属性用于指定日志的输出目标，无论是标准输出、文件，还是其他自定义的输出载体。</p>
<h2 id="zap-日志库"><a href="#zap-日志库" class="headerlink" title="zap 日志库"></a>zap 日志库</h2><p><code>zap</code> 是一个性能极高的日志库。它提供了结构化日志记录、多级别日志控制，以及灵活的配置选项。</p>
<p>与 <code>logrus</code> 类似，<code>zap</code> 也允许支持通过配置来决定日志输出的位置，但实现方式略有不同。在 <code>zap</code> 中，日志输出是通过配置 <code>zapcore.Core</code> 实现的。在创建 <code>zapcore.Core</code> 实例时，需要指定一个 <code>zapcore.WriteSyncer</code> 接口实现作为参数，这个参数直接决定了日志的输出目标。要创建 <code>zapcore.WriteSyncer</code> 实例，通常使用 <code>zapcore.AddSync()</code> 函数，它接收一个类型为 <code>io.Writer</code> 的参数。</p>
<p>下面是一个使用 <code>zap</code> 创建日志实例的基本示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">writer := zapcore.AddSync(os.Stdout) <span class="comment">// use stdout  </span></span><br><span class="line">core := zapcore.NewCore(  </span><br><span class="line">zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),  </span><br><span class="line">writer,  </span><br><span class="line">zap.InfoLevel,  </span><br><span class="line">)  </span><br><span class="line">logger := zap.New(core)  </span><br><span class="line"><span class="keyword">defer</span> logger.Sync() <span class="comment">// 刷新任何缓冲的日志条目  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// user logger </span></span><br></pre></td></tr></table></figure>

<p>关键在于 <code>zapcore.AddSync()</code> 函数，该函数接收一个类型为 <code>io.Writer</code> 的参数，这一参数用于指定日志的输出目标，无论是标准输出、文件，还是其他自定义的输出载体。</p>
<h2 id="slog-日志库"><a href="#slog-日志库" class="headerlink" title="slog 日志库"></a>slog 日志库</h2><p><code>slog</code> 是在 <code>go 1.21.0</code> 版本引入的一个官网日志库，它提供了结构化日志。如果想要更详细地了解 <code>slog</code> 日志库，</p>
<p>与 <code>logrus</code> 和 <code>zap</code> 类似，<code>slog</code> 也允许用户通过指定 <code>io.Writer</code> 参数来设置日志输出的目标。这一设置是在创建 <code>slog.Handler</code> 接口的实现时进行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">textLogger := slog.New(slog.NewTextHandler(os.Stdout, <span class="literal">nil</span>))  </span><br><span class="line">jsonLogger := slog.New(slog.NewJSONHandler(os.Stdout, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<p>在这两个函数中，<code>slog.NewTextHandler</code> 和 <code>slog.NewJSONHandler</code> 第一个参数的类型都是 <code>io.Writer</code>。</p>
<h2 id="浅析总结"><a href="#浅析总结" class="headerlink" title="浅析总结"></a>浅析总结</h2><p>在对 <code>logurs</code>、<code>zap</code> 和 <code>slog</code> 这三个主流日志库的分析中，我们可以发现一个关键的共同点：它们在处理日志输出时均依赖于 <code>io.Writer</code> 接口。这些日志库通过将 <code>io.Writer</code>接口作为关键参数的类型，以便设置日志的输出目标。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/02/f3e3b50c2247e4d57f5b0946497fbba8.png" alt="Pasted image 20240212220811"></p>
<h1 id="日志轮转与切割功能的实现机制与实践"><a href="#日志轮转与切割功能的实现机制与实践" class="headerlink" title="日志轮转与切割功能的实现机制与实践"></a>日志轮转与切割功能的实现机制与实践</h1><h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>在浅析了 <code>logurs</code>、<code>zap</code> 和 <code>slog</code> 日志库的设计后，我们发现了它们的共同点。现在，让我们深入了解日志轮转与切割功能的实现机制。</p>
<p>为了实现 <strong>日志文件的轮转与切割</strong>，通常我们会借助第三方库，如 lumberjack，当然还有其他类似的库可供选择，这里就不一一列举了。</p>
<p><code>lumberjack</code> 是一个专门设计用于日志轮转和切割的库，其作用可以类比于一个可插拔的组件。我们可以通过配置该组件，并将其 <strong>集成</strong> 到所选的日志库中，从而实现日志文件的轮转与切割功能。</p>
<p>初始化 <code>lumberjack</code> 组件的代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log := &amp;lumberjack.Logger&#123;  </span><br><span class="line">Filename: <span class="string">&quot;/path/file.log&quot;</span>, <span class="comment">// location of the log file</span></span><br><span class="line">MaxSize: <span class="number">10</span>, <span class="comment">// Maximum file size (in MB)</span></span><br><span class="line">MaxBackups: <span class="number">3</span>, <span class="comment">// Maximum number of old files to keep</span></span><br><span class="line">MaxAge: <span class="number">28</span>, <span class="comment">// Maximum number of days to retain old files</span></span><br><span class="line">Compress: <span class="literal">true</span>, <span class="comment">// whether to compress/archive old files</span></span><br><span class="line">LocalTime: <span class="literal">true</span>, <span class="comment">// create timestamps using local time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>lumberjack.Logger</code> 实例，并设置了以下参数：</p>
<ul>
<li><code>Filename</code>：指定日志文件的存储路径。</li>
<li><code>MaxSize</code>：日志文件达到多少 <code>MB</code> 后进行轮转。</li>
<li><code>MaxBackups</code>：最多保留多少个旧日志文件。</li>
<li><code>MaxAge</code>：旧文件保留的最长时间（天）。</li>
<li><code>Compress</code>：是否压缩旧文件（如转换为.gz）。</li>
</ul>
<p>需要特别注意的是， <code>lumberjack</code> 的 <code>Logger</code> 结构体实现了 <code>io.Writer</code> 接口。这意味着所有关于日志文件的轮转与切割的核心逻辑都封装在 <code>Write</code> 方法中。这一实现也方便 <code>Logger</code> 结构体被集成到任何支持 <code>io.Writer</code> 参数的日志库中。</p>
<p>明白了这些，想必你已经知道如何实现日志轮转与切割的功能了吧。<code>lumberjack</code> 的 <code>logger</code>  结构体实现了 <code>io.Writer</code> 接口，因此将它传递到第三方库中，就能完成集成配置了。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="logrus-日志库的实现"><a href="#logrus-日志库的实现" class="headerlink" title="logrus 日志库的实现"></a>logrus 日志库的实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log := &amp;lumberjack.Logger&#123;</span><br><span class="line">	Filename: <span class="string">&quot;/path/file.log&quot;</span>, <span class="comment">// location of log file</span></span><br><span class="line">	MaxSize: <span class="number">10</span>, <span class="comment">// Maximum file size in MB</span></span><br><span class="line">	MaxBackups: <span class="number">3</span>, <span class="comment">// Maximum number of old files to keep</span></span><br><span class="line">	MaxAge: <span class="number">28</span>, <span class="comment">// Maximum number of days to retain old files</span></span><br><span class="line">	Compress: <span class="literal">true</span>, <span class="comment">// whether to compress/archive old files</span></span><br><span class="line">	LocalTime: <span class="literal">true</span>, <span class="comment">// create timestamps using local time</span></span><br><span class="line">&#125;</span><br><span class="line">logger := logrus.New()</span><br><span class="line">logger.Out = log</span><br></pre></td></tr></table></figure>

<h3 id="zap-日志库的实现"><a href="#zap-日志库的实现" class="headerlink" title="zap 日志库的实现"></a>zap 日志库的实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log := &amp;lumberjack.Logger&#123;</span><br><span class="line">	Filename: <span class="string">&quot;/path/file.log&quot;</span>, <span class="comment">// location of log file</span></span><br><span class="line">	MaxSize: <span class="number">10</span>, <span class="comment">// Maximum file size in MB</span></span><br><span class="line">	MaxBackups: <span class="number">3</span>, <span class="comment">// Maximum number of old files to keep</span></span><br><span class="line">	MaxAge: <span class="number">28</span>, <span class="comment">// Maximum number of days to retain old files</span></span><br><span class="line">	Compress: <span class="literal">true</span>, <span class="comment">// whether to compress/archive old files</span></span><br><span class="line">	LocalTime: <span class="literal">true</span>, <span class="comment">// create timestamps using local time</span></span><br><span class="line">&#125;</span><br><span class="line">writer := zapcore.AddSync(log)</span><br><span class="line">core := zapcore.NewCore(</span><br><span class="line">zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig()),</span><br><span class="line">NewJSONEncoder(zap.</span><br><span class="line">zap.InfoLevel.</span><br><span class="line">)</span><br><span class="line">logger := zap.New(core)</span><br><span class="line"><span class="keyword">defer</span> logger.Sync() <span class="comment">// Flush any buffered log entries.</span></span><br></pre></td></tr></table></figure>

<h3 id="slog-日志库的实现"><a href="#slog-日志库的实现" class="headerlink" title="slog 日志库的实现"></a>slog 日志库的实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Log := &amp;lumberjack.Logger&#123;</span><br><span class="line">	Filename: <span class="string">&quot;/path/file.log&quot;</span>, <span class="comment">// Location of the log file</span></span><br><span class="line">	MaxSize: <span class="number">10</span>, <span class="comment">// Maximum file size (in MB)</span></span><br><span class="line">	MaxBackups: <span class="number">3</span>, <span class="comment">// Maximum number of old files retained</span></span><br><span class="line">	MaxAge: <span class="number">28</span>, <span class="comment">// Maximum number of days to keep old files</span></span><br><span class="line">	Compress: <span class="literal">true</span>, <span class="comment">// Whether to compress/archive old files</span></span><br><span class="line">	LocalTime: <span class="literal">true</span>, <span class="comment">// Create a timestamp with local time</span></span><br><span class="line">&#125;</span><br><span class="line">textLogger := slog.New(slog.NewTextHandler(log, <span class="literal">nil</span>))</span><br><span class="line">jsonLogger := slog.New(slog.NewJSONHandler(log, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<p>本文对三个热门的日志库 <code>logrus</code>、<code>zap</code> 和 <code>slog</code> 设计要素进行浅析，我们发现虽然它们在创建日志实例的细节上有所差异，但它们共同依赖于 <code>io.Writer</code> 接口参数来处理日志的输出。掌握如何配置 <code>io.Writer</code> 参数，并结合 <code>lumberjack</code> 库的使用，我们就可以实现日志文件的轮转与切割功能。</p>
<p>即使后面推出新的日志库，我们也可以通过类似的方法，快速地集成日志文件的轮转与切割功能。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先算法与广度优先算法</title>
    <url>/2022/09/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="深度优先算法-（Depth-First-Search）"><a href="#深度优先算法-（Depth-First-Search）" class="headerlink" title="深度优先算法 （Depth-First-Search）"></a>深度优先算法 （Depth-First-Search）</h1><p>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分 支。<br> 当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。<br> 这一过程一直进行到已发现从源节点可达的所有节点为止。<br> 如果还存在未被发 现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>
<p>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。</p>
<p><strong>DFS属于盲目搜索</strong></p>
<p>深度优先遍历图算法步骤：</p>
<ul>
<li>访问顶点v；</li>
<li>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</li>
<li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</li>
</ul>
<p><strong>举个实例：</strong></p>
<p>DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。<br> 接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。</p>
<p>例如下图，其深度优先遍历顺序为 1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7</p>
<p><img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200406213809.png" alt="深度优先算法"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Print(root.Val)</span><br><span class="line">	dfs(root.Left)</span><br><span class="line">	dfs(root.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="广度优先搜索算法（Breadth-First-Search）"><a href="#广度优先搜索算法（Breadth-First-Search）" class="headerlink" title="广度优先搜索算法（Breadth-First-Search）"></a>广度优先搜索算法（Breadth-First-Search）</h1><p><strong>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法</strong></p>
<p>简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。<br>BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。</p>
<p>算法步骤：</p>
<ol>
<li>首先将根节点放入队列中。</li>
<li>从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。</li>
<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>
<li>重复步骤2。</li>
</ol>
<p>如上图，其广度优先算法的遍历顺序为：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</p>
<p>代码实现</p>
<h3 id="leetcode-真题"><a href="#leetcode-真题" class="headerlink" title="leetcode 真题"></a>leetcode 真题</h3><h4 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AnnotatedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	node *TreeNode</span><br><span class="line">	dept,</span><br><span class="line">	ops <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> linkNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value *AnnotatedNode</span><br><span class="line">	next  *linkNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">type</span> linkedAnnotatedNodeList <span class="keyword">struct</span> &#123;</span><br><span class="line">	head  *linkNode <span class="comment">//队首</span></span><br><span class="line">	tail  *linkNode <span class="comment">//队尾</span></span><br><span class="line">	count <span class="type">int</span>       <span class="comment">//长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLinkedAnnotatedNodeList</span><span class="params">()</span></span> *linkedAnnotatedNodeList &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;linkedAnnotatedNodeList&#123;head: <span class="literal">nil</span>, tail: <span class="literal">nil</span>, count: <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *linkedAnnotatedNodeList)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.count == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *linkedAnnotatedNodeList)</span></span> Add(value *AnnotatedNode) &#123;</span><br><span class="line">	node := <span class="built_in">new</span>(linkNode)</span><br><span class="line">	node.value = value</span><br><span class="line"></span><br><span class="line">	this.count++</span><br><span class="line">	<span class="keyword">if</span> this.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		this.head = node</span><br><span class="line">		this.tail = node</span><br><span class="line">		node.next = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.tail.next = node</span><br><span class="line">	node.next = <span class="literal">nil</span></span><br><span class="line">	this.tail = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *linkedAnnotatedNodeList)</span></span> Delete() *linkNode &#123;</span><br><span class="line">	<span class="keyword">if</span> this.head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.count--</span><br><span class="line">	<span class="keyword">if</span> this.head == this.tail &#123;</span><br><span class="line">		node := this.head</span><br><span class="line">		this.head = <span class="literal">nil</span></span><br><span class="line">		this.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125;</span><br><span class="line">	node := this.head</span><br><span class="line">	this.head = this.head.next</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	link *linkedAnnotatedNodeList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> *Queue &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Queue&#123;link: NewLinkedAnnotatedNodeList()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> Put(value *AnnotatedNode) &#123;</span><br><span class="line">	this.link.Add(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop出队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> Pop() *linkNode &#123;</span><br><span class="line">	<span class="keyword">return</span> this.link.Delete()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> GetSize() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.link.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.GetSize() == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">widthOfBinaryTree</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	query := NewQueue()</span><br><span class="line">	query.Put(&amp;AnnotatedNode&#123;</span><br><span class="line">		node: root,</span><br><span class="line">		dept: <span class="number">0</span>,</span><br><span class="line">		ops:  <span class="number">0</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	curDepth := <span class="number">0</span></span><br><span class="line">	left := <span class="number">0</span></span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> query.GetSize() != <span class="number">0</span> &#123;</span><br><span class="line">		a := query.Pop().value</span><br><span class="line">		<span class="keyword">if</span> a.node != <span class="literal">nil</span> &#123;</span><br><span class="line">			query.Put(&amp;AnnotatedNode&#123;</span><br><span class="line">				node: a.node.Left,</span><br><span class="line">				dept: a.dept + <span class="number">1</span>,</span><br><span class="line">				ops:  a.ops * <span class="number">2</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			query.Put(&amp;AnnotatedNode&#123;</span><br><span class="line">				node: a.node.Right,</span><br><span class="line">				dept: a.dept + <span class="number">1</span>,</span><br><span class="line">				ops:  a.ops*<span class="number">2</span> + <span class="number">1</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">if</span> curDepth != a.dept &#123;</span><br><span class="line">				curDepth = a.dept</span><br><span class="line">				left = a.ops</span><br><span class="line">			&#125;</span><br><span class="line">			ans = Max(ans, a.ops-left+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层次遍历</a></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> AnnotatedNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	node  *TreeNode</span><br><span class="line">	dept, <span class="comment">//深度</span></span><br><span class="line">	ops <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> linkNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value *AnnotatedNode</span><br><span class="line">	next  *linkNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">type</span> linkedAnnotatedNodeList <span class="keyword">struct</span> &#123;</span><br><span class="line">	head  *linkNode <span class="comment">//队首</span></span><br><span class="line">	tail  *linkNode <span class="comment">//队尾</span></span><br><span class="line">	count <span class="type">int</span>       <span class="comment">//长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLinkedAnnotatedNodeList</span><span class="params">()</span></span> *linkedAnnotatedNodeList &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;linkedAnnotatedNodeList&#123;head: <span class="literal">nil</span>, tail: <span class="literal">nil</span>, count: <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *linkedAnnotatedNodeList)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.count == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *linkedAnnotatedNodeList)</span></span> Add(value *AnnotatedNode) &#123;</span><br><span class="line">	node := <span class="built_in">new</span>(linkNode)</span><br><span class="line">	node.value = value</span><br><span class="line"></span><br><span class="line">	this.count++</span><br><span class="line">	<span class="keyword">if</span> this.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">		this.head = node</span><br><span class="line">		this.tail = node</span><br><span class="line">		node.next = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.tail.next = node</span><br><span class="line">	node.next = <span class="literal">nil</span></span><br><span class="line">	this.tail = node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *linkedAnnotatedNodeList)</span></span> Delete() *linkNode &#123;</span><br><span class="line">	<span class="keyword">if</span> this.head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.count--</span><br><span class="line">	<span class="keyword">if</span> this.head == this.tail &#123;</span><br><span class="line">		node := this.head</span><br><span class="line">		this.head = <span class="literal">nil</span></span><br><span class="line">		this.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> node</span><br><span class="line">	&#125;</span><br><span class="line">	node := this.head</span><br><span class="line">	this.head = this.head.next</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">	link *linkedAnnotatedNodeList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewQueue</span><span class="params">()</span></span> *Queue &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Queue&#123;link: NewLinkedAnnotatedNodeList()&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> Put(value *AnnotatedNode) &#123;</span><br><span class="line">	this.link.Add(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pop出队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> Pop() *linkNode &#123;</span><br><span class="line">	<span class="keyword">return</span> this.link.Delete()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得队列的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> GetSize() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.link.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Queue)</span></span> IsEmpty() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.GetSize() == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	query := NewQueue()</span><br><span class="line"></span><br><span class="line">	query.Put(&amp;AnnotatedNode&#123;node: root, dept: <span class="number">0</span>, ops: <span class="number">0</span>&#125;)</span><br><span class="line">	<span class="keyword">for</span> query.GetSize() != <span class="number">0</span> &#123;</span><br><span class="line">		a := query.Pop().value</span><br><span class="line">		<span class="keyword">if</span> a.node != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(result) &lt;= a.dept &#123; <span class="comment">//小于层数</span></span><br><span class="line">				temp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">				temp = <span class="built_in">append</span>(temp, a.node.Val)</span><br><span class="line">				result = <span class="built_in">append</span>(result, temp)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				result[a.dept] = <span class="built_in">append</span>(result[a.dept], a.node.Val)</span><br><span class="line">			&#125;</span><br><span class="line">			query.Put(&amp;AnnotatedNode&#123;a.node.Left, a.dept + <span class="number">1</span>, <span class="number">0</span>&#125;)</span><br><span class="line">			query.Put(&amp;AnnotatedNode&#123;a.node.Right, a.dept + <span class="number">1</span>, <span class="number">0</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> result &#123;</span><br><span class="line">		<span class="keyword">if</span> k%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">			result[k] = stringReverse(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringReverse</span><span class="params">(src []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> src == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;the src can&#x27;t be empty!&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	count := <span class="built_in">len</span>(src)</span><br><span class="line">	mid := count / <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; mid; i++ &#123;</span><br><span class="line">		tmp := src[i]</span><br><span class="line">		src[i] = src[count<span class="number">-1</span>]</span><br><span class="line">		src[count<span class="number">-1</span>] = tmp</span><br><span class="line">		count--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> src</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转memos</title>
    <url>/2023/11/26/%E7%8E%A9%E8%BD%ACmemos/</url>
    <content><![CDATA[<p>memos 是一个开源的，类似flomo 的 笔记服务，同时支持，微信小程序、Obsidian、logseq 等效率工具的联动，可玩性比较好。</p>
<span id="more"></span>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><p>memos 官方提供docker，所以只需要再任意一台有安装docker 的机器上就可以安装运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name memos -p 5230:5230 -v ~/.memos/:/var/opt/memos ghcr.io/usememos/memos:latest</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  memos:</span><br><span class="line">    image: ghcr.io/usememos/memos:latest</span><br><span class="line">    container_name: memos</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">5230</span>:<span class="number">5230</span></span><br><span class="line">    volumes:</span><br><span class="line">      - ~/.memos/:/var/opt/memos</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>

<p>其中<code>~/.memos/</code> sqllite 等数据文件的目录，可以指定成任意的目录。<br>这样memos 就能搭建了，通过 <a href="http://127.0.0.1:5230/">http://127.0.0.1:5230</a> 就可以访问了。<br>效果如下<br><img src="https://images.hxzhouh.com/blog-images/2023/11/a0575a5f76c15cfde90390fff6fc5595.png"></p>
<h3 id="启用-https"><a href="#启用-https" class="headerlink" title="启用 https"></a>启用 https</h3><p>为了安全可以nginx + dns 解析 支持https。这里不展开，可以参考 其他博客或者<a href="https://hexo.hxzhouh.com/2023/09/23/%E5%9C%A8VPS%E4%B8%8A%E6%90%AD%E5%BB%BAvaultwarden/">在VPS上搭建vaultwarden</a>，我的配置是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">                listen 443 ssl;</span><br><span class="line">                server_name memos.hxzhouh.com;</span><br><span class="line"></span><br><span class="line">                ssl_certificate /etc/nginx/cert/public.pem;</span><br><span class="line">                ssl_certificate_key /etc/nginx/cert/private.key;</span><br><span class="line">                #ssl_certificate /path/to/your/ssl_certificate.pem; # 您的 SSL 证书路径</span><br><span class="line">                #ssl_certificate_key /path/to/your/ssl_certificate_key.key; # 您的 SSL 密钥路径</span><br><span class="line">                location / &#123;</span><br><span class="line">                        proxy_pass http://127.0.0.1:5230/;</span><br><span class="line">                        rewrite ^/(.*)$ /$1 break;</span><br><span class="line">                        proxy_redirect off;</span><br><span class="line">                        proxy_set_header Host $host;</span><br><span class="line">                        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">                        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                        proxy_set_header Upgrade-Insecure-Requests 1;</span><br><span class="line">                        proxy_set_header X-Forwarded-Proto https;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><p>数据备份，可以使用<code>rclone</code> 工具，备份<code>~/.memos/</code> 目录，或者直接使用 memos 提供的将数据存储到S3</p>
<h2 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h2><h3 id="打通-Obsidian"><a href="#打通-Obsidian" class="headerlink" title="打通 Obsidian"></a>打通 Obsidian</h3><h3 id="打通微信"><a href="#打通微信" class="headerlink" title="打通微信"></a>打通微信</h3><p>打通微信是用一个小程序实现的，具体可以参考这个项目**<a href="https://github.com/Rabithua/memos_wmp">memos_wmp</a>**<br>但是，我没有已经备案的域名，所以这步就放弃了。</p>
<h3 id="raycast"><a href="#raycast" class="headerlink" title="raycast"></a>raycast</h3><p>raycast 支持 memos <a href="https://www.raycast.com/JakeYu/memos">插件</a>，可以很方便的在raycast中使用 memos</p>
<h3 id="telegram"><a href="#telegram" class="headerlink" title="telegram"></a>telegram</h3><p>支持telegram转发消息保存到memos 中，参考这个<a href="https://www.usememos.com/docs/integration/telegram-bot">Integration with Telegram Bot</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>memos</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊Redis  链表</title>
    <url>/2022/09/30/%E8%81%8A%E8%81%8ARedis%20%20%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>链表提供了高效的节点重排能力， 以及顺序性的节点访问方式， 并且可以通过增删节点来灵活地调整链表的长度。</p>
<p>链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现。</p>
<span id="more"></span>

<p>由于C语言自身没有链表的实现，redis 自定定义了一套链表的实现</p>
<h1 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h1><p>每个链表节点使用一个 <code>adlist.h/listNode</code> 结构来表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个 <code>listNode</code> 可以通过 <code>prev</code> 和 <code>next</code> 指针组成双端链表</p>
<img src="https://blog-image-1253555052.cos.ap-guangzhou.myqcloud.com/20200316215937.png" alt="链表" style="zoom:200%;" />

<p>redis 还有一个数据结构来简化链表的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ypedef <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p><code>list</code> 结构为链表提供了表头指针 <code>head</code> 、表尾指针 <code>tail</code> ， 以及链表长度计数器 <code>len</code> ， 而 <code>dup</code> 、 <code>free</code> 和 <code>match</code> 成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li><code>dup</code> 函数用于复制链表节点所保存的值；</li>
<li><code>free</code> 函数用于释放链表节点所保存的值；</li>
<li><code>match</code> 函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p><img src="https://images.hxzhouh.com/blog-images/2024/04/618ef30b166ccdd73141be903aa839b7.png"></p>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端： 链表节点带有 <code>prev</code> 和 <code>next</code> 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 <code>prev</code> 指针和表尾节点的 <code>next</code> 指针都指向 <code>NULL</code> ， 对链表的访问以 <code>NULL</code> 为终点。</li>
<li>带表头指针和表尾指针： 通过 <code>list</code> 结构的 <code>head</code> 指针和 <code>tail</code> 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 <code>list</code> 结构的 <code>len</code> 属性来对 <code>list</code> 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 <code>void*</code> 指针来保存节点值， 并且可以通过 <code>list</code> 结构的 <code>dup</code> 、 <code>free</code> 、 <code>match</code> 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。</li>
<li>每个链表节点由一个 <code>listNode</code> 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。</li>
<li>每个链表使用一个 <code>list</code> 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 <code>NULL</code> ， 所以 Redis 的链表实现是无环链表。</li>
<li>通过为链表设置不同的类型特定函数（指针）， Redis 的链表可以用于保存各种不同类型的值。</li>
</ul>
<p>参考文档：</p>
<ol>
<li>《<a href="http://redisbook.com/preview/adlist/implementation.html">redis 设计与实现</a>》</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊redis sds</title>
    <url>/2022/09/30/%E8%81%8A%E8%81%8Aredis%20sds/</url>
    <content><![CDATA[<p>SDS全拼为：<code>simple dynamic string</code>，解释为：简单动态字符串</p>
<p>​    C语言字符串使用长度为n+1的字符数组来表示长度为n的字符串，并且字符数组的最后一个元素总是空字符’\0’，因为这种字符串表示方式不能满足Redis对字符串在安全性、效率以及功能方面的要求，所以Redis自己构建了SDS，用于满足其需求。在Redis里，C语言字符串只用于一些无须对字符串值进行修改的地方，比如：日志。在Redis中，包含字符串值的键值对都是使用SDS实现的，除此之外，SDS还被用于AOF缓冲区、客户端状态的输入缓冲区。</p>
<span id="more"></span>

<h1 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">     //字节数组</span><br><span class="line">     char buf[]; </span><br><span class="line">     //buf数组中已使用字节数量</span><br><span class="line">     int len;</span><br><span class="line">     //buf数组中未使用字节数量</span><br><span class="line">     int free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../../%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/Typro%20%E6%96%87%E6%A1%A3%E5%BA%93/%E5%9B%BE%E7%89%87/20200313213825.png"></p>
<p>​    上图展示了一个SDS实例，len表示该SDS保存了一个5字节长度（不包含结束符）的字符串，free表示该SDS还有5个字节的未使用空间，buf是一个char类型的数组，保存了该SDS所存储的字符串值</p>
<h1 id="为什么使用SDS"><a href="#为什么使用SDS" class="headerlink" title="为什么使用SDS"></a><strong>为什么使用SDS</strong></h1><h2 id="1-相比C语言字符串，使获取字符串长度时间复杂度降为O-1"><a href="#1-相比C语言字符串，使获取字符串长度时间复杂度降为O-1" class="headerlink" title="1. 相比C语言字符串，使获取字符串长度时间复杂度降为O(1)"></a><strong>1. 相比C语言字符串，使获取字符串长度时间复杂度降为O(1)</strong></h2><p>​    C语言字符串不记录自身长度，如果想获取自身长度必须遍历整个字符串，对每个字符进行计数，这个操作时间复杂度是O(n)。相比较而言，Redis程序只要访问SDS的len属性就可以直接获取到字符串长度，时间复杂度为O(1)，确保获取字符串长度不会成为Redis性能瓶颈，比如对字符串键反复执行strlen命令。如：获取“Redis”字符串长度时程序会直接访问len属性即可，该字符串长度为5。</p>
<h2 id="2-杜绝缓冲区溢出"><a href="#2-杜绝缓冲区溢出" class="headerlink" title="2. 杜绝缓冲区溢出"></a><strong>2. 杜绝缓冲区溢出</strong></h2><p>​    假设程序里有两个在内存中紧邻的字符串s1和s2，s1的值为Redis，底层数组的值为[‘R’,’e’,’d’,’i’,’s’,’\0’]，s2的值为Memcache，底层数组的值为[‘M’,’e’,’m’,’c’,’a’,’c’,’h’,’e’,’\0’]，在C语言中如果要执行strcat(s1, “ cluster”)把s1修改为Redis cluster，如果忘记在执行strcat命令之前为s1重新分配空间，那么在执行完strcat命令之后，s1底层数组的值变为[‘R’,’e’,’d’,’i’,’s’,’ ‘,’c’,’l’,’u’,’s’,’t’,’e’,’r’,’\0’]，s2底层数组的值变为[‘c’,’l’,’u’,’s’,’t’,’e’,’r’,’\0’,’\0’]，s1的数据溢出到s2所在的内存空间，s2的值被意外修改。与C语言不同，当SDS API需要对SDS进行修改时，API会先检查SDS当前剩余空间是否满足修改之后所需的空间，如果不满足的话API会自动将SDS的空间扩展至修改之后所需空间大小，然后再执行实际的修改操作，所以SDS不会出现缓冲区溢出问题。（缓冲区扩充并非是直接扩充到所需要的空间大小，它和SDS空间分配策略有关，参见下一小节）</p>
<h2 id="3-减少修改字符串时带来的内存重分配次数"><a href="#3-减少修改字符串时带来的内存重分配次数" class="headerlink" title="3. 减少修改字符串时带来的内存重分配次数"></a><strong>3. 减少修改字符串时带来的内存重分配次数</strong></h2><p>​    C语言字符串底层是使用一个n+1个字符长度的char类型数据实现的，所以每次增长或缩短一个C语言字符串，程序都要对这个字符串数组进行一次内存重分配操作：</p>
<ol>
<li>如果程序执行的是增长字符串操作，比如strcat操作，在执行这个操作之前需要通过内存重分配扩展底层数组，如果忘记了则会造成缓冲区溢出。</li>
<li>如果程序执行的是缩短字符串操作，比如trim操作，在执行这个操作之前需要通过内存重分配释放字符串不再使用的内存空间，如果忘记了则会造成内存泄漏。</li>
</ol>
<p>​            因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作。Redis经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串都需要执行一次内存重分配的话，那么对于性能会造成很大影响。</p>
<p>​            在SDS中通过未使用空间解除了字符串长度和底层数组长度之间的关联，在SDS中，buf数组长度不一定是字符串长度加1，数组中可能包含未使用的字节，这些字节的数量就是由SDS的free属性记录。通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p>
<h3 id="3-1-空间预分配"><a href="#3-1-空间预分配" class="headerlink" title="3.1 空间预分配"></a><strong>3.1 空间预分配</strong></h3><p>​    用于字符串增长操作，当字符串增长时，程序会先检查需不需要对SDS空间进行扩展，如果需要扩展，程序不仅会为SDS分配修改所必要的空间，还会为SDS分配额外的未使用空间，额外分配的未使用空间公式如下：</p>
<ol>
<li>如果对SDS修改之后，SDS的长度（修改之后len属性的值）小于1MB，那么则分配和len属性同样大小的未使用空间，这时SDS的len属性和free属性的值相同。如：如果修改之后SDS的len将变为10字节，那么程序也会分配10字节的未使用空间，SDS的buf数组实际长度变为10 + 10 + 1 &#x3D; 21（额外一个字节用于保存结束符\n）</li>
<li>如果对SDS修改之后，SDS的长度大于等于1MB，那么程序会分配1MB的未使用空间。如：修改之后的len将变为10MB，那么程序会分配1MB的未使用空间，SDS的bug数组长度为10MB + 1MB + 1byte</li>
</ol>
<h3 id="3-2-惰性空间释放"><a href="#3-2-惰性空间释放" class="headerlink" title="3.2 惰性空间释放"></a><strong>3.2 惰性空间释放</strong></h3><p>​    用于优化SDS的字符串收缩操作，当字符串收缩时，程序不会立即执行内存重分配来回收收缩后内存多出来的空间，而是使用free属性记录下来，以备将来使用。</p>
<p><img src="/../../../%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/Typro%20%E6%96%87%E6%A1%A3%E5%BA%93/%E5%9B%BE%E7%89%87/20200313213934.png"></p>
<p><img src="/../../../%E6%88%91%E7%9A%84%E5%9D%9A%E6%9E%9C%E4%BA%91/Typro%20%E6%96%87%E6%A1%A3%E5%BA%93/%E5%9B%BE%E7%89%87/20200313213920.png"></p>
<p>​    通过空间预分配，Redis可以减少连续执行字符串增长操作所需的内存重分配次数，通过惰性空间释放，SDS避免了缩短字符串时所需的内存重分配操作，并为将来由可能的增长操作提供了优化。</p>
<h3 id="3-3-二进制安全"><a href="#3-3-二进制安全" class="headerlink" title="3.3 二进制安全"></a>3.3 二进制安全</h3><p>C语言的字符串不能使用\0结尾，导致C语言字符串不能保存 图片等二进制数据。</p>
<p>redis 使用字符数组来保存字符串，不会对数据做任何限制、过滤、假设，使得redis兼容性更强。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机中的时间 线程上下文切换会用掉你多少CPU？</title>
    <url>/2024/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%20%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E4%BC%9A%E7%94%A8%E6%8E%89%E4%BD%A0%E5%A4%9A%E5%B0%91CPU%EF%BC%9F/</url>
    <content><![CDATA[<p>进程是操作系统的伟大发明之一，对应用程序屏蔽了CPU调度、内存管理等硬件细节，而抽象出一个进程的概念，让应用程序专心于实现自己的业务逻辑既可，而且在有限的CPU上可以“同时”进行许多个任务。但是它为用户带来方便的同时，也引入了一些额外的开销。如下图，在进程运行中间的时间里，虽然CPU也在忙于干活，但是却没有完成任何的用户工作，这就是进程机制带来的额外开销。  </p>
<span id="more"></span>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/e1fd29a84d212fe4c9161eaa7edda593.png" alt="Pasted image 20240319113416"></p>
<p>在进程A切换到进程B的过程中，先保存A进程的上下文，以便于等A恢复运行的时候，能够知道A进程的下一条指令是啥。然后将要运行的B进程的上下文恢复到寄存器中。这个过程被称为上下文切换。上下文切换开销在进程不多、切换不频繁的应用场景下问题不大。但是现在Linux操作系统被用到了高并发的网络程序后端服务器。在单机支持成千上万个用户请求的时候，这个开销就得拿出来说道说道了。因为用户进程在请求Redis、Mysql数据等网络IO阻塞掉的时候，或者在进程时间片到了，都会引发上下文切换。</p>
<p><img src="https://images.hxzhouh.com/blog-images/2024/03/1412e8c9d5f8d443e04acce317ec68f3.png" alt="Pasted image 20240319112652"></p>
<h1 id="一个简单的进程上下文切换开销测试实验"><a href="#一个简单的进程上下文切换开销测试实验" class="headerlink" title="一个简单的进程上下文切换开销测试实验"></a>一个简单的进程上下文切换开销测试实验</h1><p>废话不多说，我们先用个实验测试一下，到底一次上下文切换需要多长的CPU时间！实验方法是创建两个进程并在它们之间传送一个令牌。其中一个进程在读取令牌时就会引起阻塞。另一个进程发送令牌后等待其返回时也处于阻塞状态。如此往返传送一定的次数，然后统计他们的平均单次切换时间开销。<br><a href="https://gist.github.com/hxzhouh/7c201a16f6dc37068fa9eefae9334b04">test04</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gcc main.c -o main</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./main./main</span></span><br><span class="line">Before Context Switch Time1565352257 s, 774767 us</span><br><span class="line">After Context SWitch Time1565352257 s, 842852 us</span><br></pre></td></tr></table></figure>

<p>每次执行的时间会有差异，多次运行后<strong>平均每次上下文切换耗时3.5us左右</strong>。当然了这个数字因机器而异，而且建议在实机上测试。</p>
<p>前面我们测试系统调用的时候，最低值是200ns。可见，上下文切换开销要比系统调用的开销要大。系统调用只是在进程内将用户态切换到内核态，然后再切回来，而上下文切换可是直接从进程A切换到了进程B。显然这个上下文切换需要完成的工作量更大。</p>
<h1 id="进程上下文切换开销都有哪些"><a href="#进程上下文切换开销都有哪些" class="headerlink" title="进程上下文切换开销都有哪些"></a>进程上下文切换开销都有哪些</h1><p>那么上下文切换的时候，CPU的开销都具体有哪些呢？开销分成两种，一种是直接开销、一种是间接开销。<br>直接开销就是在切换时，cpu必须做的事情，包括：</p>
<ul>
<li>1、&#x3D;&#x3D;切换页表全局目录&#x3D;&#x3D;</li>
<li>2、&#x3D;&#x3D;切换内核态堆栈&#x3D;&#x3D;</li>
<li>3、&#x3D;&#x3D;切换硬件上下文&#x3D;&#x3D;（进程恢复前，必须装入寄存器的数据统称为硬件上下文）<ul>
<li>ip(instruction pointer)：指向当前执行指令的下一条指令</li>
<li>bp(base pointer): 用于存放执行中的函数对应的栈帧的栈底地址</li>
<li>sp(stack poinger): 用于存放执行中的函数对应的栈帧的栈顶地址</li>
<li>cr3:页目录基址寄存器，保存页目录表的物理地址</li>
<li>……</li>
</ul>
</li>
<li>4、刷新TLB</li>
<li>5、系统调度器的代码执行</li>
</ul>
<p>间接开销主要指的是虽然切换到一个新进程后，&#x3D;&#x3D;由于各种缓存并不热，速度运行会慢一些&#x3D;&#x3D;。如果进程始终都在一个CPU上调度还好一些，如果跨CPU的话，之前热起来的TLB、L1、L2、L3因为运行的进程已经变了，所以以局部性原理cache起来的代码、数据也都没有用了，导致新进程穿透到内存的IO会变多。 其实我们上面的实验并没有很好地测量到这种情况，所以实际的上下文切换开销可能比3.5us要大。<br>想了解更详细操作过程的同学请参考《深入理解Linux内核》中的第三章和第九章。</p>
<h2 id="一个更为专业的测试工具-lmbench"><a href="#一个更为专业的测试工具-lmbench" class="headerlink" title="一个更为专业的测试工具-lmbench"></a>一个更为专业的测试工具-lmbench</h2><p>lmbench用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能。使用方法简单，但就是跑有点慢，感兴趣的同学可以自己试一试。<br>这个工具的优势是是进行了多组实验，每组2个进程、8个、16个。每个进程使用的数据大小也在变，充分模拟cache miss造成的影响。我用他测了一下结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Host                 OS  2p/0K 2p/16K 2p/64K 8p/16K 8p/64K 16p/16K 16p/64K  </span><br><span class="line">                         ctxsw  ctxsw  ctxsw ctxsw  ctxsw   ctxsw   ctxsw  </span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------ ------- -------  </span><br><span class="line">bjzw_46_7 Linux 2.6.32- 2.7800 2.7800 2.7000 4.3800 4.0400 4.75000 5.48000</span><br></pre></td></tr></table></figure>

<p>lmbench显示的进程上下文切换耗时从2.7us到5.48之间。</p>
<h1 id="线程上下文切换耗时"><a href="#线程上下文切换耗时" class="headerlink" title="线程上下文切换耗时"></a>线程上下文切换耗时</h1><p>前面我们测试了进程上下文切换的开销，我们再继续在Linux测试一下线程。看看究竟比进程能不能快一些，快的话能快多少。</p>
<p>在Linux下其实本并没有线程，只是为了迎合开发者口味，搞了个轻量级进程出来就叫做了线程。轻量级进程和进程一样，都有自己独立的task_struct进程描述符，也都有自己独立的pid。从操作系统视角看，调度上和进程没有什么区别，都是在等待队列的双向链表里选择一个task_struct切到运行态而已。只不过轻量级进程和普通进程的区别是可以共享同一内存地址空间、代码段、全局变量、同一打开文件集合而已。</p>
<blockquote>
<p>同一进程下的线程之所有getpid()看到的pid是一样的，其实task_struct里还有一个tgid字段。 对于多线程程序来说，getpid()系统调用获取的实际上是这个tgid，因此隶属同一进程的多线程看起来PID相同。</p>
</blockquote>
<p>我们用一个实验来测试一下<a href="https://www.jianshu.com/p/0d90b92000c0">test06</a>。其原理和进程测试差不多，创建了20个线程，在线程之间通过管道来传递信号。接到信号就唤醒，然后再传递信号给下一个线程，自己睡眠。 这个实验里单独考虑了给管道传递信号的额外开销，并在第一步就统计了出来。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># gcc -lpthread <span class="selector-tag">main</span><span class="selector-class">.c</span> -o <span class="selector-tag">main</span></span><br><span class="line"><span class="number">0.508250</span>  </span><br><span class="line"><span class="number">4.363495</span></span><br></pre></td></tr></table></figure>

<p>每次实验结果会有一些差异，上面的结果是取了多次的结果之后然后平均的，大约每次线程切换开销大约是3.8us左右。<strong>从上下文切换的耗时上来看，Linux线程（轻量级进程）其实和进程差别不太大</strong>。</p>
<h2 id="Linux相关命令"><a href="#Linux相关命令" class="headerlink" title="Linux相关命令"></a>Linux相关命令</h2><p>既然我们知道了上下文切换比较的消耗CPU时间，那么我们通过什么工具可以查看一下Linux里究竟在发生多少切换呢？如果上下文切换已经影响到了系统整体性能，我们有没有办法把有问题的进程揪出来，并把它优化掉呢？</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># vmstat 1  </span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----  </span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st  </span><br><span class="line"> 2  0      0 595504   5724 190884    0    0   295   297    0    0 14  6 75  0  4  </span><br><span class="line"> 5  0      0 593016   5732 193288    0    0     0    92 19889 29104 20  6 67  0  7  </span><br><span class="line"> 3  0      0 591292   5732 195476    0    0     0     0 20151 28487 20  6 66  0  8  </span><br><span class="line"> 4  0      0 589296   5732 196800    0    0   116   384 19326 27693 20  7 67  0  7  </span><br><span class="line"> 4  0      0 586956   5740 199496    0    0   216    24 18321 24018 22  8 62  0  8</span><br></pre></td></tr></table></figure>
<p>或者是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sar -w 1  </span></span><br><span class="line">proc/s  </span><br><span class="line">     Total number of tasks created per second.  </span><br><span class="line">cswch/s  </span><br><span class="line">     Total number of context switches per second.  </span><br><span class="line">11:19:20 AM    proc/s   cswch/s  </span><br><span class="line">11:19:21 AM    110.28  23468.22  </span><br><span class="line">11:19:22 AM    128.85  33910.58  </span><br><span class="line">11:19:23 AM     47.52  40733.66  </span><br><span class="line">11:19:24 AM     35.85  30972.64  </span><br><span class="line">11:19:25 AM     47.62  24951.43  </span><br><span class="line">11:19:26 AM     47.52  42950.50  </span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>上图的环境是一台生产环境机器，配置是8核8G的KVM虚机，环境是在nginx+fpm的，fpm数量为1000，平均每秒处理的用户接口请求大约100左右。其中<strong>cs列</strong>表示的就是在1s内系统发生的上下文切换次数，大约1s切换次数都达到4W次了。粗略估算一下，每核大约每秒需要切换5K次，则1s内需要花将近20ms在上下文切换上。要知道这是虚机，本身在虚拟化上还会有一些额外开销，而且还要真正消耗CPU在用户接口逻辑处理、系统调用内核逻辑处理、以及网络连接的处理以及软中断，所以20ms的开销实际上不低了。<br>那么进一步，我们看下到底是哪些进程导致了频繁的上下文切换？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pidstat -w 1  </span></span><br><span class="line">11:07:56 AM       PID   cswch/s nvcswch/s  Command</span><br><span class="line">11:07:56 AM     32316      4.00      0.00  php-fpm  </span><br><span class="line">11:07:56 AM     32508    160.00     34.00  php-fpm  </span><br><span class="line">11:07:56 AM     32726    131.00      8.00  php-fpm  </span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>由于fpm是同步阻塞的模式，每当请求Redis、Memcache、Mysql的时候就会阻塞导致cswch&#x2F;s自愿上下文切换，而只有时间片到了之后才会触发nvcswch&#x2F;s非自愿切换。可见fpm进程大部分的切换都是自愿的、非自愿的比较少。</p>
<p>如果想查看具体某个进程的上下文切换总情况，可以在&#x2F;proc接口下直接看，不过这个是总值。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">grep ctxt /proc/32583/status  </span><br><span class="line">voluntary_ctxt_switches:        573066  </span><br><span class="line">nonvoluntary_ctxt_switches:     89260</span><br></pre></td></tr></table></figure>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul>
<li>上下文切换具体做哪些事情我们没有必要记，只需要记住一个结论既可，在我的工作机<strong>上下文切换的开销大约是2.7-5.48us左右</strong>，你自己的机器可以用我提供的代码或工具进行一番测试。</li>
<li>可以使用 <code>vmstat</code> <code>sar</code> 等工具查看进程的上下文切换，进而定位性能问题。</li>
<li>lmbench相对更准确一些，因为考虑了切换后Cache miss导致的额外开销。</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS 0914-0920</title>
    <url>/2023/09/21/arts/ARTS%200914-0920/</url>
    <content><![CDATA[<p>RTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。</p>
<blockquote>
<p>每人每周写一个 ARTS：</p>
<p>Algorithm 是一道算法题，</p>
<p>Review 是读一篇英文文章，</p>
<p>Technique&#x2F;Tips 是分享一个小技术，</p>
<p>Share 是分享一个观点。</p>
</blockquote>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm:"></a>Algorithm:</h1><p>leetCode: </p>
<p>82</p>
<p>83</p>
<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><ul>
<li><a href="https://blog.pixielabs.ai/blog/ebpf-function-tracing/post/">https://blog.pixielabs.ai/blog/ebpf-function-tracing/post/</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>arts</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-38</title>
    <url>/2023/09/22/arts/ARTS-2023-38/</url>
    <content><![CDATA[<h1 id="ARTS-2023-38"><a href="#ARTS-2023-38" class="headerlink" title="ARTS-2023-38"></a>ARTS-2023-38</h1><blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS： Algorithm 是一道算法题， Review 是读一篇英文文章， Technique&#x2F;Tips 是分享一个小技术， Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><hr>
<p>#算法 #leetcode</p>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150">leetCode 122  </a><br>用[[动态规划]]  来做这个题目</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> (ans <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        ans += max(<span class="number">0</span>, prices[i]-prices[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[[55. 跳跃游戏]]</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><hr>
<p>#好文 #阅读</p>
<p><a href="https://go.googlesource.com/proposal/+/master/design/11502-securitypolicy.md">https://go.googlesource.com/proposal/+/master/design/11502-securitypolicy.md</a></p>
<p>最近开始看 go 的一些设计文档， 考古的， 新的都看，看着现在一些熟悉的东西以前是怎么被设计出来的， 很有意思</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><hr>
<p>#工具  </p>
<p>[[omnivore]] 一个开源的稍后阅读软件，有点类似readwise 的reader，目前属于起步阶段把，有活跃的开发圈子，会一直关注这个软件。</p>
<ul>
<li><a href="https://linux.cn/article-16102-1.html">https://linux.cn/article-16102-1.html</a></li>
<li><a href="https://blog.omnivore.app/p/getting-started-with-omnivore">https://blog.omnivore.app/p/getting-started-with-omnivore</a></li>
</ul>
<p>一键屏蔽Twitter上的 黄推，受够了。。<br><a href="https://github.com/daymade/Twitter-Block-Porn">https://github.com/daymade/Twitter-Block-Porn</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><hr>
<p>#碎碎念 #观点</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>arts</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-39</title>
    <url>/2023/09/27/arts/ARTS-2023-39/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS： Algorithm 是一道算法题， Review 是读一篇英文文章， Technique&#x2F;Tips 是分享一个小技术， Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><hr>
<h2 id="算法-leetcode本周放假前一周，比较颓废，很多都没完成。-Review"><a href="#算法-leetcode本周放假前一周，比较颓废，很多都没完成。-Review" class="headerlink" title="#算法 #leetcode本周放假前一周，比较颓废，很多都没完成。## Review"></a>#算法 #leetcode<br>本周放假前一周，比较颓废，很多都没完成。<br>## Review</h2><p>#好文 #阅读</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><hr>
<p>#工具  </p>
<ol>
<li>在本地生成测试证书。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先，生成一个RSA私钥文件（`server.key`）：</span></span><br><span class="line">openssl genpkey -algorithm RSA -out server.key</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">接下来，生成一个自签名证书请求（CSR）：</span></span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在执行此命令时，您将被要求提供一些证书信息，例如国家、州、城市、公司等。您可以根据需要提供这些信息，或者按照默认值留空。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">现在，使用生成的私钥和证书请求来生成自签名证书：</span></span><br><span class="line">openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</span><br></pre></td></tr></table></figure>
如果这个证书再浏览器里面显示不安全，可以尝试信任本地证书</li>
</ol>
<blockquote>
<ol>
<li>打开Chrome浏览器。  </li>
<li>在地址栏中输入 <code>chrome://flags/#allow-insecure-localhost/</code> 并按 Enter 键。  </li>
<li>找到并启用 “Allow invalid certificates for resources loaded from localhost” 选项。 </li>
<li>重新启动Chrome浏览器。<br><img src="https://images.hxzhouh.com/blog-images/2023/09/c72bb8fc1990bb18c394ae237d8b4ad9.png" alt="image.png"></li>
</ol>
</blockquote>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><hr>
<p>#碎碎念 #观点</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-40</title>
    <url>/2023/10/02/arts/ARTS-2023-40/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS： Algorithm 是一道算法题， Review 是读一篇英文文章， Technique&#x2F;Tips 是分享一个小技术， Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>#算法 #leetcode</p>
<ol>
<li><a href="https://leetcode.cn/problems/excel-sheet-column-title/">168. Excel表列名称</a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToTitle</span><span class="params">(columnNumber <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> res <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> columnNumber &gt; <span class="number">0</span> &#123;</span><br><span class="line">	columnNumber-- <span class="comment">// 0-25</span></span><br><span class="line">	res = <span class="type">string</span>(<span class="type">rune</span>(columnNumber%<span class="number">26</span>+<span class="string">&#x27;A&#x27;</span>)) + res</span><br><span class="line">	columnNumber /= <span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
就是把 int 转26进制，辗转相除法？ 好像是这个名字把？</li>
</ol>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><h2 id="好文-阅读1-https-buildkite-com-blog-goodbye-integers-hello-uuids使用uuid-作为数据库的主键Id，兼顾性能以及可用性，mongodb-的-uuid-前八位是时间戳，可以用来进行范围查询。-Technique-Tips"><a href="#好文-阅读1-https-buildkite-com-blog-goodbye-integers-hello-uuids使用uuid-作为数据库的主键Id，兼顾性能以及可用性，mongodb-的-uuid-前八位是时间戳，可以用来进行范围查询。-Technique-Tips" class="headerlink" title="#好文 #阅读1. https://buildkite.com/blog/goodbye-integers-hello-uuids使用uuid 作为数据库的主键Id，兼顾性能以及可用性，mongodb 的 uuid 前八位是时间戳，可以用来进行范围查询。## Technique&#x2F;Tips"></a>#好文 #阅读<br>1. <a href="https://buildkite.com/blog/goodbye-integers-hello-uuids">https://buildkite.com/blog/goodbye-integers-hello-uuids</a><br>使用uuid 作为数据库的主键Id，兼顾性能以及可用性，<br>mongodb 的 uuid 前八位是时间戳，可以用来进行范围查询。<br>## Technique&#x2F;Tips</h2><p>#工具  </p>
<ol>
<li>#浏览器插件 <a href="https://www.trancy.org/zh-cn">trancy</a> 一个沉浸式的翻译插件，集成了ai功能，目前这种插件越来越多了。</li>
</ol>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>#碎碎念 #观点</p>
<ol>
<li>我要坚持写长文博客。。</li>
<li>看到好看的博客，还是要收藏起来，我的记忆力应该只有七秒。</li>
</ol>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS 0907-0913</title>
    <url>/2022/09/30/arts/ARTS%200907-0913/</url>
    <content><![CDATA[<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。</p>
<blockquote>
<p>每人每周写一个 ARTS：</p>
<p>Algorithm 是一道算法题，</p>
<p>Review 是读一篇英文文章，</p>
<p>Technique&#x2F;Tips 是分享一个小技术，</p>
<p>Share 是分享一个观点。</p>
</blockquote>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm:"></a>Algorithm:</h1><ul>
<li>leetcode <a href="https://leetcode-cn.com/problems/reverse-linked-list/">206 </a></li>
<li>leetcode <a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/">141</a></li>
<li>leetcode 19</li>
</ul>
<h1 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h1><p><a href="https://tech.meituan.com/2020/08/13/openstack-to-kubernetes-in-meituan.html">Kubernetes如何改变美团的云基础设施？</a></p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>arts</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-41</title>
    <url>/2023/10/09/arts/ARTS-2023-41/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS： Algorithm 是一道算法题， Review 是读一篇英文文章， Technique&#x2F;Tips 是分享一个小技术， Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>#算法 #leetcode<br>leetcod 344 翻转字符串 水了一道题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="type">byte</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;  </span><br><span class="line">       s[i], s[j] = s[j], s[i]  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString1</span><span class="params">(s []<span class="type">byte</span>)</span></span> &#123;  </span><br><span class="line">    l := <span class="number">0</span>  </span><br><span class="line">    r := <span class="built_in">len</span>(s) - <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;  </span><br><span class="line">       s[l] ^= s[r]  </span><br><span class="line">       s[r] ^= s[l]  </span><br><span class="line">       s[l] ^= s[r]  </span><br><span class="line">       r--  </span><br><span class="line">       l++  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>#好文 #阅读<br><a href="https://xargin.com/misc/">https://xargin.com/misc/</a>  曹大的文章，</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#工具  </p>
<p>分享一个命令。用来查日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat log.2023-10-13-15 |grep ERROR |grep &quot;.onEventWithoutMerge:93&quot; |awk -F&#x27;reqid&#x27; &#x27;&#123;print $2&#125;&#x27; |awk &#x27;&#123;print $1&#125;&#x27; |xargs -P 4 -I &#123;&#125; grep &#123;&#125; log.2023-10-13-15 &gt;allerr.log</span><br></pre></td></tr></table></figure>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>#碎碎念 #观点</p>
<p>再我司工作，觉得效率是没用的，绝大多数工作，都是很简单的基本工作。但是，这种情况能持续多久？还是要重视效率起来。</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-42</title>
    <url>/2023/10/16/arts/ARTS-2023-42/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>#算法 #leetcode  </p>
<ol>
<li>leetcode 45 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    length := <span class="built_in">len</span>(nums)  </span><br><span class="line">    end := <span class="number">0</span>  </span><br><span class="line">    maxPosition := <span class="number">0</span>  </span><br><span class="line">    steps := <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length<span class="number">-1</span>; i++ &#123;  </span><br><span class="line">       maxPosition = max(maxPosition, i+nums[i])  </span><br><span class="line">       <span class="keyword">if</span> i == end &#123;  </span><br><span class="line">          end = maxPosition  </span><br><span class="line">          steps++  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> steps  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>#好文 #阅读<br><a href="https://substack.com/redirect/5c83001c-e5fb-4213-8871-41e93c28dfb1?j=eyJ1IjoibHNxdmoifQ.3oGmLofndxScvklxajPKu05xrXKSE0fYF651WfgCv6U">如何做出伟大的工作？</a> </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <a href="things:///show?id=NU7XfixHt1ewVSJ3hXEteZ">阅读</a> ✅ 2023-11-08<br><a href="https://www.brendangregg.com/linuxperf.html">Linux Performance</a></li>
</ul>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#工具  </p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>#碎碎念 #观点</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-43</title>
    <url>/2023/10/23/arts/ARTS-2023-43/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<p>本周再备考以及交接的事情，arts 基本上都搁置了。。。。。 🤔</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>#算法 #leetcode</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>#好文 #阅读</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#工具  </p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>#碎碎念 #观点</p>
<p>最后，我想说有时候笨办法才是最聪明的，慢慢来才是最快的。读文档不一定能直接给我们生活的最优解，但是他能让我们趋近于知道最优解的路径。生活就像一场冒险，也许文档就是我们手中的地图和指南针。  慢慢来不着急，时间还很长。</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-44</title>
    <url>/2023/10/30/arts/ARTS-2023-44/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>#算法 #leetcode</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>#好文 #阅读<br><a href="https://github.com/ZachGoldberg/Startup-CTO-Handbook">https://github.com/ZachGoldberg/Startup-CTO-Handbook</a>  </p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#工具  </p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>#碎碎念 #观点</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-45</title>
    <url>/2023/11/06/arts/ARTS-2023-45/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>#算法 #leetcode</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>#好文 #阅读</p>
<p><a href="http://pf.bigpixel.cn/zh-CN/city/1.html">http://pf.bigpixel.cn/zh-CN/city/1.html</a><br>一个挺有趣的网站，用千亿像素看世界各个城市<br><a href="https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55">60000 毫秒 Linux 性能分析</a><br>这篇文章介绍了在 60 秒内分析 Linux 性能问题的方法。作者首先介绍了一些基本的性能指标，包括 CPU 使用率、内存使用率、网络流量和 I&#x2F;O 操作。然后，作者介绍了一些用于监控这些指标的工具，包括 top、htop、vmstat、iostat 和 netstat。</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#工具<br>批量重命名 文件后缀</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for file in *.md; do mv &quot;$file&quot; &quot;$&#123;file%.md&#125;.txt&quot;; done</span><br></pre></td></tr></table></figure>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>#碎碎念 #观点</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-47</title>
    <url>/2023/11/20/arts/ARTS-2023-47/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h3 id="leetcode-383"><a href="#leetcode-383" class="headerlink" title="leetcode 383"></a>leetcode 383</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canConstruct</span><span class="params">(ransomNote <span class="type">string</span>, magazine <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    h := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)  </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> magazine &#123;  </span><br><span class="line">       h[v-<span class="string">&#x27;a&#x27;</span>]++  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> ransomNote &#123;  </span><br><span class="line">       <span class="keyword">if</span> h[v-<span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> &#123;  </span><br><span class="line">          h[v-<span class="string">&#x27;a&#x27;</span>]--  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="49"><a href="#49" class="headerlink" title="49"></a>49</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupAnagrams</span><span class="params">(strs []<span class="type">string</span>)</span></span> [][]<span class="type">string</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    r := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>, <span class="number">1000</span>)  </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> strs &#123;  </span><br><span class="line">       key := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">26</span>, <span class="number">26</span>)  </span><br><span class="line">       <span class="keyword">for</span> _, v1 := <span class="keyword">range</span> v &#123;  </span><br><span class="line">          key[v1-<span class="string">&#x27;a&#x27;</span>]++  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> _, ok := r[<span class="type">string</span>(key)]; ok &#123;  </span><br><span class="line">          r[<span class="type">string</span>(key)] = <span class="built_in">append</span>(r[<span class="type">string</span>(key)], v)  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          r[<span class="type">string</span>(key)] = []<span class="type">string</span>&#123;v&#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    result := [][]<span class="type">string</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> r &#123;  </span><br><span class="line">       result = <span class="built_in">append</span>(result, v)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>1.<a href="https://medium.com/gitconnected/awesome-terminal-applications-e4a06022dffa"> Awesome Terminal Applications</a><br>    基于mac 系统，介绍了终端工具，看上去蛮酷的，目前再用 tldr</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#浏览器插件 <strong><a href="https://chromewebstore.google.com/detail/egejbknaophaadmhijkepokfchkbnelc?hl=en">Medium Parser</a> - 一个用于查看 Medium 付费文章的浏览器插件</strong>它的原理是通过 Google Web 缓存查看 Medium 付费文章。</p>
<h3 id="linux-sar"><a href="#linux-sar" class="headerlink" title="#linux sar"></a>#linux sar</h3><p><strong>sar命令</strong> 是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小。<br>它提供了一下的选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-A: 显示所有的报告信息；</span><br><span class="line">-b: 显示I/O速率；</span><br><span class="line">-B: 显示换页状态；</span><br><span class="line">-c: 显示进程创建活动；</span><br><span class="line">-d: 显示每个块设备的状态；</span><br><span class="line">-e: 设置显示报告的结束时间；</span><br><span class="line">-f: 从指定文件提取报告；</span><br><span class="line">-i: 设状态信息刷新的间隔时间；</span><br><span class="line">-n: 报告网络统计信息。</span><br><span class="line">-P: 报告每个CPU的状态；</span><br><span class="line">-R: 显示内存状态；</span><br><span class="line">-u: 显示CPU利用率；</span><br><span class="line">-v: 显示索引节点，文件和其他内核表的状态；</span><br><span class="line">-w: 显示交换分区状态；</span><br><span class="line">-x: 显示给定进程的状态。</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-r: 以分页方式显示输出，每页最多显示 100 行。 </span><br><span class="line">-o: 输出选项，指定要显示的列。例如，`-o mrk,prt,cvg` 将显示 CPU 使用率、进程标识符、磁盘使用率 和 网络流量。 </span><br><span class="line">-t: 时间戳选项，指定要在输出中添加时间戳。 </span><br><span class="line">-s: 统计选项，指定要显示的统计数据的类型。例如，`-s us,ms` 将显示 CPU 使用率的 us 和 ms 时间段的平均值。 </span><br><span class="line">-c: 选项用于指定要发送的命令。例如，`-c ls` 将显示当前目录中的文件和子目录列表。</span><br></pre></td></tr></table></figure>
<p>使用实例：<br>sar 可以用来观测很多 比较细致的指标，比如：</p>
<ol>
<li>查看系统当前的网络吞吐量和 PPS <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数字1表示每隔1秒输出一组数据</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sar -n DEV 1</span></span><br><span class="line">Linux 4.15.0-1035 (ubuntu)   01/06/19   _x86_64_  (2 CPU)</span><br><span class="line"></span><br><span class="line">13:21:40        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">13:21:41         eth0     18.00     20.00      5.79      4.25      0.00      0.00      0.00      0.00</span><br><span class="line">13:21:41      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">13:21:41           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包 / 秒。</span><br><span class="line">rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/ 秒。</span><br><span class="line">rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包 / 秒。</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">ifutil 是网络接口的使用率，即半双工模式下为 (rxkB/s+txkB/s)/Bandwidth，而全双工模式下为 max(rxkB/s, txkB/s)/Bandwidth。</span></span><br></pre></td></tr></table></figure>

<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>#go101 log.fatal 调用的是os.exit（）defer 不会生效。<br>![[Pasted image 20231122202715.png]]<br>#go101  数据的发送者，才能决定channel 什么时候关闭。</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>atrs</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-46</title>
    <url>/2023/11/13/arts/ARTS-2023-46/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>#算法 #leetcode</p>
<ol>
<li><a href="https://leetcode.cn/problems/roman-to-integer/description/?envType=study-plan-v2&envId=top-interview-150">leetcode 13 </a><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> symbolValues = <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>&#123;<span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;L&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">100</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;M&#x27;</span>: <span class="number">1000</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 正常来说，取出每个字符对应的值，然后判断前后大小，如果前面的比后面的小，那么就是减去前面的值，否则就是加上前面的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(s)</span><br><span class="line">	ans := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		value := symbolValues[s[i]]</span><br><span class="line">		<span class="keyword">if</span> i &lt; n<span class="number">-1</span> &amp;&amp; value &lt; symbolValues[s[i+<span class="number">1</span>]] &#123;</span><br><span class="line">			ans -= value</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ans += value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>学习资料::<a href="https://braydie.gitbooks.io/how-to-be-a-programmer/content/zh/"># How to be a Programmer 中文版</a></p>
<p>#好文 #阅读</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#工具  </p>
<ol>
<li>Microsoft InShellisense插件<br><a href="https://github.com/microsoft/inshellisense">inshellisense</a> 为 shell 提供 IDE 风格的自动完成功能。它是一个用于自动完成的终端本机运行时，支持 600 多个命令行工具。 inshellisense 支持 Windows、Linux 和 MacOS。</li>
</ol>
<p>这个插件 需要适应一下，哈哈，对以前的一些习惯侵入蛮大的。<br> 2. git删除没被跟踪的 文件<br> git clean -f -d -x  git 删除 没被跟踪的文件，有时候有用把。比如频繁切换分支。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>#碎碎念 #观点</p>
<ol>
<li>昨晚（2023-11-12） 阿里云故障了，当时在做饭，听到这个事情后，觉得不可思议，后面有哈哈大笑，嘲讽max，到了今天，感觉我有什么资格笑的出来，阿里云已经很伟大了，我能写出这样的系统？不过还是得出下面的教训<ol>
<li>云不是万能的，云也很贵。</li>
<li>保持敬畏。</li>
</ol>
</li>
<li>本周读完了《代码整洁之道：程序员的职业素养》慢慢的回到了正常的节奏了，看书写文字，Obsidian的摸索也开始有点门道了，一切开始慢慢的好转。<a href=""></a></li>
</ol>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>好文</tag>
        <tag>阅读</tag>
        <tag>工具</tag>
        <tag>碎碎念</tag>
        <tag>观点</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-48</title>
    <url>/2023/11/27/arts/ARTS-2023-48/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://www.riverphillips.dev/blog/go-cfs">https://www.riverphillips.dev/blog/go-cfs</a> 一个老生常谈的问题， GOMAXPROCS 的设置。</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>使用 <a href="https://github.com/Yidadaa/ChatGPT-Next-Web">ChatGPT-Next-Web</a> +<a href="https://www.gptapi.us/"> gptapi</a> 搭建了一个镜像站，看能活多久把。</p>
<iframe allow="autoplay *; encrypted-media *; fullscreen *; clipboard-write" frameborder="0" height="450" style="width:100%;max-width:660px;overflow:hidden;border-radius:10px;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://embed.music.apple.com/cn/playlist/vol-1000-%E5%9C%A8%E6%97%B6%E5%85%89%E5%8F%98%E5%B9%BB%E4%B8%AD%E6%B0%B8%E4%B8%8D%E5%A4%B1%E5%8E%BB/pl.u-RRbV0gVCmgNxNDx"></iframe>

<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
      <categories>
        <category>arts</category>
      </categories>
  </entry>
  <entry>
    <title>ARTS-2023-49</title>
    <url>/2023/12/04/arts/ARTS-2023-49/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>继续在做二叉树的题目。<br>leetcode 97: 中序遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> []<span class="type">int</span>&#123;root.Val&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    result := []<span class="type">int</span>&#123;&#125;  </span><br><span class="line">    result = <span class="built_in">append</span>(result, inorderTraversal(root.Left)...)  </span><br><span class="line">    result = <span class="built_in">append</span>(result, root.Val)  </span><br><span class="line">    result = <span class="built_in">append</span>(result, inorderTraversal(root.Right)...)  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leetcode 173: 也是中序遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> BSTIterator <span class="keyword">struct</span> &#123;  </span><br><span class="line">    stack []<span class="type">int</span> <span class="comment">// 用于存储中序遍历的结果  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(root *TreeNode)</span></span> BSTIterator &#123;  </span><br><span class="line">    <span class="keyword">return</span> BSTIterator&#123;stack: inorderTraversal(root)&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> []<span class="type">int</span>&#123;root.Val&#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    result := []<span class="type">int</span>&#123;&#125;  </span><br><span class="line">    result = <span class="built_in">append</span>(result, inorderTraversal(root.Left)...)  </span><br><span class="line">    result = <span class="built_in">append</span>(result, root.Val)  </span><br><span class="line">    result = <span class="built_in">append</span>(result, inorderTraversal(root.Right)...)  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *BSTIterator)</span></span> Next() <span class="type">int</span> &#123;  </span><br><span class="line">    val := this.stack[<span class="number">0</span>]  </span><br><span class="line">    this.stack = this.stack[<span class="number">1</span>:]  </span><br><span class="line">    <span class="keyword">return</span> val  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *BSTIterator)</span></span> HasNext() <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(this.stack) &gt; <span class="number">0</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://colobu.com/2023/12/07/more-precise-sleep/">更精准的sleep</a><br>头一次知道time.sleep 的精度问题，想想也是哈，CPU频率就在那里，怎么可能提供那么高精度的休眠。<code>time.sleep</code> 的精度是1ms左右。如果想要更高精度的休眠，使用<code>syscall.Nanosleep</code> 可以提供ns 级别的休眠，但是它是阻塞进程的。</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#工程师工具 鼠须管，雾凇拼音方案，<a href="https://github.com/iDvel/rime-ice">https://github.com/iDvel/rime-ice</a>开箱即用的鼠须管方案，记录一下，等下忘记了。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>不要把职业（career）当成某一件具体的事情，这是人类发明的最危险、最令人窒息的概念之一，也是大多数梦想和直觉的敌人。</p>
<p>职业应该是一个抽象的概念，指的是一个人在日常的工作和生活中，不断探索、培训、实践、逐步进步的过程。</p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
      <tags>
        <tag>arts</tag>
        <tag>工程师工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS-2023-50</title>
    <url>/2023/12/11/arts/ARTS-2023-50/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode.cn/problems/is-subsequence/?envType=study-plan-v2&envId=top-interview-150">392</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(t) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	sIndex := <span class="number">0</span></span><br><span class="line">	tIndex := <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> sIndex &lt; <span class="built_in">len</span>(s) &amp;&amp; tIndex &lt; <span class="built_in">len</span>(t) &#123;</span><br><span class="line">		<span class="keyword">if</span> s[sIndex] == t[tIndex] &#123;</span><br><span class="line">			sIndex++</span><br><span class="line">		&#125;</span><br><span class="line">		tIndex++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sIndex == <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://go.dev/blog/survey2023-h2-results">Go Developer Survey 2023 H2 Results </a><br>go 社区2023年开发者报告，感觉跟2022年比较，没啥变化，最大的是，大家开始拥抱AI了。<br><a href="https://fs.blog/stop-reading-news/">Stop Reading News</a><br>大家都不看新闻了，都在看短视频 😄</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p> <a href="https://link.zhubai.love/api/link?url=https://www.insanelycooltools.com&post_id=2345899633101881344&subscriber_id=2096257190994108416&token=b3bf68a76d446e74c673027bae243b4e&timestamp=1702282461562&signature=7d5f5fa8340d2a5fe973f57ebbbb7e474835975b365d28ea4da032928d4e5ece">Insanely Cool Tools</a></p>
<p>这个网站收集了各种热门工具和服务资源，初创企业常用的一些工具和服务。<br><a href="https://github.com/trimstray/the-book-of-secret-knowledge">the-book-of-secret-knowledge</a><br>覆盖很广的网络安全知识，方方面面。</p>
<p><a href="https://github.com/microsoft/Mastering-GitHub-Copilot-for-Paired-Programming">https://github.com/microsoft/Mastering-GitHub-Copilot-for-Paired-Programming</a><br>微软出的 GitHub Copilot 教程，只有 6 堂课，会教你如何有效利用 GitHub Copilot 以及与 AI 结对编程。 课程一共 10 小时，可以体验如何通过 VSCode 和 GitHub Copilot Chat 进行实时协作，学习如何使用 GitHub Copilot 自动补全代码，处理错误和写单元测试，尽可能教会你使用 GitHub Copilot 的最佳实践，让你可以提升写代码的效率和质量。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://hexo.hxzhouh.com/2023/12/12/aws%20ec2%20%E5%88%87%E6%8D%A2%E5%88%B0ipv6/">aws ec2 切换到ipv6</a></p>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
  </entry>
  <entry>
    <title>ARTS-2023-51</title>
    <url>/2023/12/18/arts/ARTS-2023-51/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<p>本周真是懒呀。。。。。 啥都没做。</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>最近发现了 <a href="https://dave.cheney.net/">Dave Cheney</a> 大佬的博客，补课中。<br><a href="https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory">https://dave.cheney.net/2021/01/05/a-few-bytes-here-a-few-there-pretty-soon-youre-talking-real-memory</a><br>本文讲的貌似是 go 内存分配大小的问题，但是好像没看太明白。。。。</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
      <categories>
        <category>arts</category>
      </categories>
  </entry>
  <entry>
    <title>ARTS-2023-52</title>
    <url>/2023/12/25/arts/ARTS-2023-52/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>
<p>最后一周了，2024开始。。。</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isHappy</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> ; n != <span class="number">1</span> &amp;&amp; !m[n]; n, m[n] = step(n), <span class="literal">true</span> &#123; &#125;</span><br><span class="line">	<span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">step</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		sum += (n%<span class="number">10</span>) * (n%<span class="number">10</span>)</span><br><span class="line">		n = n/<span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://go.dev/ref/mem">https://go.dev/ref/mem</a>   go内存模型，终于把这篇博客看完了。</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><ul>
<li>#tools ripgrep + fzf，搜什么都快。</li>
<li><a href="https://chromewebstore.google.com/detail/%E8%B1%86%E4%BC%B4%EF%BC%9A%E8%B1%86%E7%93%A3%E8%B4%A6%E5%8F%B7%E5%A4%87%E4%BB%BD%E5%B7%A5%E5%85%B7/ghppfgfeoafdcaebjoglabppkfmbcjdd?hl=zh-CN">豆伴：豆瓣账号备份工具</a> 豆瓣重度用户，这个浏览器拓展可以将你再豆瓣的信息全部保存的到本地。 也可以导入另外的账号，好用。</li>
<li>devv.ai  面向程序员的AIGC 浏览器，</li>
</ul>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
      <categories>
        <category>arts</category>
      </categories>
  </entry>
  <entry>
    <title>ARTS-2024-01</title>
    <url>/2024/01/02/arts/ARTS-2024-01/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>
<p>2024 第一次arts 加油</p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode.cn/problems/contains-duplicate-ii/">219. 存在重复元素 II</a> 🟢<br><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a> 🟡 将数组升序排列，或者放在一个map里面，然后在去获取长度。。</p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://roytanck.com/2023/12/23/in-2024-please-switch-to-firefox/">In 2024, please switch to Firefox</a><br>firefox 好用，坚持隐私保护更加是为了维护 web 的开放标准<br>ps：有几个人会去主动选择浏览器呢？</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><blockquote>
<p>一个不成熟的理想主义者会为理想悲壮地死去，而一个成熟的理想主义者则愿意为了理想苟且偷生。  《麦田里的守望者》</p>
</blockquote>
]]></content>
      <categories>
        <category>arts</category>
      </categories>
  </entry>
  <entry>
    <title>ARTS-2024-02</title>
    <url>/2024/01/09/arts/ARTS-2024-02/</url>
    <content><![CDATA[<blockquote>
<p>ARTS 是陈浩（网名左耳朵耗子）在极客时间专栏里发起的一个活动，目的是通过分享的方式来坚持学习。 每人每周写一个 ARTS：<br>Algorithm 是一道算法题<br>Review 是读一篇英文文章<br>Technique&#x2F;Tips 是分享一个小技术<br>Share 是分享一个观点。</p>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://commandcenter.blogspot.com/2024/01/what-we-got-right-what-we-got-wrong.html">What We Got Right, What We Got Wrong</a><br>    # 做对的地方：<br>    1.  统一的规范，方便后面的使用者理解，以及实现不同的编译器，同时，为了兼容不同的编译器，反过来又影响 规范的统一。<br>    2. 多种编译器，跟1 是绑定关系<br>    3. 跨平台，<br>    4.  保持向后兼容<br>    5. 完善的文档库<br>    6. 功能强大且多样的工具<br>    7. 格式化 fmt（最喜欢的功能，不需要靠程序员自己维护统一的风格）<br>    # 做的不太好的地方<br>    1. 并发，并发!&#x3D;并行，<br>    golang 的 go（goroutine）功能，让并发编程真正的走进了每个程序员的日常生活，让go看起来像一个新的语言，很令人兴奋，有时候我们会再程序里面写一堆 go func(){} ，但是却没取到想要的结果，甚至可能代码更慢了，这很打击积极性，其中真正的原因是 并发！&#x3D;并行。<br>    2. interface<br>     主要是社区觉得没泛型，其实接口很好用的。<br>    3. 编译器<br>    4. 项目管理 社区运营总是很难的<br>    5. 包管理 深恶痛绝</p>
<h2 id="Technique-Tips"><a href="#Technique-Tips" class="headerlink" title="Technique&#x2F;Tips"></a>Technique&#x2F;Tips</h2><p>#工程师工具 <a href="https://github.com/princjef/gomarkdoc">gomarkdoc</a> 再开发代码的时候，我们需要维护一份代码以及一份文档，通常这两个部分是分开的，gomarkdoc 可以帮我们从的注释中生成接口文档，方便我们我们写文档以及维护。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2>]]></content>
      <categories>
        <category>arts</category>
      </categories>
  </entry>
</search>
